<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-Python-100-Days-master/Day21-30/code/new/vue/vue.demo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.430Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day21-30/code/new/vue/vue.demo/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="bulma.css">

<div id="app">
	<h1>库存信息</h1>
	<hr>
	<ul>
		<li v-for="product in products">
			 - 
			<input type="number" v-model.number="product.quantity" min="0">
			<span v-if="product.quantity === 0">
				已经售罄
			</span>
			<button @click="product.quantity += 1">
				增加库存
			</button>
		</li>
	</ul>
	<h2>库存总量：台</h2>
</div>

<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<script>
	const app = new Vue({
		el: '#app',
		data: {
			products: [
				{"id": 1, "name": "iPhone X", "quantity": 20},
				{"id": 2, "name": "华为 Mate20", "quantity": 0},
				{"id": 3, "name": "小米 Mix3", "quantity": 50}
			]
		},
		computed: {
			totalQuantity() {
				return this.products.reduce((sum, product) => {
					return sum + product.quantity
				}, 0);
			}
		}
	});
</script>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day21-30/code/list_by_vue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.420Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day21-30/code/list_by_vue/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>动态列表</title>
    <style>
    	* {
			margin: 0;
			padding: 0;
		}
		body {
			background-color: #000;
			color: #fff;
		}
		#app {
			width: 40%;
			margin: 20px auto;
		}
		#fruits>li {
			width: 90%;
			height: 50px;
			background-color: #6ca;
			margin: 4px 0;
			text-align: center;
			font-size: 20px;
			list-style-type: none;
			line-height: 50px;
		}
		#fruits>li>a {
			float: right;
			color: #fff;
			text-decoration: none;
			margin-right: 10px;
		}
		#fruits+div {
			margin-top: 20px;
		}
		#fname {
			width: 70%;
			height: 40px;
			color: #fff;
			border-radius: 8px;
			border: none;
			outline: none;
			font-size: 20px;
			text-align: center;
			vertical-align: middle;
			background-color: #999;
		}
		#ok {
			width: 19%;
			height: 40px;
			color: #fff;
			background-color: #a45;
			border: none;
			outline: none;
			font-size: 16px;
			vertical-align: middle;
		}
    </style>
</head>
<body>
    <div id="app">
        <ul id="fruits">
            <li v-for="fruit in fruits">
                
                <a href="" @click.prevent="removeItem(fruit)">×</a>
            </li>
        </ul>
        <div>
            <input @keydown.enter="addItem()" type="text" id="fname" v-model.trim="fname">
            <button id="ok" @click="addItem()">确定</button>
        </div>
    </div>
    <script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"></script>
    <script>
    const app = new Vue({
        el: '#app',
        data: {
            fruits: ['苹果', '香蕉', '榴莲', '火龙果'],
            fname: ''
        },
        methods: {
            addItem() {
                if (this.fname.length > 0) {
                    this.fruits.push(this.fname)
                }
                this.fname = ''
            },
            removeItem(fruit) {
				let index = this.fruits.indexOf(fruit)
				if (index >= 0) {
					this.fruits.splice(index, 1)
				}
            }
        }
    })
    </script>
</body>
</html>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day21-30/code/list_by_jquery" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.418Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day21-30/code/list_by_jquery/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>动态列表</title>
    <style>
    	* {
			margin: 0;
			padding: 0;
		}
		body {
			background-color: #000;
			color: #fff;
		}
		#app {
			width: 40%;
			margin: 20px auto;
		}
		#fruits>li {
			width: 90%;
			height: 50px;
			background-color: #6ca;
			margin: 4px 0;
			text-align: center;
			font-size: 20px;
			list-style-type: none;
			line-height: 50px;
		}
		#fruits>li>a {
			float: right;
			color: #fff;
			text-decoration: none;
			margin-right: 10px;
		}
		#fruits+div {
			margin-top: 20px;
		}
		#fname {
			width: 70%;
			height: 40px;
			color: #fff;
			border-radius: 8px;
			border: none;
			outline: none;
			font-size: 20px;
			text-align: center;
			vertical-align: middle;
			background-color: #999;
		}
		#ok {
			width: 19%;
			height: 40px;
			color: #fff;
			background-color: #a45;
			border: none;
			outline: none;
			font-size: 16px;
			vertical-align: middle;
		}
    </style>
</head>
<body>
    <div id="app">
        <ul id="fruits">
            <li>苹果<a href="">×</a></li>
            <li>香蕉<a href="">×</a></li>
            <li>榴莲<a href="">×</a></li>
            <li>火龙果<a href="">×</a></li>
        </ul>
        <div>
            <input type="text" id="fname">
            <button id="ok">确定</button>
        </div>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script>
    // 1. $函数的参数是一个函数，该函数是页面加载完成后执行的回调函数
    $(() => {
        function removeItem(evt) {
            evt.preventDefault()
            // 4. $函数的参数是原生JavaScript对象，返回该原生JavaScript对象对应的jQuery对象
            $(evt.target).parent().remove()
        }

        function addItem(evt) {
            let fname = $('#fname').val().trim()
            if (fname.length > 0) {
                $('#fruits').append(
                    // 3. $函数的参数是标签字符串，创建对应的标签元素并返回jQuery对象
                    $('<li>').text(fname).append(
                        $('<a>').attr('href', '').text('×')
                        	.on('click', removeItem)
                    )
                )
            }
            $('#fname').val('')
            // jQuery对象通过下标运算或get方法可以获得与之对应的原生JavaScript对象
            // input.get(0).focus()
            $('#fname')[0].focus()
        }

        // 2. $函数的参数是选择器字符串，返回对应元素的jQuery对象
        $('#fruits a').on('click', removeItem)
        $('#ok').on('click', addItem)
        $('#fname').on('keydown', (evt) => {
        	let code = evt.keyCode || evt.which
        	if (code == 13) {
        		addItem(evt) 
        	}
        })
    })
    </script>
</body>
</html>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day21-30/code/list_by_javascript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.415Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day21-30/code/list_by_javascript/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>动态列表</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		body {
			background-color: #000;
			color: #fff;
		}
		#app {
			width: 40%;
			margin: 20px auto;
		}
		#fruits>li {
			width: 90%;
			height: 50px;
			background-color: #6ca;
			margin: 4px 0;
			text-align: center;
			font-size: 20px;
			list-style-type: none;
			line-height: 50px;
		}
		#fruits>li>a {
			float: right;
			color: #fff;
			text-decoration: none;
			margin-right: 10px;
		}
		#fruits+div {
			margin-top: 20px;
		}
		#fname {
			width: 70%;
			height: 40px;
			color: #fff;
			border-radius: 8px;
			border: none;
			outline: none;
			font-size: 20px;
			text-align: center;
			vertical-align: middle;
			background-color: #999;
		}
		#ok {
			width: 19%;
			height: 40px;
			color: #fff;
			background-color: #a45;
			border: none;
			outline: none;
			font-size: 16px;
			vertical-align: middle;
		}
	</style>
</head>
<body>
	<div id="app">
		<ul id="fruits">
			<li>苹果<a href="">×</a></li>
			<li>香蕉<a href="">×</a></li>
			<li>榴莲<a href="">×</a></li>
			<li>火龙果<a href="">×</a></li>
		</ul>
		<div>
			<input type="text" id="fname">
			<button id="ok">确定</button>
		</div>
	</div>
	<script>
	const ul = document.querySelector('#fruits')
	const fnameInput = document.querySelector('#fname')
	const okBtn = document.querySelector('#ok')
	const anchors = document.querySelectorAll('#fruits a')

	function removeItem(evt) {
		evt.preventDefault()
		let li = evt.target.parentNode
		li.parentNode.removeChild(li)
	}

	function addItem(evt) {
		let fname = fnameInput.value.trim()
		if (fname.length > 0) {
			let li = document.createElement('li')
			li.textContent = fname
			let a = document.createElement('a')
			a.setAttribute('href', '')
			a.textContent = '×'
			a.addEventListener('click', removeItem)
			li.appendChild(a)
			ul.insertBefore(li, ul.firstElementChild)
		}
		fnameInput.value = ''
		fnameInput.focus()
	}
	
	window.addEventListener('load', (evt) => {
		for (let i = 0; i < anchors.length; i += 1) {
			anchors[i].addEventListener('click', removeItem)
		}

		fnameInput.addEventListener('keydown', (evt) => {
			let code = evt.keyCode || evt.which
			if (code == 13) {
				addItem()
			} 
		})
		
		okBtn.addEventListener('click', addItem)
	})
	</script>
</body>
</html>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day21-30/21-30.Web前端概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.408Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day21-30/21-30.Web%E5%89%8D%E7%AB%AF%E6%A6%82%E8%BF%B0/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Web前端概述"><a href="#Web前端概述" class="headerlink" title="Web前端概述"></a>Web前端概述</h2><blockquote>
<p><strong>说明</strong>：本文使用的部分插图来自<em>Jon Duckett</em>先生的*<a target="_blank" rel="noopener" href="https://www.amazon.cn/dp/1118008189/ref=sr_1_5?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=html+&+css&qid=1554609325&s=gateway&sr=8-5">HTML and CSS: Design and Build Websites</a>*一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。</p>
</blockquote>
<h3 id="HTML简史"><a href="#HTML简史" class="headerlink" title="HTML简史"></a>HTML简史</h3><ol>
<li>1991年10月：一个非正式CERN（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%B4%B2%E6%A0%B8%E5%AD%90%E7%A0%94%E7%A9%B6%E7%B5%84%E7%B9%94">欧洲核子研究中心</a>）文件首次公开18个HTML标签，这个文件的作者是物理学家<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂姆·伯纳斯-李</a>，因此他是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>的发明者，也是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F">万维网联盟</a>的主席。</li>
<li>1995年11月：HTML 2.0标准发布（RFC 1866）。</li>
<li>1997年1月：HTML 3.2作为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W3C">W3C</a>推荐标准发布。</li>
<li>1997年12月：HTML 4.0作为W3C推荐标准发布。</li>
<li> 1999年12月：HTML4.01作为W3C推荐标准发布。</li>
<li>2008年1月：HTML5由W3C作为工作草案发布。</li>
<li>2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。</li>
<li>2012年12月：W3C指定HTML5作为“候选推荐”阶段。</li>
<li>2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。</li>
</ol>
<h4 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h4><ol>
<li>引入原生多媒体支持（audio和video标签）</li>
<li>引入可编程内容（canvas标签）</li>
<li>引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签）</li>
<li>引入新的表单控件（日历、邮箱、搜索、滑条等）</li>
<li>引入对离线存储更好的支持（localStorage和sessionStorage）</li>
<li>引入对定位、拖放、WebSocket、后台任务等的支持</li>
</ol>
<h3 id="使用标签承载内容"><a href="#使用标签承载内容" class="headerlink" title="使用标签承载内容"></a>使用标签承载内容</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>html<ul>
<li>head<ul>
<li>title</li>
<li>meta</li>
</ul>
</li>
<li>body</li>
</ul>
</li>
</ul>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><ul>
<li>标题（heading）和段落（paragraph）<ul>
<li>h1 ~ h6</li>
<li>p</li>
</ul>
</li>
<li>上标（superscript）和下标（subscript）<ul>
<li>sup</li>
<li>sub</li>
</ul>
</li>
<li>空白（白色空间折叠）</li>
<li>折行（break）和水平标尺（horizontal ruler）<ul>
<li>br</li>
<li>hr</li>
</ul>
</li>
<li>语义化标签<ul>
<li>加粗和强调 - strong</li>
<li>引用 - blockquote</li>
<li>缩写词和首字母缩写词 - abbr / acronym</li>
<li>引文 - cite</li>
<li>所有者联系信息 - address</li>
<li>内容的修改 - ins / del</li>
</ul>
</li>
</ul>
<h4 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h4><ul>
<li>有序列表（ordered list）- ol / li</li>
<li>无序列表（unordered list）- ul / li</li>
<li>定义列表（definition list）- dl / dt / dd</li>
</ul>
<h4 id="链接（anchor）"><a href="#链接（anchor）" class="headerlink" title="链接（anchor）"></a>链接（anchor）</h4><ul>
<li>页面链接</li>
<li>锚链接</li>
<li>功能链接</li>
</ul>
<h4 id="图像（image）"><a href="#图像（image）" class="headerlink" title="图像（image）"></a>图像（image）</h4><ul>
<li><p>图像存储位置</p>
<p><img src="./res/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.png"></p>
</li>
<li><p>图像及其宽高</p>
</li>
<li><p>选择正确的图像格式</p>
<ul>
<li>JPEG</li>
<li>GIF</li>
<li>PNG</li>
</ul>
</li>
<li><p>矢量图</p>
</li>
<li><p>语义化标签 - figure / figcaption</p>
</li>
</ul>
<h4 id="表格（table）"><a href="#表格（table）" class="headerlink" title="表格（table）"></a>表格（table）</h4><ul>
<li>基本的表格结构 - table / tr / td / th</li>
<li>表格的标题 - caption</li>
<li>跨行和跨列 - rowspan属性 / colspan属性</li>
<li>长表格 - thead / tbody / tfoot</li>
</ul>
<h4 id="表单（form）"><a href="#表单（form）" class="headerlink" title="表单（form）"></a>表单（form）</h4><ul>
<li>重要属性 - action / method / enctype</li>
<li>表单控件（input）- type属性<ul>
<li>文本框 - text / 密码框 - password / 数字框 - number</li>
<li>邮箱 - email / 电话 - tel / 日期 - date / 滑条 - range / URL - url / 搜索 - search</li>
<li>单选按钮 - radio / 复选按钮 - checkbox</li>
<li>文件上传 - file / 隐藏域 - hidden</li>
<li>提交按钮 - submit / 图像按钮 - image  / 重置按钮 - reset</li>
</ul>
</li>
<li>下拉列表 - select / option</li>
<li>文本域（多行文本）- textarea</li>
<li>组合表单元素 - fieldset / legend</li>
</ul>
<h4 id="音视频（audio-video）"><a href="#音视频（audio-video）" class="headerlink" title="音视频（audio / video）"></a>音视频（audio / video）</h4><ul>
<li>视频格式和播放器</li>
<li>视频托管服务</li>
<li>添加视频的准备工作</li>
<li>video标签和属性 - autoplay / controls / loop / muted / preload / src</li>
<li>audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster</li>
</ul>
<h4 id="窗口（frame）"><a href="#窗口（frame）" class="headerlink" title="窗口（frame）"></a>窗口（frame）</h4><ul>
<li><p>框架集（过时，不建议使用） - frameset / frame</p>
</li>
<li><p>内嵌窗口 - iframe</p>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>文档类型</p>
<pre><code class="HTML">&lt;!doctype html&gt;
</code></pre>
<pre><code class="HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre>
<pre><code class="HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre>
</li>
<li><p>注释</p>
<pre><code class="HTML">&lt;!-- 这是一段注释，注释不能够嵌套 --&gt;
</code></pre>
</li>
<li><p>属性</p>
<ul>
<li>id：唯一标识</li>
<li>class：元素所属的类，用于区分不同的元素</li>
<li>title：元素的额外信息（鼠标悬浮时会显示工具提示文本）</li>
<li>tabindex：Tab键切换顺序</li>
<li>contenteditable：元素是否可编辑</li>
<li>draggable：元素是否可拖拽</li>
</ul>
</li>
<li><p>块级元素 / 行级元素</p>
</li>
<li><p>字符实体（实体替换符）</p>
<p><img src="./res/%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93.png"></p>
</li>
</ul>
<h3 id="使用CSS渲染页面"><a href="#使用CSS渲染页面" class="headerlink" title="使用CSS渲染页面"></a>使用CSS渲染页面</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>CSS的作用</p>
</li>
<li><p>CSS的工作原理</p>
</li>
<li><p>规则、属性和值</p>
<p><img src="./res/%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%AD%E6%B3%95.png"></p>
</li>
<li><p>常用选择器</p>
<p><img src="./res/%E5%B8%B8%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8.png"></p>
</li>
</ul>
<h4 id="颜色（color）"><a href="#颜色（color）" class="headerlink" title="颜色（color）"></a>颜色（color）</h4><ul>
<li>如何指定颜色</li>
<li>颜色术语和颜色对比</li>
<li>背景色</li>
</ul>
<h4 id="文本（text-font）"><a href="#文本（text-font）" class="headerlink" title="文本（text / font）"></a>文本（text / font）</h4><ul>
<li><p>文本的大小和字型(font-size / font-family)</p>
<p><img src="./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png"></p>
<p><img src="./res/%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E9%9D%9E%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93.png"></p>
</li>
<li><p>粗细、样式、拉伸和装饰(font-weight / font-style / font-stretch / text-decoration)</p>
<p><img src="./res/%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F.png"></p>
</li>
<li><p>行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing)</p>
</li>
<li><p>对齐(text-align)方式和缩进(text-ident)</p>
</li>
<li><p>链接样式（:link / :visited / :active / :hover）</p>
</li>
<li><p>CSS3新属性</p>
<ul>
<li>阴影效果 - text-shadow</li>
<li>首字母和首行文本(:first-letter / :first-line)</li>
<li>响应用户</li>
</ul>
</li>
</ul>
<h4 id="盒子（box-model）"><a href="#盒子（box-model）" class="headerlink" title="盒子（box model）"></a>盒子（box model）</h4><ul>
<li><p>盒子大小的控制（width / height）</p>
<p><img src="./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png"></p>
</li>
<li><p>盒子的边框、外边距和内边距（border /  margin / padding）</p>
<p><img src="./res/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png"></p>
</li>
<li><p>盒子的显示和隐藏（display / visibility）</p>
</li>
<li><p>CSS3新属性</p>
<ul>
<li>边框图像（border-image）</li>
<li>投影（border-shadow）</li>
<li>圆角（border-radius）</li>
</ul>
</li>
</ul>
<h4 id="列表、表格和表单"><a href="#列表、表格和表单" class="headerlink" title="列表、表格和表单"></a>列表、表格和表单</h4><ul>
<li>列表的项目符号（list-style）</li>
<li>表格的边框和背景（border-collapse）</li>
<li>表单控件的外观</li>
<li>表单控件的对齐</li>
<li>浏览器的开发者工具</li>
</ul>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li>控制图像的大小（display: inline-block）</li>
<li>对齐图像</li>
<li>背景图像（background / background-image / background-repeat / background-position）</li>
</ul>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ul>
<li><p>控制元素的位置（position / z-index）</p>
<ul>
<li>普通流</li>
<li>相对定位</li>
<li>绝对定位</li>
<li>固定定位</li>
<li>浮动元素（float / clear）</li>
</ul>
</li>
<li><p>网站布局</p>
<ul>
<li><p>HTML5布局</p>
<p><img src="./res/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80-2.png"></p>
</li>
</ul>
</li>
<li><p>适配屏幕尺寸</p>
<ul>
<li>固定宽度布局</li>
<li>流体布局</li>
<li>布局网格</li>
</ul>
</li>
</ul>
<h3 id="使用JavaScript控制行为"><a href="#使用JavaScript控制行为" class="headerlink" title="使用JavaScript控制行为"></a>使用JavaScript控制行为</h3><h4 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h4><ul>
<li>语句和注释</li>
<li>变量和数据类型<ul>
<li>声明和赋值</li>
<li>简单数据类型和复杂数据类型</li>
<li>变量的命名规则</li>
</ul>
</li>
<li>表达式和运算符<ul>
<li>赋值运算符</li>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
</ul>
</li>
<li>分支结构<ul>
<li><code>if...else...</code></li>
<li><code>switch...cas...default...</code></li>
</ul>
</li>
<li>循环结构<ul>
<li><code>for</code>循环</li>
<li><code>while</code>循环</li>
<li><code>do...while</code>循环</li>
</ul>
</li>
<li>数组<ul>
<li>创建数组</li>
<li>操作数组中的元素</li>
</ul>
</li>
<li>函数<ul>
<li>声明函数</li>
<li>调用函数</li>
<li>参数和返回值</li>
<li>匿名函数</li>
<li>立即调用函数</li>
</ul>
</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li>对象的概念</li>
<li>创建对象的字面量语法</li>
<li>访问成员运算符</li>
<li>创建对象的构造函数语法<ul>
<li><code>this</code>关键字</li>
</ul>
</li>
<li>添加和删除属性<ul>
<li><code>delete</code>关键字</li>
</ul>
</li>
<li>标准对象<ul>
<li><code>Number</code> / <code>String</code> / <code>Boolean</code> / <code>Symbol</code> / <code>Array</code> / <code>Function</code> </li>
<li><code>Date</code> / <code>Error</code> / <code>Math</code> / <code>RegExp</code> / <code>Object</code> / <code>Map</code> / <code>Set</code></li>
<li><code>JSON</code> / <code>Promise</code> / <code>Generator</code> / <code>Reflect</code> / <code>Proxy</code></li>
</ul>
</li>
</ul>
<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><ul>
<li><code>window</code>对象的属性和方法</li>
<li><code>history</code>对象<ul>
<li><code>forward()</code> / <code>back()</code> / <code>go()</code></li>
</ul>
</li>
<li><code>location</code>对象</li>
<li><code>navigator</code>对象</li>
<li><code>screen</code>对象</li>
</ul>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul>
<li>DOM树</li>
<li>访问元素<ul>
<li><code>getElementById()</code> / <code>querySelector()</code></li>
<li><code>getElementsByClassName()</code> / <code>getElementsByTagName()</code> / <code>querySelectorAll()</code></li>
<li><code>parentNode</code> / <code>previousSibling</code> / <code>nextSibling</code> / <code>children</code> / <code>firstChild</code> / <code>lastChild</code></li>
</ul>
</li>
<li>操作元素<ul>
<li><code>nodeValue</code></li>
<li><code>innerHTML</code> / <code>textContent</code> / <code>createElement()</code> / <code>createTextNode()</code> / <code>appendChild()</code> / <code>insertBefore()</code> / <code>removeChild()</code></li>
<li><code>className</code> / <code>id</code> / <code>hasAttribute()</code> / <code>getAttribute()</code> / <code>setAttribute()</code> / <code>removeAttribute()</code></li>
</ul>
</li>
<li>事件处理<ul>
<li>事件类型<ul>
<li>UI事件：<code>load</code> / <code>unload</code> / <code>error</code> / <code>resize</code> / <code>scroll</code></li>
<li>键盘事件：<code>keydown</code> / <code>keyup</code> / <code>keypress</code></li>
<li>鼠标事件：<code>click</code> / <code>dbclick</code> / <code>mousedown</code> / <code>mouseup</code> / <code>mousemove</code> / <code>mouseover</code> / <code>mouseout</code></li>
<li>焦点事件：<code>focus</code> / <code>blur</code></li>
<li>表单事件：<code>input</code> / <code>change</code> / <code>submit</code> / <code>reset</code> / <code>cut</code> / <code>copy</code> / <code>paste</code> / <code>select</code></li>
</ul>
</li>
<li>事件绑定<ul>
<li>HTML事件处理程序（不推荐使用，因为要做到标签与代码分离）</li>
<li>传统的DOM事件处理程序（只能附加一个回调函数）</li>
<li>事件监听器（旧的浏览器中不被支持）</li>
</ul>
</li>
<li>事件流：事件捕获 / 事件冒泡</li>
<li>事件对象（低版本IE中的window.event）<ul>
<li><code>target</code>（有些浏览器使用srcElement）</li>
<li><code>type</code></li>
<li><code>cancelable</code></li>
<li><code>preventDefault()</code></li>
<li><code>stopPropagation()</code>（低版本IE中的cancelBubble）</li>
</ul>
</li>
<li>鼠标事件 - 事件发生的位置<ul>
<li>屏幕位置：<code>screenX</code>和<code>screenY</code></li>
<li>页面位置：<code>pageX</code>和<code>pageY</code></li>
<li>客户端位置：<code>clientX</code>和<code>clientY</code></li>
</ul>
</li>
<li>键盘事件 - 哪个键被按下了<ul>
<li><code>keyCode</code>属性（有些浏览器使用<code>which</code>）</li>
<li><code>String.fromCharCode(event.keyCode)</code></li>
</ul>
</li>
<li>HTML5事件<ul>
<li><code>DOMContentLoaded</code></li>
<li><code>hashchange</code></li>
<li><code>beforeunload</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h4><ul>
<li><p>客户端存储 - <code>localStorage</code>和<code>sessionStorage</code></p>
<pre><code class="JavaScript">localStorage.colorSetting = &#39;#a4509b&#39;;
localStorage[&#39;colorSetting&#39;] = &#39;#a4509b&#39;;
localStorage.setItem(&#39;colorSetting&#39;, &#39;#a4509b&#39;);
</code></pre>
</li>
<li><p>获取位置信息 - <code>geolocation</code></p>
<pre><code class="JavaScript">navigator.geolocation.getCurrentPosition(function(pos) &#123;           
    console.log(pos.coords.latitude)
    console.log(pos.coords.longitude)
&#125;)
</code></pre>
</li>
<li><p>从服务器获取数据 - Fetch API</p>
</li>
<li><p>绘制图形 - <code>&lt;canvas&gt;</code>的API</p>
</li>
<li><p>音视频 - <code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的API</p>
</li>
</ul>
<h3 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h3><h4 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h4><ol>
<li>Write Less Do More（用更少的代码来完成更多的工作）</li>
<li>使用CSS选择器来查找元素（更简单更方便）</li>
<li>使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法）</li>
</ol>
<h4 id="引入jQuery"><a href="#引入jQuery" class="headerlink" title="引入jQuery"></a>引入jQuery</h4><ul>
<li>下载jQuery的开发版和压缩版</li>
<li>从CDN加载jQuery</li>
</ul>
<pre><code class="HTML">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    window.jQuery || 
        document.write(&#39;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&#39;)
&lt;/script&gt;
</code></pre>
<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul>
<li>选择器<ul>
<li>* / element / #id / .class / selector1, selector2</li>
<li>ancestor descendant / parent&gt;child / previous+next / previous~siblings </li>
</ul>
</li>
<li>筛选器<ul>
<li>基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus</li>
<li>内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector)</li>
<li>可见性筛选器：:hidden / :visible</li>
<li>子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child</li>
<li>属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’]</li>
</ul>
</li>
<li>表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked</li>
</ul>
<h4 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h4><ul>
<li>内容操作<ul>
<li>获取/修改内容：<code>html()</code> / <code>text()</code> / <code>replaceWith()</code> / <code>remove()</code></li>
<li>获取/设置元素：<code>before()</code> / <code>after()</code> / <code>prepend()</code> / <code>append()</code> / <code>remove()</code> / <code>clone()</code> / <code>unwrap()</code> / <code>detach()</code> / <code>empty()</code> / <code>add()</code></li>
<li>获取/修改属性：<code>attr()</code> / <code>removeAttr()</code> / <code>addClass()</code> / <code>removeClass()</code> / <code>css()</code></li>
<li>获取/设置表单值：<code>val()</code></li>
</ul>
</li>
<li>查找操作<ul>
<li>查找方法：<code>find()</code> /  <code>parent()</code> / <code>children()</code> / <code>siblings()</code> / <code>next()</code> / <code>nextAll()</code> / <code>prev()</code> / <code>prevAll()</code></li>
<li>筛选器：<code>filter()</code> / <code>not()</code> / <code>has()</code> / <code>is()</code> / <code>contains()</code></li>
<li>索引编号：<code>eq()</code></li>
</ul>
</li>
<li>尺寸和位置<ul>
<li>尺寸相关：<code>height()</code> / <code>width()</code> / <code>innerHeight()</code> / <code>innerWidth()</code> / <code>outerWidth()</code> / <code>outerHeight()</code></li>
<li>位置相关：<code>offset()</code> / <code>position()</code> / <code>scrollLeft()</code> / <code>scrollTop()</code></li>
</ul>
</li>
<li>特效和动画<ul>
<li>基本动画：<code>show()</code> / <code>hide()</code> / <code>toggle()</code></li>
<li>消失出现：<code>fadeIn()</code> / <code>fadeOut()</code> / <code>fadeTo()</code> / <code>fadeToggle()</code></li>
<li>滑动效果：<code>slideDown()</code> / <code>slideUp()</code> / <code>slideToggle()</code></li>
<li>自定义：<code>delay()</code> / <code>stop()</code> / <code>animate()</code></li>
</ul>
</li>
<li>事件<ul>
<li>文档加载：<code>ready()</code> / <code>load()</code></li>
<li>用户交互：<code>on()</code> / <code>off()</code></li>
</ul>
</li>
</ul>
<h4 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h4><h4 id="检测页面是否可用"><a href="#检测页面是否可用" class="headerlink" title="检测页面是否可用"></a>检测页面是否可用</h4><pre><code class="HTML">&lt;script&gt;
    $(document).ready(function() &#123;
        
    &#125;);
&lt;/script&gt;
</code></pre>
<pre><code class="HTML">&lt;script&gt;
    $(function() &#123;
        
    &#125;);
&lt;/script&gt;
</code></pre>
<h4 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h4><ul>
<li>jQuery Validation</li>
<li>jQuery Treeview</li>
<li>jQuery Autocomplete</li>
<li>jQuery UI</li>
</ul>
<h4 id="避免和其他库的冲突"><a href="#避免和其他库的冲突" class="headerlink" title="避免和其他库的冲突"></a>避免和其他库的冲突</h4><p>先引入其他库再引入jQuery的情况。</p>
<pre><code class="HTML">&lt;script src=&quot;other.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    jQuery.noConflict();
    jQuery(function() &#123;
        jQuery(&#39;div&#39;).hide();
    &#125;);
&lt;/script&gt;
</code></pre>
<p>先引入jQuery再引入其他库的情况。</p>
<pre><code class="HTML">
&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;other.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    jQuery(function() &#123;
        jQuery(&#39;div&#39;).hide();
    &#125;);
&lt;/script&gt;
</code></pre>
<h4 id="使用Ajax"><a href="#使用Ajax" class="headerlink" title="使用Ajax"></a>使用Ajax</h4><p>Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<ul>
<li>原生的Ajax</li>
<li>基于jQuery的Ajax<ul>
<li>加载内容</li>
<li>提交表单</li>
</ul>
</li>
</ul>
<h3 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h3><h4 id="渐进式框架-Vue-js"><a href="#渐进式框架-Vue-js" class="headerlink" title="渐进式框架 - Vue.js"></a>渐进式框架 - <a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js</a></h4><p>前后端分离开发（前端渲染）必选框架。</p>
<h5 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h5><ol>
<li><p>引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。</p>
<pre><code class="HTML">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>数据绑定（声明式渲染 ）。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;&#123;&#123; product &#125;&#125;库存信息&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            product: &#39;iPhone X&#39;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>条件与循环。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;库存信息&lt;/h1&gt;
    &lt;hr&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;product in products&quot;&gt;
            &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;
            &lt;span v-if=&quot;product.quantity === 0&quot;&gt;
                已经售罄
            &lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            products: [
                &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,
                &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,
                &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;
            ]
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>计算属性。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;库存信息&lt;/h1&gt;
    &lt;hr&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;product in products&quot;&gt;
            &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;
            &lt;span v-if=&quot;product.quantity === 0&quot;&gt;
                已经售罄
            &lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            products: [
                &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,
                &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,
                &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;
            ]
        &#125;,
        computed: &#123;
            totalQuantity() &#123;
                return this.products.reduce((sum, product) =&gt; &#123;
                    return sum + product.quantity
                &#125;, 0);
            &#125;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>处理事件。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;库存信息&lt;/h1&gt;
    &lt;hr&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;product in products&quot;&gt;
            &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;
            &lt;span v-if=&quot;product.quantity === 0&quot;&gt;
                已经售罄
            &lt;/span&gt;
            &lt;button @click=&quot;product.quantity += 1&quot;&gt;
                增加库存
            &lt;/button&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            products: [
                &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,
                &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,
                &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;
            ]
        &#125;,
        computed: &#123;
            totalQuantity() &#123;
                return this.products.reduce((sum, product) =&gt; &#123;
                    return sum + product.quantity
                &#125;, 0);
            &#125;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>用户输入。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;库存信息&lt;/h1&gt;
    &lt;hr&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;product in products&quot;&gt;
            &#123;&#123; product.name &#125;&#125; - 
            &lt;input type=&quot;number&quot; v-model.number=&quot;product.quantity&quot; min=&quot;0&quot;&gt;
            &lt;span v-if=&quot;product.quantity === 0&quot;&gt;
                已经售罄
            &lt;/span&gt;
            &lt;button @click=&quot;product.quantity += 1&quot;&gt;
                增加库存
            &lt;/button&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;/h2&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            products: [
                &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,
                &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,
                &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;
            ]
        &#125;,
        computed: &#123;
            totalQuantity() &#123;
                return this.products.reduce((sum, product) =&gt; &#123;
                    return sum + product.quantity
                &#125;, 0);
            &#125;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>通过网络加载JSON数据。</p>
<pre><code class="HTML">&lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;库存信息&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;product in products&quot;&gt;
            &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;
            &lt;span v-if=&quot;product.quantity === 0&quot;&gt;
                已经售罄
            &lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
            products: []
        &#125;，
        created() &#123;
            fetch(&#39;https://jackfrued.top/api/products&#39;)
                .then(response =&gt; response.json())
                .then(json =&gt; &#123;
                    this.products = json
                &#125;);
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="使用脚手架-vue-cli"><a href="#使用脚手架-vue-cli" class="headerlink" title="使用脚手架 - vue-cli"></a>使用脚手架 - vue-cli</h5><p>Vue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。</p>
<ol>
<li>安装脚手架。</li>
<li>创建项目。</li>
<li>安装依赖包。</li>
<li>运行项目。</li>
</ol>
<h4 id="UI框架-Element"><a href="#UI框架-Element" class="headerlink" title="UI框架 - Element"></a>UI框架 - <a target="_blank" rel="noopener" href="http://element-cn.eleme.io/#/zh-CN">Element</a></h4><p>基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。</p>
<ol>
<li><p>引入Element的CSS和JavaScript文件。</p>
<pre><code class="HTML">&lt;!-- 引入样式 --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;
&lt;!-- 引入组件库 --&gt;
&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>一个简单的例子。</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;el-button @click=&quot;visible = true&quot;&gt;点我&lt;/el-button&gt;
            &lt;el-dialog :visible.sync=&quot;visible&quot; title=&quot;Hello world&quot;&gt;
                &lt;p&gt;开始使用Element吧&lt;/p&gt;
            &lt;/el-dialog&gt;
            &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Vue(&#123;
            el: &#39;#app&#39;,
            data: &#123;
                visible: false,
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>使用组件。</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;
            &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt;
                &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt;
                &lt;/el-table-column&gt;
                &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt;
                &lt;/el-table-column&gt;
                &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;
                &lt;/el-table-column&gt;
            &lt;/el-table&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Vue(&#123;
            el: &#39;#app&#39;,
            data: &#123;
                tableData:  [
                    &#123;
                        date: &#39;2016-05-02&#39;,
                        name: &#39;王一霸&#39;,
                        address: &#39;上海市普陀区金沙江路 1518 弄&#39;
                    &#125;, 
                    &#123;
                        date: &#39;2016-05-04&#39;,
                        name: &#39;刘二狗&#39;,
                        address: &#39;上海市普陀区金沙江路 1517 弄&#39;
                    &#125;, 
                    &#123;
                        date: &#39;2016-05-01&#39;,
                        name: &#39;杨三萌&#39;,
                        address: &#39;上海市普陀区金沙江路 1519 弄&#39;
                    &#125;, 
                    &#123;
                        date: &#39;2016-05-03&#39;,
                        name: &#39;陈四吹&#39;,
                        address: &#39;上海市普陀区金沙江路 1516 弄&#39;
                    &#125;
                ]
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
<h4 id="报表框架-ECharts"><a href="#报表框架-ECharts" class="headerlink" title="报表框架 - ECharts"></a>报表框架 - <a target="_blank" rel="noopener" href="https://echarts.baidu.com/">ECharts</a></h4><p>百度出品的开源可视化库，常用于生成各种类型的报表。</p>
<p><img src="./res/baidu_echarts.png"></p>
<h4 id="基于弹性盒子的CSS框架-Bulma"><a href="#基于弹性盒子的CSS框架-Bulma" class="headerlink" title="基于弹性盒子的CSS框架 - Bulma"></a>基于弹性盒子的CSS框架 - <a target="_blank" rel="noopener" href="https://bulma.io/">Bulma</a></h4><p>Bulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Bulma&lt;/title&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bulma/0.7.4/css/bulma.min.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        div &#123; margin-top: 10px; &#125;
        .column &#123; color: #fff; background-color: #063; margin: 10px 10px; text-align: center; &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;columns&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;1&lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;2&lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;3&lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;4&lt;/div&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;a class=&quot;button is-primary&quot;&gt;Primary&lt;/a&gt;
        &lt;a class=&quot;button is-link&quot;&gt;Link&lt;/a&gt;
        &lt;a class=&quot;button is-info&quot;&gt;Info&lt;/a&gt;
        &lt;a class=&quot;button is-success&quot;&gt;Success&lt;/a&gt;
        &lt;a class=&quot;button is-warning&quot;&gt;Warning&lt;/a&gt;
        &lt;a class=&quot;button is-danger&quot;&gt;Danger&lt;/a&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;progress class=&quot;progress is-danger is-medium&quot; max=&quot;100&quot;&gt;60%&lt;/progress&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;table class=&quot;table is-hoverable&quot;&gt;
            &lt;tr&gt;
                &lt;th&gt;One&lt;/th&gt;
                &lt;th&gt;Two&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Three&lt;/td&gt;
                &lt;td&gt;Four&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Five&lt;/td&gt;
                &lt;td&gt;Six&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Seven&lt;/td&gt;
                &lt;td&gt;Eight&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Nine&lt;/td&gt;
                &lt;td&gt;Ten&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;Eleven&lt;/td&gt;
                &lt;td&gt;Twelve&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="响应式布局框架-Bootstrap"><a href="#响应式布局框架-Bootstrap" class="headerlink" title="响应式布局框架 - Bootstrap"></a>响应式布局框架 - <a target="_blank" rel="noopener" href="http://www.bootcss.com/">Bootstrap</a></h4><p>用于快速开发Web应用程序的前端框架，支持响应式布局。</p>
<ol>
<li><p>特点</p>
<ul>
<li>支持主流的浏览器和移动设备</li>
<li>容易上手</li>
<li>响应式设计</li>
</ul>
</li>
<li><p>内容</p>
<ul>
<li>网格系统</li>
<li>封装的CSS</li>
<li>现成的组件</li>
<li>JavaScript插件</li>
</ul>
</li>
<li><p>可视化</p>
<p><img src="./res/bootstrap-layoutit.png">    </p>
</li>
</ol>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day16-20/16-20.Python语言进阶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:54.321Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day16-20/16-20.Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Python语言进阶"><a href="#Python语言进阶" class="headerlink" title="Python语言进阶"></a>Python语言进阶</h2><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ul>
<li><p>生成式（推导式）的用法</p>
<pre><code class="Python">prices = &#123;
    &#39;AAPL&#39;: 191.88,
    &#39;GOOG&#39;: 1186.96,
    &#39;IBM&#39;: 149.24,
    &#39;ORCL&#39;: 48.44,
    &#39;ACN&#39;: 166.89,
    &#39;FB&#39;: 208.09,
    &#39;SYMC&#39;: 21.29
&#125;
# 用股票价格大于100元的股票构造一个新的字典
prices2 = &#123;key: value for key, value in prices.items() if value &gt; 100&#125;
print(prices2)
</code></pre>
<blockquote>
<p>说明：生成式（推导式）可以用来生成列表、集合和字典。</p>
</blockquote>
</li>
<li><p>嵌套的列表的坑</p>
<pre><code class="Python">names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]
courses = [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;]
# 录入五个学生三门课程的成绩
# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit
# scores = [[None] * len(courses)] * len(names)
scores = [[None] * len(courses) for _ in range(len(names))]
for row, name in enumerate(names):
    for col, course in enumerate(courses):
        scores[row][col] = float(input(f&#39;请输入&#123;name&#125;的&#123;course&#125;成绩: &#39;))
        print(scores)
</code></pre>
<p><a target="_blank" rel="noopener" href="http://pythontutor.com/">Python Tutor</a> - VISUALIZE CODE AND GET LIVE HELP</p>
</li>
<li><p><code>heapq</code>模块（堆排序）</p>
<pre><code class="Python">&quot;&quot;&quot;
从列表中找出最大的或最小的N个元素
堆结构(大根堆/小根堆)
&quot;&quot;&quot;
import heapq

list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]
list2 = [
    &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,
    &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,
    &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,
    &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,
    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,
    &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;
]
print(heapq.nlargest(3, list1))
print(heapq.nsmallest(3, list1))
print(heapq.nlargest(2, list2, key=lambda x: x[&#39;price&#39;]))
print(heapq.nlargest(2, list2, key=lambda x: x[&#39;shares&#39;]))
</code></pre>
</li>
<li><p><code>itertools</code>模块</p>
<pre><code class="Python">&quot;&quot;&quot;
迭代工具模块
&quot;&quot;&quot;
import itertools

# 产生ABCD的全排列
itertools.permutations(&#39;ABCD&#39;)
# 产生ABCDE的五选三组合
itertools.combinations(&#39;ABCDE&#39;, 3)
# 产生ABCD和123的笛卡尔积
itertools.product(&#39;ABCD&#39;, &#39;123&#39;)
# 产生ABC的无限循环序列
itertools.cycle((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))
</code></pre>
</li>
<li><p><code>collections</code>模块</p>
<p>常用的工具类：</p>
<ul>
<li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li>
<li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素是，deque会表现出更好的性能，渐近时间复杂度为$O(1)$。</li>
<li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li>
<li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li>
<li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li>
</ul>
<pre><code class="Python">&quot;&quot;&quot;
找出序列中出现次数最多的元素
&quot;&quot;&quot;
from collections import Counter

words = [
    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;,
    &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;,
    &#39;the&#39;, &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;,
    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39;
]
counter = Counter(words)
print(counter.most_common(3))
</code></pre>
</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul>
<li><p>算法：解决问题的方法和步骤</p>
</li>
<li><p>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</p>
</li>
<li><p>渐近时间复杂度的大O标记：</p>
<ul>
<li><img src="http://latex.codecogs.com/gif.latex?O(c)" /> - 常量时间复杂度 - 布隆过滤器 / 哈希存储</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(log_2n)" /> - 对数时间复杂度 - 折半查找（二分查找）</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(n)" /> - 线性时间复杂度 - 顺序查找 / 计数排序</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(n*log_2n)" /> - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(n^2)" /> - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(n^3)" /> - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(2^n)" /> - 几何级数时间复杂度 - 汉诺塔</li>
<li><img src="http://latex.codecogs.com/gif.latex?O(n!)" /> - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li>
</ul>
<p><img src="https://gitee.com/lipaisan/image-bed/raw/master/md_img/20211019150805.png"></p>
<p><img src="https://gitee.com/lipaisan/image-bed/raw/master/md_img/20211019150805-1.png"></p>
</li>
<li><p>排序算法（选择、冒泡和归并）和查找算法（顺序和折半）</p>
<pre><code class="Python">def select_sort(items, comp=lambda x, y: x &lt; y):
    &quot;&quot;&quot;简单选择排序&quot;&quot;&quot;
    items = items[:]
    for i in range(len(items) - 1):
        min_index = i
        for j in range(i + 1, len(items)):
            if comp(items[j], items[min_index]):
                min_index = j
        items[i], items[min_index] = items[min_index], items[i]
    return items
</code></pre>
<pre><code class="Python">def bubble_sort(items, comp=lambda x, y: x &gt; y):
    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if not swapped:
            break
    return items
</code></pre>
<pre><code class="Python">def bubble_sort(items, comp=lambda x, y: x &gt; y):
    &quot;&quot;&quot;搅拌排序(冒泡排序升级版)&quot;&quot;&quot;
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if swapped:
            swapped = False
            for j in range(len(items) - 2 - i, i, -1):
                if comp(items[j - 1], items[j]):
                    items[j], items[j - 1] = items[j - 1], items[j]
                    swapped = True
        if not swapped:
            break
    return items
</code></pre>
<pre><code class="Python">def merge(items1, items2, comp=lambda x, y: x &lt; y):
    &quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot;
    items = []
    index1, index2 = 0, 0
    while index1 &lt; len(items1) and index2 &lt; len(items2):
        if comp(items1[index1], items2[index2]):
            items.append(items1[index1])
            index1 += 1
        else:
            items.append(items2[index2])
            index2 += 1
    items += items1[index1:]
    items += items2[index2:]
    return items


def merge_sort(items, comp=lambda x, y: x &lt; y):
    return _merge_sort(list(items), comp)


def _merge_sort(items, comp):
    &quot;&quot;&quot;归并排序&quot;&quot;&quot;
    if len(items) &lt; 2:
        return items
    mid = len(items) // 2
    left = _merge_sort(items[:mid], comp)
    right = _merge_sort(items[mid:], comp)
    return merge(left, right, comp)
</code></pre>
<pre><code class="Python">def seq_search(items, key):
    &quot;&quot;&quot;顺序查找&quot;&quot;&quot;
    for index, item in enumerate(items):
        if item == key:
            return index
    return -1
</code></pre>
<pre><code class="Python">def bin_search(items, key):
    &quot;&quot;&quot;折半查找&quot;&quot;&quot;
    start, end = 0, len(items) - 1
    while start &lt;= end:
        mid = (start + end) // 2
        if key &gt; items[mid]:
            start = mid + 1
        elif key &lt; items[mid]:
            end = mid - 1
        else:
            return mid
    return -1
</code></pre>
</li>
<li><p>常用算法：</p>
<ul>
<li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li>
<li>贪婪法 - 在对问题求解时，总是做出在当前看来</li>
<li>最好的选择，不追求最优解，快速找到满意解。</li>
<li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li>
<li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li>
<li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li>
</ul>
<p>穷举法例子：百钱百鸡和五人分鱼。</p>
<pre><code class="Python"># 公鸡5元一只 母鸡3元一只 小鸡1元三只
# 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
for x in range(20):
    for y in range(33):
        z = 100 - x - y
        if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
            print(x, y, z)

# A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
# 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
# B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
# 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
fish = 6
while True:
    total = fish
    enough = True
    for _ in range(5):
        if (total - 1) % 5 == 0:
            total = (total - 1) // 5 * 4
        else:
            enough = False
            break
    if enough:
        print(fish)
        break
    fish += 5
</code></pre>
<p>贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">价格（美元）</th>
<th align="center">重量（kg）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">电脑</td>
<td align="center">200</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">收音机</td>
<td align="center">20</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">钟</td>
<td align="center">175</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">花瓶</td>
<td align="center">50</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">书</td>
<td align="center">10</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">油画</td>
<td align="center">90</td>
<td align="center">9</td>
</tr>
</tbody></table>
<pre><code class="Python">&quot;&quot;&quot;
贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
输入：
20 6
电脑 200 20
收音机 20 4
钟 175 10
花瓶 50 2
书 10 1
油画 90 9
&quot;&quot;&quot;
class Thing(object):
    &quot;&quot;&quot;物品&quot;&quot;&quot;

    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight

    @property
    def value(self):
        &quot;&quot;&quot;价格重量比&quot;&quot;&quot;
        return self.price / self.weight


def input_thing():
    &quot;&quot;&quot;输入物品信息&quot;&quot;&quot;
    name_str, price_str, weight_str = input().split()
    return name_str, int(price_str), int(weight_str)


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    max_weight, num_of_things = map(int, input().split())
    all_things = []
    for _ in range(num_of_things):
        all_things.append(Thing(*input_thing()))
    all_things.sort(key=lambda x: x.value, reverse=True)
    total_weight = 0
    total_price = 0
    for thing in all_things:
        if total_weight + thing.weight &lt;= max_weight:
            print(f&#39;小偷拿走了&#123;thing.name&#125;&#39;)
            total_weight += thing.weight
            total_price += thing.price
    print(f&#39;总价值: &#123;total_price&#125;美元&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>分治法例子：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>。</p>
<pre><code class="Python">&quot;&quot;&quot;
快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大
&quot;&quot;&quot;
def quick_sort(items, comp=lambda x, y: x &lt;= y):
    items = list(items)[:]
    _quick_sort(items, 0, len(items) - 1, comp)
    return items


def _quick_sort(items, start, end, comp):
    if start &lt; end:
        pos = _partition(items, start, end, comp)
        _quick_sort(items, start, pos - 1, comp)
        _quick_sort(items, pos + 1, end, comp)


def _partition(items, start, end, comp):
    pivot = items[end]
    i = start - 1
    for j in range(start, end):
        if comp(items[j], pivot):
            i += 1
            items[i], items[j] = items[j], items[i]
    items[i + 1], items[end] = items[end], items[i + 1]
    return i + 1
</code></pre>
<p>回溯法例子：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E9%AA%91%E5%A3%AB%E5%B7%A1%E9%80%BB">骑士巡逻</a>。</p>
<pre><code class="Python">&quot;&quot;&quot;
递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。
&quot;&quot;&quot;
import sys
import time

SIZE = 5
total = 0


def print_board(board):
    for row in board:
        for col in row:
            print(str(col).center(4), end=&#39;&#39;)
        print()


def patrol(board, row, col, step=1):
    if row &gt;= 0 and row &lt; SIZE and \
        col &gt;= 0 and col &lt; SIZE and \
        board[row][col] == 0:
        board[row][col] = step
        if step == SIZE * SIZE:
            global total
            total += 1
            print(f&#39;第&#123;total&#125;种走法: &#39;)
            print_board(board)
        patrol(board, row - 2, col - 1, step + 1)
        patrol(board, row - 1, col - 2, step + 1)
        patrol(board, row + 1, col - 2, step + 1)
        patrol(board, row + 2, col - 1, step + 1)
        patrol(board, row + 2, col + 1, step + 1)
        patrol(board, row + 1, col + 2, step + 1)
        patrol(board, row - 1, col + 2, step + 1)
        patrol(board, row - 2, col + 1, step + 1)
        board[row][col] = 0


def main():
    board = [[0] * SIZE for _ in range(SIZE)]
    patrol(board, SIZE - 1, SIZE - 1)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>动态规划例子：子列表元素之和的最大值。</p>
<blockquote>
<p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p>
<p>输入：1 -2 3 5 -3 2</p>
<p>输出：8</p>
<p>输入：0 -2 3 5 -1 2</p>
<p>输出：9</p>
<p>输入：-9 -2 -3 -5 -3</p>
<p>输出：-2</p>
</blockquote>
<pre><code class="Python">def main():
    items = list(map(int, input().split()))
    overall = partial = items[0]
    for i in range(1, len(items)):
        partial = max(items[i], partial + items[i])
        overall = max(partial, overall)
    print(overall)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。</p>
</blockquote>
</li>
</ul>
<h3 id="函数的使用方式"><a href="#函数的使用方式" class="headerlink" title="函数的使用方式"></a>函数的使用方式</h3><ul>
<li><p>将函数视为“一等公民”</p>
<ul>
<li>函数可以赋值给变量</li>
<li>函数可以作为函数的参数</li>
<li>函数可以作为函数的返回值</li>
</ul>
</li>
<li><p>高阶函数的用法（<code>filter</code>、<code>map</code>以及它们的替代品）</p>
<pre><code class="Python">items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))
items2 = [x ** 2 for x in range(1, 10) if x % 2]
</code></pre>
</li>
<li><p>位置参数、可变参数、关键字参数、命名关键字参数</p>
</li>
<li><p>参数的元信息（代码可读性问题）</p>
</li>
<li><p>匿名函数和内联函数的用法（<code>lambda</code>函数）</p>
</li>
<li><p>闭包和作用域问题</p>
<ul>
<li><p>Python搜索变量的LEGB顺序（Local &gt;&gt;&gt; Embedded &gt;&gt;&gt; Global &gt;&gt;&gt; Built-in）</p>
</li>
<li><p><code>global</code>和<code>nonlocal</code>关键字的作用</p>
<p><code>global</code>：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p>
<p><code>nonlocal</code>：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p>
</li>
</ul>
</li>
<li><p>装饰器函数（使用装饰器和取消装饰器）</p>
<p>例子：输出函数执行时间的装饰器。</p>
<pre><code class="Python">def record_time(func):
    &quot;&quot;&quot;自定义装饰函数的装饰器&quot;&quot;&quot;
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        print(f&#39;&#123;func.__name__&#125;: &#123;time() - start&#125;秒&#39;)
        return result
        
    return wrapper
</code></pre>
<p>如果装饰器不希望跟<code>print</code>函数耦合，可以编写可以参数化的装饰器。</p>
<pre><code class="Python">from functools import wraps
from time import time


def record(output):
    &quot;&quot;&quot;可以参数化的装饰器&quot;&quot;&quot;
    
    def decorate(func):
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time()
            result = func(*args, **kwargs)
            output(func.__name__, time() - start)
            return result
            
        return wrapper
    
    return decorate
</code></pre>
<pre><code class="Python">from functools import wraps
from time import time


class Record():
    &quot;&quot;&quot;通过定义类的方式定义装饰器&quot;&quot;&quot;

    def __init__(self, output):
        self.output = output

    def __call__(self, func):

        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time()
            result = func(*args, **kwargs)
            self.output(func.__name__, time() - start)
            return result

        return wrapper
</code></pre>
<blockquote>
<p><strong>说明</strong>：由于对带装饰功能的函数添加了@wraps装饰器，可以通过<code>func.__wrapped__</code>方式获得被装饰之前的函数或类来取消装饰器的作用。</p>
</blockquote>
<p>例子：用装饰器来实现单例模式。</p>
<pre><code class="Python">from functools import wraps


def singleton(cls):
    &quot;&quot;&quot;装饰类的装饰器&quot;&quot;&quot;
    instances = &#123;&#125;

    @wraps(cls)
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return wrapper


@singleton
class President:
    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;
    pass
</code></pre>
<blockquote>
<p><strong>提示</strong>：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？</p>
</blockquote>
<p>线程安全的单例装饰器。</p>
<pre><code class="Python">from functools import wraps
from threading import RLock


def singleton(cls):
    &quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot;
    instances = &#123;&#125;
    locker = RLock()

    @wraps(cls)
    def wrapper(*args, **kwargs):
        if cls not in instances:
            with locker:
                if cls not in instances:
                    instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return wrapper
</code></pre>
<blockquote>
<p><strong>提示</strong>：上面的代码用到了<code>with</code>上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持<code>__enter__</code>和<code>__exit__</code>魔术方法）。在<code>wrapper</code>函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。</p>
</blockquote>
</li>
</ul>
<h3 id="面向对象相关知识"><a href="#面向对象相关知识" class="headerlink" title="面向对象相关知识"></a>面向对象相关知识</h3><ul>
<li><p>三大支柱：封装、继承、多态</p>
<p>例子：工资结算系统。</p>
<pre><code class="Python">&quot;&quot;&quot;
月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成
&quot;&quot;&quot;
from abc import ABCMeta, abstractmethod


class Employee(metaclass=ABCMeta):
    &quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot;

    def __init__(self, name):
        self.name = name

    @abstractmethod
    def get_salary(self):
        &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot;
        pass


class Manager(Employee):
    &quot;&quot;&quot;部门经理&quot;&quot;&quot;

    def get_salary(self):
        return 15000.0


class Programmer(Employee):
    &quot;&quot;&quot;程序员&quot;&quot;&quot;

    def __init__(self, name, working_hour=0):
        self.working_hour = working_hour
        super().__init__(name)

    def get_salary(self):
        return 200.0 * self.working_hour


class Salesman(Employee):
    &quot;&quot;&quot;销售员&quot;&quot;&quot;

    def __init__(self, name, sales=0.0):
        self.sales = sales
        super().__init__(name)

    def get_salary(self):
        return 1800.0 + self.sales * 0.05


class EmployeeFactory:
    &quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot;

    @staticmethod
    def create(emp_type, *args, **kwargs):
        &quot;&quot;&quot;创建员工&quot;&quot;&quot;
        all_emp_types = &#123;&#39;M&#39;: Manager, &#39;P&#39;: Programmer, &#39;S&#39;: Salesman&#125;
        cls = all_emp_types[emp_type.upper()]
        return cls(*args, **kwargs) if cls else None


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    emps = [
        EmployeeFactory.create(&#39;M&#39;, &#39;曹操&#39;), 
        EmployeeFactory.create(&#39;P&#39;, &#39;荀彧&#39;, 120),
        EmployeeFactory.create(&#39;P&#39;, &#39;郭嘉&#39;, 85), 
        EmployeeFactory.create(&#39;S&#39;, &#39;典韦&#39;, 123000),
    ]
    for emp in emps:
        print(f&#39;&#123;emp.name&#125;: &#123;emp.get_salary():.2f&#125;元&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
</li>
<li><p>类与类之间的关系</p>
<ul>
<li>is-a关系：继承</li>
<li>has-a关系：关联 / 聚合 / 合成</li>
<li>use-a关系：依赖</li>
</ul>
<p>例子：扑克游戏。</p>
<pre><code class="Python">&quot;&quot;&quot;
经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择
&quot;&quot;&quot;
from enum import Enum, unique

import random


@unique
class Suite(Enum):
    &quot;&quot;&quot;花色&quot;&quot;&quot;

    SPADE, HEART, CLUB, DIAMOND = range(4)

    def __lt__(self, other):
        return self.value &lt; other.value


class Card():
    &quot;&quot;&quot;牌&quot;&quot;&quot;

    def __init__(self, suite, face):
        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;
        self.suite = suite
        self.face = face

    def show(self):
        &quot;&quot;&quot;显示牌面&quot;&quot;&quot;
        suites = [&#39;♠︎&#39;, &#39;♥︎&#39;, &#39;♣︎&#39;, &#39;♦︎&#39;]
        faces = [&#39;&#39;, &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;]
        return f&#39;&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;&#39;

    def __repr__(self):
        return self.show()


class Poker():
    &quot;&quot;&quot;扑克&quot;&quot;&quot;

    def __init__(self):
        self.index = 0
        self.cards = [Card(suite, face)
                      for suite in Suite
                      for face in range(1, 14)]

    def shuffle(self):
        &quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot;
        random.shuffle(self.cards)
        self.index = 0

    def deal(self):
        &quot;&quot;&quot;发牌&quot;&quot;&quot;
        card = self.cards[self.index]
        self.index += 1
        return card

    @property
    def has_more(self):
        return self.index &lt; len(self.cards)


class Player():
    &quot;&quot;&quot;玩家&quot;&quot;&quot;

    def __init__(self, name):
        self.name = name
        self.cards = []

    def get_one(self, card):
        &quot;&quot;&quot;摸一张牌&quot;&quot;&quot;
        self.cards.append(card)

    def sort(self, comp=lambda card: (card.suite, card.face)):
        &quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;
        self.cards.sort(key=comp)


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    poker = Poker()
    poker.shuffle()
    players = [Player(&#39;东邪&#39;), Player(&#39;西毒&#39;), Player(&#39;南帝&#39;), Player(&#39;北丐&#39;)]
    while poker.has_more:
        for player in players:
                player.get_one(poker.deal())
    for player in players:
        player.sort()
        print(player.name, end=&#39;: &#39;)
        print(player.cards)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>说明</strong>：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。</p>
</blockquote>
</li>
<li><p>对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）</p>
</li>
<li><p>垃圾回收、循环引用和弱引用</p>
<p>Python使用了自动化内存管理，这种管理机制以<strong>引用计数</strong>为基础，同时也引入了<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p>
<pre><code class="C">typedef struct _object &#123;
    /* 引用计数 */
    int ob_refcnt;
    /* 对象指针 */
    struct _typeobject *ob_type;
&#125; PyObject;
</code></pre>
<pre><code class="C">/* 增加引用计数的宏定义 */
#define Py_INCREF(op)   ((op)-&gt;ob_refcnt++)
/* 减少引用计数的宏定义 */
#define Py_DECREF(op) \ //减少计数
    if (--(op)-&gt;ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
</code></pre>
<p>导致引用计数+1的情况：</p>
<ul>
<li>对象被创建，例如<code>a = 23</code></li>
<li>对象被引用，例如<code>b = a</code></li>
<li>对象被作为参数，传入到一个函数中，例如<code>f(a)</code></li>
<li>对象作为一个元素，存储在容器中，例如<code>list1 = [a, a]</code></li>
</ul>
<p>导致引用计数-1的情况：</p>
<ul>
<li>对象的别名被显式销毁，例如<code>del a</code></li>
<li>对象的别名被赋予新的对象，例如<code>a = 24</code></li>
<li>一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）</li>
<li>对象所在的容器被销毁，或从容器中删除对象</li>
</ul>
<p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p>
<pre><code class="Python"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收
# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效
# 如果不想造成循环引用可以使用弱引用
list1 = []
list2 = [] 
list1.append(list2)
list2.append(list1)
</code></pre>
<p>以下情况会导致垃圾回收：</p>
<ul>
<li>调用<code>gc.collect()</code></li>
<li><code>gc</code>模块的计数器达到阀值</li>
<li>程序退出</li>
</ul>
<p>如果循环引用中两个对象都定义了<code>__del__</code>方法，<code>gc</code>模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，这个问题在Python 3.6中得到了解决。</p>
<p>也可以通过<code>weakref</code>模块构造弱引用的方式来解决循环引用的问题。</p>
</li>
<li><p>魔法属性和方法（请参考《Python魔法方法指南》）</p>
<p>有几个小问题请大家思考：</p>
<ul>
<li>自定义的对象能不能使用运算符做运算？</li>
<li>自定义的对象能不能放到<code>set</code>中？能去重吗？</li>
<li>自定义的对象能不能作为<code>dict</code>的键？</li>
<li>自定义的对象能不能使用上下文语法？</li>
</ul>
</li>
<li><p>混入（Mixin）</p>
<p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p>
<pre><code class="Python">class SetOnceMappingMixin:
    &quot;&quot;&quot;自定义混入类&quot;&quot;&quot;
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + &#39; already set&#39;)
        return super().__setitem__(key, value)


class SetOnceDict(SetOnceMappingMixin, dict):
    &quot;&quot;&quot;自定义字典&quot;&quot;&quot;
    pass


my_dict= SetOnceDict()
try:
    my_dict[&#39;username&#39;] = &#39;jackfrued&#39;
    my_dict[&#39;username&#39;] = &#39;hellokitty&#39;
except KeyError:
    pass
print(my_dict)
</code></pre>
</li>
<li><p>元编程和元类</p>
<p>对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自<code>object</code>，所有的元类都直接或间接的继承自<code>type</code>。</p>
<p>例子：用元类实现单例模式。</p>
<pre><code class="Python">import threading


class SingletonMeta(type):
    &quot;&quot;&quot;自定义元类&quot;&quot;&quot;

    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        cls.__lock = threading.RLock()
        super().__init__(*args, **kwargs)

    def __call__(cls, *args, **kwargs):
        if cls.__instance is None:
            with cls.__lock:
                if cls.__instance is None:
                    cls.__instance = super().__call__(*args, **kwargs)
        return cls.__instance


class President(metaclass=SingletonMeta):
    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;
    
    pass
</code></pre>
</li>
<li><p>面向对象设计原则</p>
<ul>
<li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li>
<li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li>
<li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li>
<li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li>
<li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）</li>
<li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li>
<li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li>
</ul>
<blockquote>
<p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p>
</blockquote>
</li>
<li><p>GoF设计模式</p>
<ul>
<li>创建型模式：单例、工厂、建造者、原型</li>
<li>结构型模式：适配器、门面（外观）、代理</li>
<li>行为型模式：迭代器、观察者、状态、策略</li>
</ul>
<p>例子：可插拔的哈希算法（策略模式）。</p>
<pre><code class="Python">class StreamHasher():
    &quot;&quot;&quot;哈希摘要生成器&quot;&quot;&quot;

    def __init__(self, alg=&#39;md5&#39;, size=4096):
        self.size = size
        alg = alg.lower()
        self.hasher = getattr(__import__(&#39;hashlib&#39;), alg.lower())()

    def __call__(self, stream):
        return self.to_digest(stream)

    def to_digest(self, stream):
        &quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot;
        for buf in iter(lambda: stream.read(self.size), b&#39;&#39;):
            self.hasher.update(buf)
        return self.hasher.hexdigest()

def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    hasher1 = StreamHasher()
    with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream:
        print(hasher1.to_digest(stream))
    hasher2 = StreamHasher(&#39;sha1&#39;)
    with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream:
        print(hasher2(stream))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
</li>
</ul>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><ul>
<li><p>迭代器是实现了迭代器协议的对象。</p>
<ul>
<li>Python中没有像<code>protocol</code>或<code>interface</code>这样的定义协议的关键字。</li>
<li>Python中用魔术方法表示协议。</li>
<li><code>__iter__</code>和<code>__next__</code>魔术方法就是迭代器协议。</li>
</ul>
<pre><code class="Python">class Fib(object):
    &quot;&quot;&quot;迭代器&quot;&quot;&quot;
    
    def __init__(self, num):
        self.num = num
        self.a, self.b = 0, 1
        self.idx = 0
   
    def __iter__(self):
        return self

    def __next__(self):
        if self.idx &lt; self.num:
            self.a, self.b = self.b, self.a + self.b
            self.idx += 1
            return self.a
        raise StopIteration()
</code></pre>
</li>
<li><p>生成器是语法简化版的迭代器。</p>
<pre><code class="Python">def fib(num):
    &quot;&quot;&quot;生成器&quot;&quot;&quot;
    a, b = 0, 1
    for _ in range(num):
        a, b = b, a + b
        yield a
</code></pre>
</li>
<li><p>生成器进化为协程。</p>
<p>生成器对象可以使用<code>send()</code>方法发送数据，发送的数据会成为生成器函数中通过<code>yield</code>表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。</p>
<pre><code class="Python">def calc_avg():
    &quot;&quot;&quot;流式计算平均值&quot;&quot;&quot;
    total, counter = 0, 0
    avg_value = None
    while True:
        value = yield avg_value
        total, counter = total + value, counter + 1
        avg_value = total / counter


gen = calc_avg()
next(gen)
print(gen.send(10))
print(gen.send(20))
print(gen.send(30))
</code></pre>
</li>
</ul>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。</p>
<ul>
<li><p>多线程：Python中提供了<code>Thread</code>类并辅以<code>Lock</code>、<code>Condition</code>、<code>Event</code>、<code>Semaphore</code>和<code>Barrier</code>。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。</p>
<pre><code class="Python">&quot;&quot;&quot;
面试题：进程和线程的区别和联系？
进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程
线程 - 操作系统分配CPU的基本单位
并发编程（concurrent programming）
1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行
2. 改善用户体验 - 让耗时间的操作不会造成程序的假死
&quot;&quot;&quot;
import glob
import os
import threading

from PIL import Image

PREFIX = &#39;thumbnails&#39;


def generate_thumbnail(infile, size, format=&#39;PNG&#39;):
    &quot;&quot;&quot;生成指定图片文件的缩略图&quot;&quot;&quot;
    file, ext = os.path.splitext(infile)
    file = file[file.rfind(&#39;/&#39;) + 1:]
    outfile = f&#39;&#123;PREFIX&#125;/&#123;file&#125;_&#123;size[0]&#125;_&#123;size[1]&#125;.&#123;ext&#125;&#39;
    img = Image.open(infile)
    img.thumbnail(size, Image.ANTIALIAS)
    img.save(outfile, format)


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    if not os.path.exists(PREFIX):
        os.mkdir(PREFIX)
    for infile in glob.glob(&#39;images/*.png&#39;):
        for size in (32, 64, 128):
            # 创建并启动线程
            threading.Thread(
                target=generate_thumbnail, 
                args=(infile, (size, size))
            ).start()
            

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>多个线程竞争资源的情况。</p>
<pre><code class="Python">&quot;&quot;&quot;
多线程程序如果没有竞争资源处理起来通常也比较简单
当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱
说明：临界资源就是被多个线程竞争的资源
&quot;&quot;&quot;
import time
import threading

from concurrent.futures import ThreadPoolExecutor


class Account(object):
    &quot;&quot;&quot;银行账户&quot;&quot;&quot;

    def __init__(self):
        self.balance = 0.0
        self.lock = threading.Lock()

    def deposit(self, money):
        # 通过锁保护临界资源
        with self.lock:
            new_balance = self.balance + money
            time.sleep(0.001)
            self.balance = new_balance


class AddMoneyThread(threading.Thread):
    &quot;&quot;&quot;自定义线程类&quot;&quot;&quot;

    def __init__(self, account, money):
        self.account = account
        self.money = money
        # 自定义线程的初始化方法中必须调用父类的初始化方法
        super().__init__()

    def run(self):
        # 线程启动之后要执行的操作
        self.account.deposit(self.money)

def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    account = Account()
    # 创建线程池
    pool = ThreadPoolExecutor(max_workers=10)
    futures = []
    for _ in range(100):
        # 创建线程的第1种方式
        # threading.Thread(
        #     target=account.deposit, args=(1, )
        # ).start()
        # 创建线程的第2种方式
        # AddMoneyThread(account, 1).start()
        # 创建线程的第3种方式
        # 调用线程池中的线程来执行特定的任务
        future = pool.submit(account.deposit, 1)
        futures.append(future)
    # 关闭线程池
    pool.shutdown()
    for future in futures:
        future.result()
    print(account.balance)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的<code>Condition</code>来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p>
<pre><code class="Python">&quot;&quot;&quot;
多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）
多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）
多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition
&quot;&quot;&quot;
from concurrent.futures import ThreadPoolExecutor
from random import randint
from time import sleep

import threading


class Account:
    &quot;&quot;&quot;银行账户&quot;&quot;&quot;

    def __init__(self, balance=0):
        self.balance = balance
        lock = threading.RLock()
        self.condition = threading.Condition(lock)

    def withdraw(self, money):
        &quot;&quot;&quot;取钱&quot;&quot;&quot;
        with self.condition:
            while money &gt; self.balance:
                self.condition.wait()
            new_balance = self.balance - money
            sleep(0.001)
            self.balance = new_balance

    def deposit(self, money):
        &quot;&quot;&quot;存钱&quot;&quot;&quot;
        with self.condition:
            new_balance = self.balance + money
            sleep(0.001)
            self.balance = new_balance
            self.condition.notify_all()


def add_money(account):
    while True:
        money = randint(5, 10)
        account.deposit(money)
        print(threading.current_thread().name, 
              &#39;:&#39;, money, &#39;====&gt;&#39;, account.balance)
        sleep(0.5)


def sub_money(account):
    while True:
        money = randint(10, 30)
        account.withdraw(money)
        print(threading.current_thread().name, 
              &#39;:&#39;, money, &#39;&lt;====&#39;, account.balance)
        sleep(1)


def main():
    account = Account()
    with ThreadPoolExecutor(max_workers=15) as pool:
        for _ in range(5):
            pool.submit(add_money, account)
        for _ in range(10):
            pool.submit(sub_money, account)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
</li>
<li><p>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是<code>Process</code>，其他辅助的类跟<code>threading</code>模块中的类似，进程间共享数据可以使用管道、套接字等，在<code>multiprocessing</code>模块中有一个<code>Queue</code>类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</p>
<pre><code class="Python">&quot;&quot;&quot;
多进程和进程池的使用
多线程因为GIL的存在不能够发挥CPU的多核特性
对于计算密集型任务应该考虑使用多进程
time python3 example22.py
real    0m11.512s
user    0m39.319s
sys     0m0.169s
使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍
这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU
&quot;&quot;&quot;
import concurrent.futures
import math

PRIMES = [
    1116281,
    1297337,
    104395303,
    472882027,
    533000389,
    817504243,
    982451653,
    112272535095293,
    112582705942171,
    112272535095293,
    115280095190773,
    115797848077099,
    1099726899285419
] * 5


def is_prime(n):
    &quot;&quot;&quot;判断素数&quot;&quot;&quot;
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
            print(&#39;%d is prime: %s&#39; % (number, prime))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>重点</strong>：<strong>多线程和多进程的比较</strong>。</p>
<p>以下情况需要使用多线程：</p>
<ol>
<li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li>
<li>程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。</li>
</ol>
<p>以下情况需要使用多进程：</p>
<ol>
<li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li>
<li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li>
<li>程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。</li>
</ol>
</blockquote>
</li>
<li><p>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者<code>future</code>对象来获取任务执行的结果。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</p>
<pre><code class="Python">&quot;&quot;&quot;
异步I/O - async / await
&quot;&quot;&quot;
import asyncio


def num_generator(m, n):
    &quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot;
    yield from range(m, n + 1)


async def prime_filter(m, n):
    &quot;&quot;&quot;素数过滤器&quot;&quot;&quot;
    primes = []
    for i in num_generator(m, n):
        flag = True
        for j in range(2, int(i ** 0.5 + 1)):
            if i % j == 0:
                flag = False
                break
        if flag:
            print(&#39;Prime =&gt;&#39;, i)
            primes.append(i)

        await asyncio.sleep(0.001)
    return tuple(primes)


async def square_mapper(m, n):
    &quot;&quot;&quot;平方映射器&quot;&quot;&quot;
    squares = []
    for i in num_generator(m, n):
        print(&#39;Square =&gt;&#39;, i * i)
        squares.append(i * i)

        await asyncio.sleep(0.001)
    return squares


def main():
    &quot;&quot;&quot;主函数&quot;&quot;&quot;
    loop = asyncio.get_event_loop()
    future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))
    future.add_done_callback(lambda x: print(x.result()))
    loop.run_until_complete(future)
    loop.close()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>说明</strong>：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p>
</blockquote>
<p>Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了<code>async</code>和<code>await</code>来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
<pre><code class="Python">import asyncio
import re

import aiohttp

PATTERN = re.compile(r&#39;\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\/title\&gt;&#39;)


async def fetch_page(session, url):
    async with session.get(url, ssl=False) as resp:
        return await resp.text()


async def show_title(url):
    async with aiohttp.ClientSession() as session:
        html = await fetch_page(session, url)
        print(PATTERN.search(html).group(&#39;title&#39;))


def main():
    urls = (&#39;https://www.python.org/&#39;,
            &#39;https://git-scm.com/&#39;,
            &#39;https://www.jd.com/&#39;,
            &#39;https://www.taobao.com/&#39;,
            &#39;https://www.douban.com/&#39;)
    loop = asyncio.get_event_loop()
    cos = [show_title(url) for url in urls]
    loop.run_until_complete(asyncio.wait(cos))
    loop.close()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>重点</strong>：<strong>异步I/O与多进程的比较</strong>。</p>
<p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，<code>asyncio</code>就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑<code>asyncio</code>，它很适合编写没有实时数据处理需求的Web应用服务器。</p>
</blockquote>
<p>Python还有很多用于处理并行任务的三方库，例如：<code>joblib</code>、<code>PyMP</code>等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
<p>要实现任务的异步化，可以使用名为<code>Celery</code>的三方库。<code>Celery</code>是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
</li>
</ul>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day01-15/15.图像和办公文档处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:53.692Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day01-15/15.%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="图像和办公文档处理"><a href="#图像和办公文档处理" class="headerlink" title="图像和办公文档处理"></a>图像和办公文档处理</h2><p>用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。</p>
<h3 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h3><h4 id="计算机图像相关知识"><a href="#计算机图像相关知识" class="headerlink" title="计算机图像相关知识"></a>计算机图像相关知识</h4><ol>
<li><p>颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">RGBA值</th>
<th align="center">名称</th>
<th align="center">RGBA值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">White</td>
<td align="center">(255, 255, 255, 255)</td>
<td align="center">Red</td>
<td align="center">(255, 0, 0, 255)</td>
</tr>
<tr>
<td align="center">Green</td>
<td align="center">(0, 255, 0, 255)</td>
<td align="center">Blue</td>
<td align="center">(0, 0, 255, 255)</td>
</tr>
<tr>
<td align="center">Gray</td>
<td align="center">(128, 128, 128, 255)</td>
<td align="center">Yellow</td>
<td align="center">(255, 255, 0, 255)</td>
</tr>
<tr>
<td align="center">Black</td>
<td align="center">(0, 0, 0, 255)</td>
<td align="center">Purple</td>
<td align="center">(128, 0, 128, 255)</td>
</tr>
</tbody></table>
</li>
<li><p>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。</p>
</li>
</ol>
<h4 id="用Pillow操作图像"><a href="#用Pillow操作图像" class="headerlink" title="用Pillow操作图像"></a>用Pillow操作图像</h4><p>Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。</p>
<pre><code class="Shell">pip install pillow
</code></pre>
<p>Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。</p>
<pre><code class="Python">&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt;
&gt;&gt;&gt; image = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; image.format, image.size, image.mode
(&#39;JPEG&#39;, (500, 750), &#39;RGB&#39;)
&gt;&gt;&gt; image.show()
</code></pre>
<p><img src="./res/image-show.png"></p>
<ol>
<li><p>剪裁图像</p>
<pre><code class="Python">&gt;&gt;&gt; image = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; rect = 80, 20, 310, 360
&gt;&gt;&gt; image.crop(rect).show()
</code></pre>
<p><img src="./res/image-crop.png"></p>
</li>
<li><p>生成缩略图</p>
<pre><code class="Python">&gt;&gt;&gt; image = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; size = 128, 128
&gt;&gt;&gt; image.thumbnail(size)
&gt;&gt;&gt; image.show()
</code></pre>
<p><img src="./res/image-thumbnail.png"></p>
</li>
<li><p>缩放和黏贴图像</p>
<pre><code class="Python">&gt;&gt;&gt; image1 = Image.open(&#39;./res/luohao.png&#39;)
&gt;&gt;&gt; image2 = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; rect = 80, 20, 310, 360
&gt;&gt;&gt; guido_head = image2.crop(rect)
&gt;&gt;&gt; width, height = guido_head.size
&gt;&gt;&gt; image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40))
</code></pre>
<p><img src="./res/image-paste.png"></p>
</li>
<li><p>旋转和翻转</p>
<pre><code class="Python">&gt;&gt;&gt; image = Image.open(&#39;./res/guido.png&#39;)
&gt;&gt;&gt; image.rotate(180).show()
&gt;&gt;&gt; image.transpose(Image.FLIP_LEFT_RIGHT).show()
</code></pre>
<p><img src="./res/image-rotate.png"></p>
<p><img src="./res/image-transpose.png"></p>
</li>
<li><p>操作像素</p>
<pre><code class="Python">&gt;&gt;&gt; image = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; for x in range(80, 310):
...     for y in range(20, 360):
...         image.putpixel((x, y), (128, 128, 128))
... 
&gt;&gt;&gt; image.show()
</code></pre>
<p><img src="./res/image-putpixel.png"></p>
</li>
<li><p>滤镜效果</p>
<pre><code class="Python">&gt;&gt;&gt; from PIL import Image, ImageFilter
&gt;&gt;&gt;
&gt;&gt;&gt; image = Image.open(&#39;./res/guido.jpg&#39;)
&gt;&gt;&gt; image.filter(ImageFilter.CONTOUR).show()
</code></pre>
<p><img src="./res/image-filter.png"></p>
</li>
</ol>
<h3 id="处理Excel电子表格"><a href="#处理Excel电子表格" class="headerlink" title="处理Excel电子表格"></a>处理Excel电子表格</h3><p>Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。</p>
<pre><code class="Python">import datetime

from openpyxl import Workbook

wb = Workbook()
ws = wb.active

ws[&#39;A1&#39;] = 42
ws.append([1, 2, 3])
ws[&#39;A2&#39;] = datetime.datetime.now()

wb.save(&quot;sample.xlsx&quot;)
</code></pre>
<h3 id="处理Word文档"><a href="#处理Word文档" class="headerlink" title="处理Word文档"></a>处理Word文档</h3><p>利用python-docx模块，Python可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。</p>
<pre><code class="Python">from docx import Document
from docx.shared import Inches

document = Document()

document.add_heading(&#39;Document Title&#39;, 0)

p = document.add_paragraph(&#39;A plain paragraph having some &#39;)
p.add_run(&#39;bold&#39;).bold = True
p.add_run(&#39; and some &#39;)
p.add_run(&#39;italic.&#39;).italic = True

document.add_heading(&#39;Heading, level 1&#39;, level=1)
document.add_paragraph(&#39;Intense quote&#39;, style=&#39;Intense Quote&#39;)

document.add_paragraph(
    &#39;first item in unordered list&#39;, style=&#39;List Bullet&#39;
)
document.add_paragraph(
    &#39;first item in ordered list&#39;, style=&#39;List Number&#39;
)

document.add_picture(&#39;monty-truth.png&#39;, width=Inches(1.25))

records = (
    (3, &#39;101&#39;, &#39;Spam&#39;),
    (7, &#39;422&#39;, &#39;Eggs&#39;),
    (4, &#39;631&#39;, &#39;Spam, spam, eggs, and spam&#39;)
)

table = document.add_table(rows=1, cols=3)
hdr_cells = table.rows[0].cells
hdr_cells[0].text = &#39;Qty&#39;
hdr_cells[1].text = &#39;Id&#39;
hdr_cells[2].text = &#39;Desc&#39;
for qty, id, desc in records:
    row_cells = table.add_row().cells
    row_cells[0].text = str(qty)
    row_cells[1].text = id
    row_cells[2].text = desc

document.add_page_break()

document.save(&#39;demo.docx&#39;)
</code></pre>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day01-15/14.网络编程入门和网络应用开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:53.689Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day01-15/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网络编程入门"><a href="#网络编程入门" class="headerlink" title="网络编程入门"></a>网络编程入门</h2><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p>计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。</p>
<h4 id="计算机网络发展史"><a href="#计算机网络发展史" class="headerlink" title="计算机网络发展史"></a>计算机网络发展史</h4><ol>
<li><p>1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。</p>
<p><img src="./res/arpanet.png"></p>
</li>
<li><p>1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。</p>
<p><img src="./res/osimodel.png"></p>
</li>
<li><p>1990s - 英国人<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E">蒂姆·伯纳斯-李</a>发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。</p>
<p>在没有浏览器的年代，上网是这样的。</p>
<p><img src="./res/before-browser.jpg"></p>
<p>有了浏览器以后，上网是这样的。</p>
<p><img src="./res/after-browser.jpg"></p>
</li>
</ol>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>实现网络通信的基础是网络通信协议，这些协议通常是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84">互联网工程任务组</a> （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。</p>
<p><img src="./res/TCP-IP-model.png"></p>
<p>IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网（LAN）</a>中的内部IP地址，通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换（NAT）服务</a>我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。</p>
<p>TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情：</p>
<ol>
<li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li>
<li>流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。</li>
<li>拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。</li>
</ol>
<h4 id="网络应用模式"><a href="#网络应用模式" class="headerlink" title="网络应用模式"></a>网络应用模式</h4><ol>
<li>C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。</li>
<li>去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li>
</ol>
<h3 id="基于HTTP协议的网络资源访问"><a href="#基于HTTP协议的网络资源访问" class="headerlink" title="基于HTTP协议的网络资源访问"></a>基于HTTP协议的网络资源访问</h3><h4 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h4><p>HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML</a>页面的方法，通过HTTP或者<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">HTTPS</a>（超文本传输安全协议）请求的资源由URI（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E8%B3%87%E6%BA%90%E6%A8%99%E8%AD%98%E7%AC%A6">统一资源标识符</a>）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a>，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。</p>
<h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XML">XML</a>一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。</p>
<p>XML的例子：</p>
<pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;message&gt;
    &lt;from&gt;Alice&lt;/from&gt;
    &lt;to&gt;Bob&lt;/to&gt;
    &lt;content&gt;Will you marry me?&lt;/content&gt;
&lt;/message&gt;
</code></pre>
<p>JSON的例子：</p>
<pre><code class="JSON">&#123;
    &quot;from&quot;: &quot;Alice&quot;,
    &quot;to&quot;: &quot;Bob&quot;,
    &quot;content&quot;: &quot;Will you marry me?&quot;
&#125;
</code></pre>
<h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>requests是一个基于HTTP协议来使用网络的第三库，其<a target="_blank" rel="noopener" href="http://cn.python-requests.org/zh_CN/latest/">官方网站</a>有这样的一句介绍它的话：“Requests是唯一的一个<strong>非转基因</strong>的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了<a target="_blank" rel="noopener" href="https://www.tianapi.com/">天行数据</a>提供的网络API。</p>
<p>我们可以先通过pip安装requests及其依赖库。</p>
<pre><code class="Shell">pip install requests
</code></pre>
<p>如果使用PyCharm作为开发工具，可以直接在代码中书写<code>import requests</code>，然后通过代码修复功能来自动下载安装requests。</p>
<pre><code class="Python">from time import time
from threading import Thread

import requests


# 继承Thread类创建自定义的线程类
class DownloadHanlder(Thread):

    def __init__(self, url):
        super().__init__()
        self.url = url

    def run(self):
        filename = self.url[self.url.rfind(&#39;/&#39;) + 1:]
        resp = requests.get(self.url)
        with open(&#39;/Users/Hao/&#39; + filename, &#39;wb&#39;) as f:
            f.write(resp.content)


def main():
    # 通过requests模块的get函数获取网络资源
    # 下面的代码中使用了天行数据接口提供的网络API
    # 要使用该数据接口需要在天行数据的网站上注册
    # 然后用自己的Key替换掉下面代码的中APIKey即可
    resp = requests.get(
        &#39;http://api.tianapi.com/meinv/?key=APIKey&amp;num=10&#39;)
    # 将服务器返回的JSON格式的数据解析为字典
    data_model = resp.json()
    for mm_dict in data_model[&#39;newslist&#39;]:
        url = mm_dict[&#39;picUrl&#39;]
        # 通过多线程的方式实现图片下载
        DownloadHanlder(url).start()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h3 id="基于传输层协议的套接字编程"><a href="#基于传输层协议的套接字编程" class="headerlink" title="基于传输层协议的套接字编程"></a>基于传输层协议的套接字编程</h3><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C语言</a>写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p>
<h4 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h4><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</p>
<p>下面的代码实现了一个提供时间日期的服务器。</p>
<pre><code class="Python">from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime


def main():
    # 1.创建套接字对象并指定使用哪种传输服务
    # family=AF_INET - IPv4地址
    # family=AF_INET6 - IPv6地址
    # type=SOCK_STREAM - TCP套接字
    # type=SOCK_DGRAM - UDP套接字
    # type=SOCK_RAW - 原始套接字
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.绑定IP地址和端口(端口用于区分不同的服务)
    # 同一时间在同一个端口上只能绑定一个服务否则报错
    server.bind((&#39;192.168.1.2&#39;, 6789))
    # 3.开启监听 - 监听客户端连接到服务器
    # 参数512可以理解为连接队列的大小
    server.listen(512)
    print(&#39;服务器启动开始监听...&#39;)
    while True:
        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)
        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行
        # accept方法返回一个元组其中的第一个元素是客户端对象
        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)
        client, addr = server.accept()
        print(str(addr) + &#39;连接到了服务器.&#39;)
        # 5.发送数据
        client.send(str(datetime.now()).encode(&#39;utf-8&#39;))
        # 6.断开连接
        client.close()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p>
<pre><code class="Shell">telnet 192.168.1.2 6789
</code></pre>
<p><img src="./res/telnet.png"></p>
<p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p>
<pre><code class="Python">from socket import socket


def main():
    # 1.创建套接字对象默认使用IPv4和TCP协议
    client = socket()
    # 2.连接到服务器(需要指定IP地址和端口)
    client.connect((&#39;192.168.1.2&#39;, 6789))
    # 3.从服务器接收数据
    print(client.recv(1024).decode(&#39;utf-8&#39;))
    client.close()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p>
<p>服务器端代码：</p>
<pre><code class="Python">from socket import socket, SOCK_STREAM, AF_INET
from base64 import b64encode
from json import dumps
from threading import Thread


def main():
    
    # 自定义线程类
    class FileTransferHandler(Thread):

        def __init__(self, cclient):
            super().__init__()
            self.cclient = cclient

        def run(self):
            my_dict = &#123;&#125;
            my_dict[&#39;filename&#39;] = &#39;guido.jpg&#39;
            # JSON是纯文本不能携带二进制数据
            # 所以图片的二进制数据要处理成base64编码
            my_dict[&#39;filedata&#39;] = data
            # 通过dumps函数将字典处理成JSON字符串
            json_str = dumps(my_dict)
            # 发送JSON字符串
            self.cclient.send(json_str.encode(&#39;utf-8&#39;))
            self.cclient.close()

    # 1.创建套接字对象并指定使用哪种传输服务
    server = socket()
    # 2.绑定IP地址和端口(区分不同的服务)
    server.bind((&#39;192.168.1.2&#39;, 5566))
    # 3.开启监听 - 监听客户端连接到服务器
    server.listen(512)
    print(&#39;服务器启动开始监听...&#39;)
    with open(&#39;guido.jpg&#39;, &#39;rb&#39;) as f:
        # 将二进制数据处理成base64再解码成字符串
        data = b64encode(f.read()).decode(&#39;utf-8&#39;)
    while True:
        client, addr = server.accept()
        # 启动一个线程来处理客户端的请求
        FileTransferHandler(client).start()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>客户端代码：</p>
<pre><code class="Python">from socket import socket
from json import loads
from base64 import b64decode


def main():
    client = socket()
    client.connect((&#39;192.168.1.2&#39;, 5566))
    # 定义一个保存二进制数据的对象
    in_data = bytes()
    # 由于不知道服务器发送的数据有多大每次接收1024字节
    data = client.recv(1024)
    while data:
        # 将收到的数据拼接起来
        in_data += data
        data = client.recv(1024)
    # 将收到的二进制数据解码成JSON字符串并转换成字典
    # loads函数的作用就是将JSON字符串转成字典对象
    my_dict = loads(in_data.decode(&#39;utf-8&#39;))
    filename = my_dict[&#39;filename&#39;]
    filedata = my_dict[&#39;filedata&#39;].encode(&#39;utf-8&#39;)
    with open(&#39;/Users/Hao/&#39; + filename, &#39;wb&#39;) as f:
        # 将base64格式的数据解码成二进制数据并写入文件
        f.write(b64decode(filedata))
    print(&#39;图片已保存.&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Base64">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p>
<blockquote>
<p><strong>说明：</strong> 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。</p>
</blockquote>
<h4 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h4><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。</p>
<h3 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h3><h4 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h4><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p>
<p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p>
<p>下面的代码演示了如何在Python发送邮件。</p>
<pre><code class="Python">from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText


def main():
    # 请自行修改下面的邮件发送者和接收者
    sender = &#39;abcdefg@126.com&#39;
    receivers = [&#39;uvwxyz@qq.com&#39;, &#39;uvwxyz@126.com&#39;]
    message = MIMEText(&#39;用Python发送邮件的示例代码.&#39;, &#39;plain&#39;, &#39;utf-8&#39;)
    message[&#39;From&#39;] = Header(&#39;王大锤&#39;, &#39;utf-8&#39;)
    message[&#39;To&#39;] = Header(&#39;骆昊&#39;, &#39;utf-8&#39;)
    message[&#39;Subject&#39;] = Header(&#39;示例代码实验邮件&#39;, &#39;utf-8&#39;)
    smtper = SMTP(&#39;smtp.126.com&#39;)
    # 请自行修改下面的登录口令
    smtper.login(sender, &#39;secretpass&#39;)
    smtper.sendmail(sender, receivers, message.as_string())
    print(&#39;邮件发送完成!&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。</p>
<pre><code class="Python">from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart

import urllib


def main():
    # 创建一个带附件的邮件消息对象
    message = MIMEMultipart()
    
    # 创建文本内容
    text_content = MIMEText(&#39;附件中有本月数据请查收&#39;, &#39;plain&#39;, &#39;utf-8&#39;)
    message[&#39;Subject&#39;] = Header(&#39;本月数据&#39;, &#39;utf-8&#39;)
    # 将文本内容添加到邮件消息对象中
    message.attach(text_content)

    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open(&#39;/Users/Hao/Desktop/hello.txt&#39;, &#39;rb&#39;) as f:
        txt = MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;)
        txt[&#39;Content-Type&#39;] = &#39;text/plain&#39;
        txt[&#39;Content-Disposition&#39;] = &#39;attachment; filename=hello.txt&#39;
        message.attach(txt)
    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open(&#39;/Users/Hao/Desktop/汇总数据.xlsx&#39;, &#39;rb&#39;) as f:
        xls = MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;)
        xls[&#39;Content-Type&#39;] = &#39;application/vnd.ms-excel&#39;
        xls[&#39;Content-Disposition&#39;] = &#39;attachment; filename=month-data.xlsx&#39;
        message.attach(xls)
    
    # 创建SMTP对象
    smtper = SMTP(&#39;smtp.126.com&#39;)
    # 开启安全连接
    # smtper.starttls()
    sender = &#39;abcdefg@126.com&#39;
    receivers = [&#39;uvwxyz@qq.com&#39;]
    # 登录到SMTP服务器
    # 请注意此处不是使用密码而是邮件客户端授权码进行登录
    # 对此有疑问的读者可以联系自己使用的邮件服务器客服
    smtper.login(sender, &#39;secretpass&#39;)
    # 发送邮件
    smtper.sendmail(sender, receivers, message.as_string())
    # 与邮件服务器断开连接
    smtper.quit()
    print(&#39;发送完成!&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h4 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h4><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a target="_blank" rel="noopener" href="http://www.ihuyi.com/">互亿无线</a>短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p>
<pre><code class="Python">import urllib.parse
import http.client
import json


def main():
    host  = &quot;106.ihuyi.com&quot;
    sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;
    # 下面的参数需要填入自己注册的账号和对应的密码
    params = urllib.parse.urlencode(&#123;&#39;account&#39;: &#39;你自己的账号&#39;, &#39;password&#39; : &#39;你自己的密码&#39;, &#39;content&#39;: &#39;您的验证码是：147258。请不要把验证码泄露给其他人。&#39;, &#39;mobile&#39;: &#39;接收者的手机号&#39;, &#39;format&#39;:&#39;json&#39; &#125;)
    print(params)
    headers = &#123;&#39;Content-type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Accept&#39;: &#39;text/plain&#39;&#125;
    conn = http.client.HTTPConnection(host, port=80, timeout=30)
    conn.request(&#39;POST&#39;, sms_send_uri, params, headers)
    response = conn.getresponse()
    response_str = response.read()
    jsonstr = response_str.decode(&#39;utf-8&#39;)
    print(json.loads(jsonstr))
    conn.close()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day01-15/13.进程和线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:53.686Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day01-15/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。</p>
<p><img src="./res/macos-monitor.png"></p>
<p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p>
<p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p>
<h3 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h3><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p>
<p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p>
<pre><code class="Python">from random import randint
from time import time, sleep


def download_task(filename):
    print(&#39;开始下载%s...&#39; % filename)
    time_to_download = randint(5, 10)
    sleep(time_to_download)
    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))


def main():
    start = time()
    download_task(&#39;Python从入门到住院.pdf&#39;)
    download_task(&#39;Peking Hot.avi&#39;)
    end = time()
    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>下面是运行程序得到的一次运行结果。</p>
<pre><code class="Shell">开始下载Python从入门到住院.pdf...
Python从入门到住院.pdf下载完成! 耗费了6秒
开始下载Peking Hot.avi...
Peking Hot.avi下载完成! 耗费了7秒
总共耗费了13.01秒.
</code></pre>
<p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p>
<pre><code class="Python">from multiprocessing import Process
from os import getpid
from random import randint
from time import time, sleep


def download_task(filename):
    print(&#39;启动下载进程，进程号[%d].&#39; % getpid())
    print(&#39;开始下载%s...&#39; % filename)
    time_to_download = randint(5, 10)
    sleep(time_to_download)
    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))


def main():
    start = time()
    p1 = Process(target=download_task, args=(&#39;Python从入门到住院.pdf&#39;, ))
    p1.start()
    p2 = Process(target=download_task, args=(&#39;Peking Hot.avi&#39;, ))
    p2.start()
    p1.join()
    p2.join()
    end = time()
    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p>
<pre><code class="Shell">启动下载进程，进程号[1530].
开始下载Python从入门到住院.pdf...
启动下载进程，进程号[1531].
开始下载Peking Hot.avi...
Peking Hot.avi下载完成! 耗费了7秒
Python从入门到住院.pdf下载完成! 耗费了10秒
总共耗费了10.01秒.
</code></pre>
<p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p>
<pre><code class="Python">from multiprocessing import Process
from time import sleep

counter = 0


def sub_task(string):
    global counter
    while counter &lt; 10:
        print(string, end=&#39;&#39;, flush=True)
        counter += 1
        sleep(0.01)

        
def main():
    Process(target=sub_task, args=(&#39;Ping&#39;, )).start()
    Process(target=sub_task, args=(&#39;Pong&#39;, )).start()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p>
<h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p>
<pre><code class="Python">from random import randint
from threading import Thread
from time import time, sleep


def download(filename):
    print(&#39;开始下载%s...&#39; % filename)
    time_to_download = randint(5, 10)
    sleep(time_to_download)
    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))


def main():
    start = time()
    t1 = Thread(target=download, args=(&#39;Python从入门到住院.pdf&#39;,))
    t1.start()
    t2 = Thread(target=download, args=(&#39;Peking Hot.avi&#39;,))
    t2.start()
    t1.join()
    t2.join()
    end = time()
    print(&#39;总共耗费了%.3f秒&#39; % (end - start))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p>
<pre><code class="Python">from random import randint
from threading import Thread
from time import time, sleep


class DownloadTask(Thread):

    def __init__(self, filename):
        super().__init__()
        self._filename = filename

    def run(self):
        print(&#39;开始下载%s...&#39; % self._filename)
        time_to_download = randint(5, 10)
        sleep(time_to_download)
        print(&#39;%s下载完成! 耗费了%d秒&#39; % (self._filename, time_to_download))


def main():
    start = time()
    t1 = DownloadTask(&#39;Python从入门到住院.pdf&#39;)
    t1.start()
    t2 = DownloadTask(&#39;Peking Hot.avi&#39;)
    t2.start()
    t1.join()
    t2.join()
    end = time()
    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p>
<pre><code class="Python">from time import sleep
from threading import Thread


class Account(object):

    def __init__(self):
        self._balance = 0

    def deposit(self, money):
        # 计算存款后的余额
        new_balance = self._balance + money
        # 模拟受理存款业务需要0.01秒的时间
        sleep(0.01)
        # 修改账户余额
        self._balance = new_balance

    @property
    def balance(self):
        return self._balance


class AddMoneyThread(Thread):

    def __init__(self, account, money):
        super().__init__()
        self._account = account
        self._money = money

    def run(self):
        self._account.deposit(self._money)


def main():
    account = Account()
    threads = []
    # 创建100个存款的线程向同一个账户中存钱
    for _ in range(100):
        t = AddMoneyThread(account, 1)
        threads.append(t)
        t.start()
    # 等所有存款的线程都执行完毕
    for t in threads:
        t.join()
    print(&#39;账户余额为: ￥%d元&#39; % account.balance)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p>
<pre><code class="Python">from time import sleep
from threading import Thread, Lock


class Account(object):

    def __init__(self):
        self._balance = 0
        self._lock = Lock()

    def deposit(self, money):
        # 先获取锁才能执行后续的代码
        self._lock.acquire()
        try:
            new_balance = self._balance + money
            sleep(0.01)
            self._balance = new_balance
        finally:
            # 在finally中执行释放锁的操作保证正常异常锁都能释放
            self._lock.release()

    @property
    def balance(self):
        return self._balance


class AddMoneyThread(Thread):

    def __init__(self, account, money):
        super().__init__()
        self._account = account
        self._money = money

    def run(self):
        self._account.deposit(self._money)


def main():
    account = Account()
    threads = []
    for _ in range(100):
        t = AddMoneyThread(account, 1)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print(&#39;账户余额为: ￥%d元&#39; % account.balance)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p>
<h3 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。</p>
<p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p>
<blockquote>
<p><strong>说明：</strong> 上面的内容和例子来自于<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p>
</blockquote>
<h3 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h3><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p>
<p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#例子1：将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"></a>例子1：将耗时间的任务放到线程中以获得更好的用户体验。</h4><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。</p>
<pre><code class="Python">import time
import tkinter
import tkinter.messagebox


def download():
    # 模拟下载任务需要花费10秒钟时间
    time.sleep(10)
    tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;)


def show_about():
    tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;)


def main():
    top = tkinter.Tk()
    top.title(&#39;单线程&#39;)
    top.geometry(&#39;200x150&#39;)
    top.wm_attributes(&#39;-topmost&#39;, True)

    panel = tkinter.Frame(top)
    button1 = tkinter.Button(panel, text=&#39;下载&#39;, command=download)
    button1.pack(side=&#39;left&#39;)
    button2 = tkinter.Button(panel, text=&#39;关于&#39;, command=show_about)
    button2.pack(side=&#39;right&#39;)
    panel.pack(side=&#39;bottom&#39;)

    tkinter.mainloop()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p>
<pre><code class="Python">import time
import tkinter
import tkinter.messagebox
from threading import Thread


def main():

    class DownloadTaskHandler(Thread):

        def run(self):
            time.sleep(10)
            tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;)
            # 启用下载按钮
            button1.config(state=tkinter.NORMAL)

    def download():
        # 禁用下载按钮
        button1.config(state=tkinter.DISABLED)
        # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)
        # 在线程中处理耗时间的下载任务
        DownloadTaskHandler(daemon=True).start()

    def show_about():
        tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;)

    top = tkinter.Tk()
    top.title(&#39;单线程&#39;)
    top.geometry(&#39;200x150&#39;)
    top.wm_attributes(&#39;-topmost&#39;, 1)

    panel = tkinter.Frame(top)
    button1 = tkinter.Button(panel, text=&#39;下载&#39;, command=download)
    button1.pack(side=&#39;left&#39;)
    button2 = tkinter.Button(panel, text=&#39;关于&#39;, command=show_about)
    button2.pack(side=&#39;right&#39;)
    panel.pack(side=&#39;bottom&#39;)

    tkinter.mainloop()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h4 id="例子2：使用多进程对复杂任务进行“分而治之”。"><a href="#例子2：使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="例子2：使用多进程对复杂任务进行“分而治之”。"></a>例子2：使用多进程对复杂任务进行“分而治之”。</h4><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p>
<pre><code class="Python">from time import time


def main():
    total = 0
    number_list = [x for x in range(1, 100000001)]
    start = time()
    for number in number_list:
        total += number
    print(total)
    end = time()
    print(&#39;Execution time: %.3fs&#39; % (end - start))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p>
<pre><code class="Python">from multiprocessing import Process, Queue
from random import randint
from time import time


def task_handler(curr_list, result_queue):
    total = 0
    for number in curr_list:
        total += number
    result_queue.put(total)


def main():
    processes = []
    number_list = [x for x in range(1, 100000001)]
    result_queue = Queue()
    index = 0
    # 启动8个进程将数据切片后进行运算
    for _ in range(8):
        p = Process(target=task_handler,
                    args=(number_list[index:index + 12500000], result_queue))
        index += 12500000
        processes.append(p)
        p.start()
    # 开始记录所有进程执行完成花费的时间
    start = time()
    for p in processes:
        p.join()
    # 合并执行结果
    total = 0
    while not result_queue.empty():
        total += result_queue.get()
    print(total)
    end = time()
    print(&#39;Execution time: &#39;, (end - start), &#39;s&#39;, sep=&#39;&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过<code>multiprocessing.managers</code>模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day01-15/12.字符串和正则表达式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:53.683Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><h3 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p>
<p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p>
<p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a target="_blank" rel="noopener" href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符</td>
<td>b.t</td>
<td>可以匹配bat / but / b#t / b1t等</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母/数字/下划线</td>
<td>b\wt</td>
<td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符（包括\r、\n、\t等）</td>
<td>love\syou</td>
<td>可以匹配love you</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td>\d\d</td>
<td>可以匹配01 / 23 / 99等</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的边界</td>
<td>\bThe\b</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^The</td>
<td>可以匹配The开头的字符串</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
<td>.exe$</td>
<td>可以匹配.exe结尾的字符串</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母/数字/下划线</td>
<td>b\Wt</td>
<td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
<td>love\Syou</td>
<td>可以匹配love#you等<br>但不能匹配love you</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
<td>\d\D</td>
<td>可以匹配9a / 3# / 0F等</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
<td>\Bio\B</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
<td>可以匹配任一元音字母字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在字符集中的任意单一字符</td>
<td>[^aeiou]</td>
<td>可以匹配任一非元音字母字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或多次</td>
<td>\w*</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或多次</td>
<td>\w+</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或1次</td>
<td>\w?</td>
<td></td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次</td>
<td>\w{3}</td>
<td></td>
</tr>
<tr>
<td>{M,}</td>
<td>匹配至少M次</td>
<td>\w{3,}</td>
<td></td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配至少M次至多N次</td>
<td>\w{3,6}</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>分支</td>
<td>foo|bar</td>
<td>可以匹配foo或者bar</td>
</tr>
<tr>
<td>(?#)</td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(exp)</td>
<td>匹配exp并捕获到自动命名的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;name&gt;exp)</td>
<td>匹配exp并捕获到名为name的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp但是不捕获匹配的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
<td>\b\w+(?=ing)</td>
<td>可以匹配I’m dancing中的danc</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
<td>(?&lt;=\bdanc)\w+\b</td>
<td>可以匹配I love dancing and reading中的第一个ing</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
<td>a.*b<br>a.*?b</td>
<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或多次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,N}?</td>
<td>重复M到N次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,}?</td>
<td>重复M次以上，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile(pattern, flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, string, maxsplit=0, flags=0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count=0, flags=0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags=0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I / re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M / re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p>
<h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><pre><code class="Python">&quot;&quot;&quot;
验证输入用户名和QQ号是否有效并给出对应的提示信息

要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0
&quot;&quot;&quot;
import re


def main():
    username = input(&#39;请输入用户名: &#39;)
    qq = input(&#39;请输入QQ号: &#39;)
    # match函数的第一个参数是正则表达式字符串或正则表达式对象
    # 第二个参数是要跟正则表达式做匹配的字符串对象
    m1 = re.match(r&#39;^[0-9a-zA-Z_]&#123;6,20&#125;$&#39;, username)
    if not m1:
        print(&#39;请输入有效的用户名.&#39;)
    m2 = re.match(r&#39;^[1-9]\d&#123;4,11&#125;$&#39;, qq)
    if not m2:
        print(&#39;请输入有效的QQ号.&#39;)
    if m1 and m2:
        print(&#39;你输入的信息是有效的!&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>提示：</strong> 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p>
</blockquote>
<h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p>
<p><img src="./res/tel-start-number.png"></p>
<pre><code class="Python">import re


def main():
    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字
    pattern = re.compile(r&#39;(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)&#39;)
    sentence = &#39;&#39;&#39;
    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，
    不是15600998765，也是110或119，王大锤的手机号才是15600998765。
    &#39;&#39;&#39;
    # 查找所有匹配并保存到一个列表中
    mylist = re.findall(pattern, sentence)
    print(mylist)
    print(&#39;--------华丽的分隔线--------&#39;)
    # 通过迭代器取出匹配对象并获得匹配的内容
    for temp in pattern.finditer(sentence):
        print(temp.group())
    print(&#39;--------华丽的分隔线--------&#39;)
    # 通过search函数指定搜索位置找出所有匹配
    m = pattern.search(sentence)
    while m:
        print(m.group())
        m = pattern.search(sentence, m.end())


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d&#123;9&#125;|14[57]\d&#123;8&#125;|15[0-35-9]\d&#123;8&#125;|17[678]\d&#123;8&#125;)(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p>
</blockquote>
<h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><pre><code class="Python">import re


def main():
    sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;
    purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,
                      &#39;*&#39;, sentence, flags=re.IGNORECASE)
    print(purified)  # 你丫是*吗? 我*你大爷的. * you.


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<blockquote>
<p><strong>说明：</strong> re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a target="_blank" rel="noopener" href="http://www.runoob.com/python/python-operators.html#ysf5">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p>
</blockquote>
<h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><pre><code class="Python">import re


def main():
    poem = &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39;
    sentence_list = re.split(r&#39;[，。, .]&#39;, poem)
    while &#39;&#39; in sentence_list:
        sentence_list.remove(&#39;&#39;)
    print(sentence_list)  # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;]


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<a target="_blank" rel="noopener" href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>或<a target="_blank" rel="noopener" href="http://lxml.de/">Lxml</a>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/16/index.html">http://example.com/page/16/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/page/15/">Previous</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/17/">Next</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/PEP8/" style="font-size: 10px;">PEP8</a> <a href="/tags/PEP899/" style="font-size: 10px;">PEP899</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Python99/" style="font-size: 10px;">Python99</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%8000/">Python基础00</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年10月</a><span class="archive-list-count">173</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年08月</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP8/" rel="tag">PEP8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP899/" rel="tag">PEP899</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python99/" rel="tag">Python99</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2021 John Doe.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        
            <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank">busuanzi.</a></span>
        
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
<script src="/localshare/js/social-share.js"></script>

  
<script src="/localshare/js/qrcode.js"></script>




















  </div>
</body>
</html>