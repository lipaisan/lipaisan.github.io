<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-Python-100-Days-master/Day91-100/97.电商网站技术要点剖析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.047Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/97.%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E5%89%96%E6%9E%90/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="电商网站技术要点剖析"><a href="#电商网站技术要点剖析" class="headerlink" title="电商网站技术要点剖析"></a>电商网站技术要点剖析</h2><h3 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h3><ol>
<li>B2B - 商家对商家，交易双方都是企业（商家），最典型的案例就是阿里巴巴。</li>
<li>C2C - 个人对个人，例如：淘宝、人人车。</li>
<li>B2C - 商家对个人，例如：唯品会，聚美优品。</li>
<li>C2B - 个人对商家，先有消费者提出需求，后有商家按需求组织生产，例如： 尚品宅配。</li>
<li>O2O - 线上到线下，将线下的商务机会与互联网结合，让互联网成为线下交易的平台，例如：美团外卖、饿了么。</li>
<li>B2B2C - 商家对商家对个人，例如：天猫、京东。</li>
</ol>
<h3 id="需求要点"><a href="#需求要点" class="headerlink" title="需求要点"></a>需求要点</h3><ol>
<li><p>用户端</p>
<ul>
<li><p>首页（商品分类、广告轮播、滚动快讯、瀑布加载、推荐、折扣、热销、……）</p>
</li>
<li><p>用户（登录（第三方登录）、注册、注销、自服务（个人信息、浏览历史、收货地址、……））</p>
</li>
<li><p>商品（分类、列表、详情、搜索、热门搜索、搜索历史、添加到购物车、收藏、关注、评论、……）</p>
</li>
<li><p>购物车（查看、编辑（修改数量、删除商品、清空））</p>
</li>
<li><p>订单（提交订单（支付）、历史订单、订单详情、订单评价、……）</p>
</li>
</ul>
</li>
<li><p>管理端</p>
<ul>
<li>核心业务实体的CRUD</li>
<li>定时任务（周期性和非周期性，如处理未支付订单、采集数据对异常事件报警、……）</li>
<li>报表功能（导入导出Excel、PDF等以及前端ECharts统计图表展示）</li>
<li>权限控制（RBAC、白名单、黑名单、……）</li>
<li>业务流转（如发起退款流程，常用流程引擎有：Activity、Airflow、Spiff等）</li>
<li>三方服务（接入地图、短信、物流、支付、实名认证、天气、监控、云存储、……）</li>
</ul>
</li>
</ol>
<h3 id="物理模型设计"><a href="#物理模型设计" class="headerlink" title="物理模型设计"></a>物理模型设计</h3><p>首先要搞清楚两个概念：SPU（Standard Product Unit）和SKU（Stock Keeping Unit）。</p>
<ul>
<li>SPU：iPhone 6s</li>
<li>SKU：iPhone 6s 64G 土豪金</li>
</ul>
<p><img src="./res/shopping-pdm.png"></p>
<h3 id="第三方登录"><a href="#第三方登录" class="headerlink" title="第三方登录"></a>第三方登录</h3><p>第三方登录是指利用第三方网站（通常是知名社交网站）的账号进行登录验证（主要是通过知名第三方网站获取到用户相关信息），比如国内的 QQ、微博，国外的Google、Facebook等。第三方登录大部分都是使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OAuth">OAuth</a>协议，它是一个关于授权的开放网络标准（<strong>数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌，用来代替密码，供第三方应用使用</strong>），得到了广泛的应用，目前通常使用的是2.0版本。关于OAuth的基础知识，可以阅读阮一峰老师的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">《理解OAuth 2.0》</a>。关于<strong>令牌</strong>和<strong>密码</strong>的区别，我们可以简单总结出以下三点差异：</p>
<ol>
<li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li>
<li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li>
<li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li>
</ol>
<p>所以，通过令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是OAuth协议的优势。</p>
<h4 id="OAuth-2-0授权流程"><a href="#OAuth-2-0授权流程" class="headerlink" title="OAuth 2.0授权流程"></a>OAuth 2.0授权流程</h4><ol>
<li>用户打开客户端以后，客户端要求用户（资源所有者）给予授权。</li>
<li>用户（资源所有者）同意给予客户端授权。</li>
<li>客户端使用上一步获得的授权，向认证服务器申请访问令牌。</li>
<li>认证服务器对客户端进行认证以后，发放访问令牌。</li>
<li>客户端使用访问令牌向资源服务器申请获取资源。</li>
<li>资源服务器确认访问令牌无误，同意向客户端开放资源。</li>
</ol>
<p><img src="./res/oauth2.png"></p>
<p>如果使用微博登录进行接入，其具体步骤可以参考微博开放平台上的<a target="_blank" rel="noopener" href="http://open.weibo.com/wiki/Connect/login">“微博登录接入”</a>文档。使用QQ登录进行接入，需要首先注册成为QQ互联开发者并通过审核，具体的步骤可以参考QQ互联上的<a target="_blank" rel="noopener" href="http://wiki.connect.qq.com/">“接入指南”</a>，具体的步骤可以参考<a target="_blank" rel="noopener" href="http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0">“网站开发流程”</a>。</p>
<blockquote>
<p>提示：在Gitbook上面有一本名为<a target="_blank" rel="noopener" href="https://shenxgan.gitbooks.io/django/content/publish/2015-08-10-django-oauth-login.html">《Django博客入门》</a>的书以Github为例介绍了第三方账号登录，有兴趣的可以自行阅读。</p>
</blockquote>
<p>通常电商网站在使用第三方登录时，会要求与网站账号进行绑定或者根据获取到的第三方账号信息（如：手机号）自动完成账号绑定。</p>
<h3 id="缓存预热和查询缓存"><a href="#缓存预热和查询缓存" class="headerlink" title="缓存预热和查询缓存"></a>缓存预热和查询缓存</h3><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>所谓缓存预热，是指在启动服务器时将数据提前加载到缓存中，为此可以在Django应用的<code>apps.py</code>模块中编写<code>AppConfig</code>的子类并重写<code>ready()</code>方法，代码如下所示。</p>
<pre><code class="Python">import pymysql

from django.apps import AppConfig
from django.core.cache import cache

SELECT_PROVINCE_SQL = &#39;select distid, name from tb_district where pid is null&#39;


class CommonConfig(AppConfig):
    name = &#39;common&#39;

    def ready(self):
        conn = pymysql.connect(host=&#39;1.2.3.4&#39;, port=3306,
                               user=&#39;root&#39;, password=&#39;pass&#39;,
                               database=&#39;db&#39;, charset=&#39;utf8&#39;,
                               cursorclass=pymysql.cursors.DictCursor)
        try:
            with conn.cursor() as cursor:
                cursor.execute(SELECT_PROVINCE_SQL)
                provinces = cursor.fetchall()
                cache.set(&#39;provinces&#39;, provinces)
        finally:
            conn.close()
</code></pre>
<p>接下来，还需要在应用的<code>__init__.py</code>中编写下面的代码。</p>
<pre><code class="Python">default_app_config = &#39;common.apps.CommonConfig&#39;
</code></pre>
<p>或者在项目的<code>settings.py</code>文件中注册应用。</p>
<pre><code class="Python">INSTALLED_APPS = [
    ...
    &#39;common.apps.CommonConfig&#39;,
    ...
]
</code></pre>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>自定义装饰器实现查询结果的缓存。</p>
<pre><code class="Python">from pickle import dumps, loads

from django.core.cache import caches

MODEL_CACHE_KEY = &#39;project:modelcache:%s&#39;


def my_model_cache(key, section=&#39;default&#39;, timeout=None):
    &quot;&quot;&quot;实现模型缓存的装饰器&quot;&quot;&quot;

    def wrapper1(func):

        def wrapper2(*args, **kwargs):
            real_key = &#39;%s:%s&#39; % (MODEL_CACHE_KEY % key, &#39;:&#39;.join(map(str, args)))
            serialized_data = caches[section].get(real_key)
            if serialized_data:
                data = loads(serialized_data)
            else:
                data = func(*args, **kwargs)
                cache.set(real_key, dumps(data), timeout=timeout)
            return data

        return wrapper2

    return wrapper1
</code></pre>
<pre><code class="Python">@my_model_cache(key=&#39;provinces&#39;)
def get_all_provinces():
    return list(Province.objects.all())
</code></pre>
<h3 id="购物车实现"><a href="#购物车实现" class="headerlink" title="购物车实现"></a>购物车实现</h3><p>问题一：已登录用户的购物车放在哪里？未登录用户的购物车放在哪里？</p>
<pre><code class="Python">class CartItem(object):
    &quot;&quot;&quot;购物车中的商品项&quot;&quot;&quot;

    def __init__(self, sku, amount=1, selected=False):
        self.sku = sku
        self.amount = amount
        self.selected = selected

    @property
    def total(self):
        return self.sku.price * self.amount


class ShoppingCart(object):
    &quot;&quot;&quot;购物车&quot;&quot;&quot;

    def __init__(self):
        self.items = &#123;&#125;
        self.index = 0

    def add_item(self, item):
        if item.sku.id in self.items:
            self.items[item.sku.id].amount += item.amount
        else:
            self.items[item.sku.id] = item

    def remove_item(self, sku_id):
        if sku_id in self.items:
            self.items.remove(sku_id)

    def clear_all_items(self):
        self.items.clear()

    @property
    def cart_items(self):
        return self.items.values()

    @property
    def cart_total(self):
        total = 0
        for item in self.items.values():
            total += item.total
        return total
</code></pre>
<p>已登录用户的购物车可以放在数据库中（可以先在Redis中缓存）；未登录用户的购物车可以保存在Cookie、localStorage或sessionStorage中（减少服务器端内存开销）。</p>
<pre><code class="JSON">&#123;
    &#39;1001&#39;: &#123;sku: &#123;...&#125;, &#39;amount&#39;: 1, &#39;selected&#39;: True&#125;, 
    &#39;1002&#39;: &#123;sku: &#123;...&#125;, &#39;amount&#39;: 2, &#39;selected&#39;: False&#125;,
    &#39;1003&#39;: &#123;sku: &#123;...&#125;, &#39;amount&#39;: 3, &#39;selected&#39;: True&#125;,
&#125;
</code></pre>
<pre><code class="Python">request.get_signed_cookie(&#39;cart&#39;)

cart_base64 = base64.base64encode(pickle.dumps(cart))
response.set_signed_cookie(&#39;cart&#39;, cart_base64)
</code></pre>
<p>问题二：用户登录之后，如何合并购物车？（目前电商应用的购物车几乎都做了持久化处理，主要是方便在多个终端之间共享数据）</p>
<h3 id="集成支付功能"><a href="#集成支付功能" class="headerlink" title="集成支付功能"></a>集成支付功能</h3><p>问题一：支付信息如何持久化？（必须保证每笔交易都有记录）</p>
<p>问题二：如何接入支付宝？（接入其他平台基本类似）</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://open.alipay.com/platform/home.htm">蚂蚁金服开放平台</a>。</li>
<li><a target="_blank" rel="noopener" href="https://open.alipay.com/platform/homeRoleSelection.htm">入驻平台</a>。</li>
<li><a target="_blank" rel="noopener" href="https://openhome.alipay.com/platform/appManage.htm#/apps">开发者中心</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.open.alipay.com/270/105899/">文档中心</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.open.alipay.com/54/103419">SDK集成</a> - <a target="_blank" rel="noopener" href="https://pypi.org/project/alipay-sdk-python/">PYPI链接</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.open.alipay.com/270/105900/">API列表</a>。</li>
</ol>
<p><img src="./res/alipay_web_developer.png"></p>
<p>配置文件：</p>
<pre><code class="Python">ALIPAY_APPID = &#39;......&#39;
ALIPAY_URL = &#39;https://openapi.alipaydev.com/gateway.do&#39;
ALIPAY_DEBUG = False
</code></pre>
<p>获得支付链接（发起支付）：</p>
<pre><code class="Python"># 创建调用支付宝的对象
alipay = AliPay(
    # 在线创建应用时分配的ID
    appid=settings.ALIPAY_APPID,
    app_notify_url=None,
    # 自己应用的私钥
    app_private_key_path=os.path.join(
        os.path.dirname(os.path.abspath(__file__)), 
        &#39;keys/app_private_key.pem&#39;),
    # 支付宝的公钥
    alipay_public_key_path=os.path.join(
        os.path.dirname(os.path.abspath(__file__)), 
        &#39;keys/alipay_public_key.pem&#39;),
    sign_type=&#39;RSA2&#39;,
    debug=settings.ALIPAY_DEBUG
)
# 调用获取支付页面操作
order_info = alipay.api_alipay_trade_page_pay(
    out_trade_no=&#39;...&#39;,
    total_amount=&#39;...&#39;,
    subject=&#39;...&#39;,
    return_url=&#39;http://...&#39;
)
# 生成完整的支付页面URL
alipay_url = settings.ALIPAY_URL + &#39;?&#39; + order_info
return JsonResponse(&#123;&#39;alipay_url&#39;: alipay_url&#125;)
</code></pre>
<p>通过上面返回的链接可以进入支付页面，支付完成后会自动跳转回上面代码中设定好的项目页面，在该页面中可以获得订单号（out_trade_no）、支付流水号（trade_no）、交易金额（total_amount）和对应的签名（sign）并请求后端验证和保存交易结果，代码如下所示：</p>
<pre><code class="Python"># 创建调用支付宝的对象
alipay = AliPay(
    # 在线创建应用时分配的ID
    appid=settings.ALIPAY_APPID,
    app_notify_url=None,
    # 自己应用的私钥
    app_private_key_path=os.path.join(
        os.path.dirname(os.path.abspath(__file__)), 
        &#39;keys/app_private_key.pem&#39;),
    # 支付宝的公钥
    alipay_public_key_path=os.path.join(
        os.path.dirname(os.path.abspath(__file__)), 
        &#39;keys/alipay_public_key.pem&#39;),
    sign_type=&#39;RSA2&#39;,
    debug=settings.ALIPAY_DEBUG
)
# 请求参数（假设是POST请求）中包括订单号、支付流水号、交易金额和签名
params = request.POST.dict()
# 调用验证操作
if alipay.verify(params, params.pop(&#39;sign&#39;)):
    # 对交易进行持久化操作
</code></pre>
<p>支付宝的支付API还提供了交易查询、交易结算、退款、退款查询等一系列的接口，可以根据业务需要进行调用，此处不再进行赘述。</p>
<h3 id="秒杀和超卖"><a href="#秒杀和超卖" class="headerlink" title="秒杀和超卖"></a>秒杀和超卖</h3><ol>
<li>秒杀：秒杀是通常意味着要在很短的时间处理极高的并发，系统在短时间需要承受平时百倍以上的流量，因此秒杀架构是一个比较复杂的问题，其核心思路是流量控制和性能优化，需要从前端（通过JavaScript实现倒计时、避免重复提交和限制频繁刷新）到后台各个环节的配合。流量控制主要是限制只有少部分流量进入服务后端（毕竟最终只有少部分用户能够秒杀成功），同时在物理架构上使用缓存（一方面是因为读操作多写操作少；另外可以将库存放在Redis中，利用DECR原语实现减库存；同时也可以利用Redis来进行限流，道理跟限制频繁发送手机验证码是一样的）和消息队列（消息队列最为重要的作用就是“削峰”和“上下游节点解耦合”）来进行优化；此外还要采用无状态服务设计，这样才便于进行水平扩展（通过增加设备来为系统扩容）。</li>
<li>超卖现象：比如某商品的库存为1，此时用户1和用户2并发购买该商品，用户1提交订单后该商品的库存被修改为0，而此时用户2并不知道的情况下提交订单，该商品的库存再次被修改为-1这就是超卖现象。解决超卖现象有三种常见的思路：<ul>
<li>悲观锁控制：查询商品数量的时候就用<code>select ... for update</code>对数据加锁，这样的话用户1查询库存时，用户2因无法读取库存数量被阻塞，直到用户1提交或者回滚了更新库存的操作后才能继续，从而解决了超卖问题。但是这种做法对并发访问量很高的商品来说性能太过糟糕，实际开发中可以在库存小于某个值时才考虑加锁，但是总的来说这种做法不太可取。</li>
<li>乐观锁控制：查询商品数量不用加锁，更新库存的时候设定商品数量必须与之前查询数量相同才能更新，否则说明其他事务已经更新了库存，必须重新发出请求。</li>
<li>尝试减库存：将上面的查询（<code>select</code>）和更新（<code>update</code>）操作合并为一条SQL操作，更新库存的时候，在<code>where</code>筛选条件中加上<code>库存&gt;=购买数量</code>或<code>库存-购买数量&gt;=0</code>的条件，这种做法要求事务隔离级别为读提交（read committed）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：有兴趣的可以自己在知乎上看看关于这类问题的讨论。</p>
</blockquote>
<h3 id="静态资源管理"><a href="#静态资源管理" class="headerlink" title="静态资源管理"></a>静态资源管理</h3><p>静态资源的管理可以自己架设文件服务器或者分布式文件服务器（FastDFS），但是一般的项目中没有必要这样做而且效果未必是最好的，我们建议使用云存储服务来管理网站的静态资源，国内外的云服务提供商如<a target="_blank" rel="noopener" href="https://amazonaws-china.com/cn/">亚马逊</a>、<a target="_blank" rel="noopener" href="https://www.aliyun.com/product/oss">阿里云</a>、<a target="_blank" rel="noopener" href="https://www.qiniu.com/products/kodo">七牛</a>、<a target="_blank" rel="noopener" href="https://leancloud.cn/storage/">LeanCloud</a>、<a target="_blank" rel="noopener" href="https://www.bmob.cn/cloud">Bmob</a>等都提供了非常优质的云存储服务，而且价格也是一般公司可以接受的，具体的操作可以参考官方文档，例如：阿里云的<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/support/developer-resources">对象存储 OSS开发人员指南</a>。</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h4><ol>
<li>使用数据库的模糊查询功能 - 效率低，每次需要全表扫描，不支持分词。</li>
<li>使用数据库的全文检索功能 - MySQL 5.6以前只适用于MyISAM引擎，检索操作和其他的DML操作耦合在数据库中，可能导致检索操作非常缓慢，数据量达到百万级性能显著下降，查询时间很长。</li>
<li>使用开源搜索引擎 - 索引数据和原始数据分离，可以使用ElasticSearch或Solr来提供外置索引服务，如果不考虑高并发的全文检索需求，纯Python的Whoosh也可以考虑。</li>
</ol>
<h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><p>ElasticSearch既是一个分布式文档数据库又是一个高可扩展的开源全文搜索和分析引擎，它允许存储、搜索和分析大量的数据，并且这个过程是近实时的。它通常被用作底层引擎和技术，为复杂的搜索功能和要求提供动力，大家熟知的维基百科、Stack-Overflow、Github都使用了ElasticSearch。</p>
<p>ElasticSearch的底层是开源搜索引擎<a target="_blank" rel="noopener" href="https://lucene.apache.org/">Lucene</a>，但是直接用Lucene会非常麻烦，必须自己编写代码去调用它的接口而且只支持Java语言。ElasticSearch相当于对Lucene进行了一次全面的封装，提供了REST风格的API接口，通过基于HTTP协议的访问方式屏蔽了编程语言的差异。ElasticSearch会为数据构建<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">倒排索引</a>，但是ElasticSearch内置的分词器对中文分词的支持几乎为零，因此需要通过安装elasticsearch-analysis-ik插件来提供中文分词服务。</p>
<p>ElasticSearch的安装和配置可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/jinyidong/article/details/80475320">《ElasticSearch之Docker安装》</a>。除了ElasticSearch之外，也可以使用Solr、Whoosh等来提供搜索引擎服务，基本上Django项目中可以考虑如下几种方案：</p>
<ul>
<li>haystack（django-haystack / drf-haystack） + whoosh + Jieba</li>
<li>haystack （django-haystack / drf-haystack）+ elasticsearch</li>
<li>requests + elasticsearch</li>
<li>django-elasticsearch-dsl</li>
</ul>
<p>####安装和使用ElasticSearch</p>
<ol>
<li><p>使用Docker安装ElasticSearch。</p>
<pre><code class="Shell">docker pull elasticsearch:7.6.0
docker run -d -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; --name es elasticsearch:7.6.0
</code></pre>
<blockquote>
<p>说明：上面创建容器时通过<code>-e</code>参数指定了使用单机模式和Java虚拟机最小最大可用堆空间的大小，堆空间大小可以根据服务器实际能够提供给ElasticSearch的内存大小来决定，默认为2G。</p>
</blockquote>
</li>
<li><p>创建数据库。</p>
<p>请求：PUT - <code>http://1.2.3.4:9200/demo/</code></p>
<p>响应：</p>
<pre><code class="JSON">&#123;
   &quot;acknowledged&quot;: true,
   &quot;shards_acknowledged&quot;: true,
   &quot;index&quot;: &quot;demo&quot;
&#125;
</code></pre>
</li>
<li><p>查看创建的数据库。</p>
<p>请求：GET - <code>http://1.2.3.4:9200/demo/</code></p>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;demo&quot;: &#123;
        &quot;aliases&quot;: &#123;&#125;,
        &quot;mappings&quot;: &#123;&#125;,
        &quot;settings&quot;: &#123;
            &quot;index&quot;: &#123;
                &quot;creation_date&quot;: &quot;1552213970199&quot;,
                &quot;number_of_shards&quot;: &quot;5&quot;,
                &quot;number_of_replicas&quot;: &quot;1&quot;,
                &quot;uuid&quot;: &quot;ny3rCn10SAmCsqW6xPP1gw&quot;,
                &quot;version&quot;: &#123;
                    &quot;created&quot;: &quot;6050399&quot;
                &#125;,
                &quot;provided_name&quot;: &quot;demo&quot;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>插入数据。</p>
<p>请求：POST - <code>http://1.2.3.4:9200/demo/goods/1/</code></p>
<p>请求头：Content-Type: application/json</p>
<p>参数：</p>
<pre><code class="JSON">&#123;
    &quot;no&quot;: &quot;5089253&quot;,
    &quot;title&quot;: &quot;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机&quot;,
    &quot;brand&quot;: &quot;Apple&quot;,
    &quot;name&quot;: &quot;Apple iPhone X&quot;,
    &quot;product&quot;: &quot;中国大陆&quot;,
    &quot;resolution&quot;: &quot;2436 x 1125&quot;,
    &quot;intro&quot;: &quot;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。&quot;
&#125;
</code></pre>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;goods&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 4,
    &quot;result&quot;: &quot;created&quot;,
    &quot;_shards&quot;: &#123;
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    &#125;,
    &quot;_seq_no&quot;: 3,
    &quot;_primary_term&quot;: 1
&#125;
</code></pre>
</li>
<li><p>删除数据。</p>
<p>请求：DELETE -  <code>http://1.2.3.4:9200/demo/goods/1/</code></p>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;goods&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 2,
    &quot;result&quot;: &quot;deleted&quot;,
    &quot;_shards&quot;: &#123;
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    &#125;,
    &quot;_seq_no&quot;: 1,
    &quot;_primary_term&quot;: 1
&#125;
</code></pre>
</li>
<li><p>更新数据。</p>
<p>请求：PUT - <code>http://1.2.3.4:9200/demo/goods/1/_update</code></p>
<p>请求头：Content-Type: application/json</p>
<p>参数：</p>
<pre><code class="JSON">&#123;
    &quot;doc&quot;: &#123;
        &quot;no&quot;: &quot;5089253&quot;,
        &quot;title&quot;: &quot;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机&quot;,
        &quot;brand&quot;: &quot;Apple(苹果)&quot;,
        &quot;name&quot;: &quot;Apple iPhone X&quot;,
        &quot;product&quot;: &quot;美国&quot;,
        &quot;resolution&quot;: &quot;2436 x 1125&quot;,
        &quot;intro&quot;: &quot;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。&quot;
    &#125;
&#125;
</code></pre>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;goods&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 10,
    &quot;result&quot;: &quot;updated&quot;,
    &quot;_shards&quot;: &#123;
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    &#125;,
    &quot;_seq_no&quot;: 9,
    &quot;_primary_term&quot;: 1
&#125;
</code></pre>
</li>
<li><p>查询数据。</p>
<p>请求：GET - <code>http://1.2.3.4:9200/demo/goods/1/</code></p>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;goods&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 10,
    &quot;found&quot;: true,
    &quot;_source&quot;: &#123;
        &quot;doc&quot;: &#123;
            &quot;no&quot;: &quot;5089253&quot;,
            &quot;title&quot;: &quot;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机&quot;,
            &quot;brand&quot;: &quot;Apple(苹果)&quot;,
            &quot;name&quot;: &quot;Apple iPhone X&quot;,
            &quot;product&quot;: &quot;美国&quot;,
            &quot;resolution&quot;: &quot;2436 x 1125&quot;,
            &quot;intro&quot;: &quot;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。&quot;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h4 id="配置中文分词和拼音插件"><a href="#配置中文分词和拼音插件" class="headerlink" title="配置中文分词和拼音插件"></a>配置中文分词和拼音插件</h4><ol>
<li><p>进入Docker容器的plugins目录。</p>
<pre><code class="Shell">docker exec -it es /bin/bash
</code></pre>
</li>
<li><p>下载和ElasticSearch版本对应的<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a>和<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin">pinyin</a>插件。</p>
<pre><code class="Shell">yum install -y wget
cd plugins/
mkdir ik
cd ik
wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.0/elasticsearch-analysis-ik-7.6.0.zip
unzip elasticsearch-analysis-ik-7.6.0.zip
rm -f elasticsearch-analysis-ik-7.6.0.zip
cd ..
mkdir pinyin
cd pinyin
wget https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v7.6.0/elasticsearch-analysis-pinyin-7.6.0.zip
unzip elasticsearch-analysis-pinyin-7.6.0.zip
rm -f elasticsearch-analysis-pinyin-7.6.0.zip
</code></pre>
</li>
<li><p>退出容器，重启ElasticSearch。</p>
<pre><code class="Shell">docker restart es
</code></pre>
</li>
<li><p>测试中文分词效果。</p>
<p>请求：POST - <code>http://1.2.3.4:9200/_analyze</code></p>
<p>请求头：Content-Type: application/json</p>
<p>参数：</p>
<pre><code class="JSON">&#123;
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot;: &quot;中国男足在2022年卡塔尔世界杯预选赛中勇夺小组最后一名&quot;
&#125;
</code></pre>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;tokens&quot;: [
        &#123;
            &quot;token&quot;: &quot;中国&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 2,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 0
        &#125;,
        &#123;
            &quot;token&quot;: &quot;男足&quot;,
            &quot;start_offset&quot;: 2,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 1
        &#125;,
        &#123;
            &quot;token&quot;: &quot;在&quot;,
            &quot;start_offset&quot;: 4,
            &quot;end_offset&quot;: 5,
            &quot;type&quot;: &quot;CN_CHAR&quot;,
            &quot;position&quot;: 2
        &#125;,
        &#123;
            &quot;token&quot;: &quot;2022年&quot;,
            &quot;start_offset&quot;: 5,
            &quot;end_offset&quot;: 10,
            &quot;type&quot;: &quot;TYPE_CQUAN&quot;,
            &quot;position&quot;: 3
        &#125;,
        &#123;
            &quot;token&quot;: &quot;卡塔尔&quot;,
            &quot;start_offset&quot;: 10,
            &quot;end_offset&quot;: 13,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 4
        &#125;,
        &#123;
            &quot;token&quot;: &quot;世界杯&quot;,
            &quot;start_offset&quot;: 13,
            &quot;end_offset&quot;: 16,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 5
        &#125;,
        &#123;
            &quot;token&quot;: &quot;预选赛&quot;,
            &quot;start_offset&quot;: 16,
            &quot;end_offset&quot;: 19,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 6
        &#125;,
        &#123;
            &quot;token&quot;: &quot;中&quot;,
            &quot;start_offset&quot;: 19,
            &quot;end_offset&quot;: 20,
            &quot;type&quot;: &quot;CN_CHAR&quot;,
            &quot;position&quot;: 7
        &#125;,
        &#123;
            &quot;token&quot;: &quot;勇夺&quot;,
            &quot;start_offset&quot;: 20,
            &quot;end_offset&quot;: 22,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 8
        &#125;,
        &#123;
            &quot;token&quot;: &quot;小组&quot;,
            &quot;start_offset&quot;: 22,
            &quot;end_offset&quot;: 24,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 9
        &#125;,
        &#123;
            &quot;token&quot;: &quot;最后&quot;,
            &quot;start_offset&quot;: 24,
            &quot;end_offset&quot;: 26,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 10
        &#125;,
        &#123;
            &quot;token&quot;: &quot;一名&quot;,
            &quot;start_offset&quot;: 26,
            &quot;end_offset&quot;: 28,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 11
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>测试拼音分词效果。</p>
<p>请求：POST - <code>http://1.2.3.4:9200/_analyze</code></p>
<p>请求头：Content-Type: application/json</p>
<p>参数：</p>
<pre><code class="JSON">&#123;
  &quot;analyzer&quot;: &quot;pinyin&quot;,
  &quot;text&quot;: &quot;张学友&quot;
&#125;
</code></pre>
<p>响应：</p>
<pre><code class="JSON">&#123;
    &quot;tokens&quot;: [
        &#123;
            &quot;token&quot;: &quot;zhang&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        &#125;,
        &#123;
            &quot;token&quot;: &quot;zxy&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 0
        &#125;,
        &#123;
            &quot;token&quot;: &quot;xue&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 1
        &#125;,
        &#123;
            &quot;token&quot;: &quot;you&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 0,
            &quot;type&quot;: &quot;word&quot;,
            &quot;position&quot;: 2
        &#125;
    ]
&#125;
</code></pre>
</li>
</ol>
<h4 id="全文检索功能"><a href="#全文检索功能" class="headerlink" title="全文检索功能"></a>全文检索功能</h4><p>可以通过GET或者POST请求进行搜索，下面演示了搜索有“未来”关键词商品。</p>
<ol>
<li><p>GET - <code>http://120.77.222.217:9200/demo/goods/_search?q=未来</code></p>
<blockquote>
<p>注意：URL中的中文应该要处理成百分号编码。</p>
</blockquote>
<pre><code class="JSON">&#123;
    &quot;took&quot;: 19,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: &#123;
        &quot;total&quot;: 5,
        &quot;successful&quot;: 5,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    &#125;,
    &quot;hits&quot;: &#123;
        &quot;total&quot;: 2,
        &quot;max_score&quot;: 0.73975396,
        &quot;hits&quot;: [
            &#123;
                &quot;_index&quot;: &quot;demo&quot;,
                &quot;_type&quot;: &quot;goods&quot;,
                &quot;_id&quot;: &quot;1&quot;,
                &quot;_score&quot;: 0.73975396,
                &quot;_source&quot;: &#123;
                    &quot;doc&quot;: &#123;
                        &quot;no&quot;: &quot;5089253&quot;,
                        &quot;title&quot;: &quot;Apple iPhone X (A1865) 64GB 深空灰色 移动联通电信4G手机&quot;,
                        &quot;brand&quot;: &quot;Apple(苹果)&quot;,
                        &quot;name&quot;: &quot;Apple iPhone X&quot;,
                        &quot;product&quot;: &quot;美国&quot;,
                        &quot;resolution&quot;: &quot;2436*1125&quot;,
                        &quot;intro&quot;: &quot;一直以来，Apple都心存一个设想，期待能够打造出这样一部iPhone：它有整面屏幕，能让你在使用时，完全沉浸其中，仿佛忘了它的存在。它是如此智能，哪怕轻轻一瞥，都能得到它心有灵犀的回应。而这个设想，终于随着iPhone X的到来成为了现实。现在，就跟未来见个面吧。&quot;
                    &#125;
                &#125;
            &#125;,
            &#123;
                &quot;_index&quot;: &quot;demo&quot;,
                &quot;_type&quot;: &quot;goods&quot;,
                &quot;_id&quot;: &quot;3&quot;,
                &quot;_score&quot;: 0.68324494,
                &quot;_source&quot;: &#123;
                    &quot;no&quot;: &quot;42417956432&quot;,
                    &quot;title&quot;: &quot;小米9 透明尊享版 手机 透明尊享 全网通(12GB + 256GB)&quot;,
                    &quot;brand&quot;: &quot;小米（MI）&quot;,
                    &quot;name&quot;: &quot;小米（MI）小米9透明&quot;,
                    &quot;product&quot;: &quot;中国大陆&quot;,
                    &quot;resolution&quot;: &quot;2340*1080&quot;,
                    &quot;intro&quot;: &quot;全面透明机身，独特科幻机甲风，来自未来的设计。&quot;
                &#125;
            &#125;
        ]
    &#125;
&#125;
</code></pre>
<p>URL中可用的搜索参数如下表所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>q</td>
<td>查询字符串</td>
</tr>
<tr>
<td>analyzer</td>
<td>分析查询字符串使用的分词器</td>
</tr>
<tr>
<td>analyze_wildcard</td>
<td>通配符或者前缀查询是否被分析，默认为false</td>
</tr>
<tr>
<td>default_operator</td>
<td>多个条件之间的关系，默认为OR，可以修改为AND</td>
</tr>
<tr>
<td>explain</td>
<td>在返回的结果中包含评分机制的解释</td>
</tr>
<tr>
<td>fields</td>
<td>只返回索引中指定的列，多个列中间用逗号隔开</td>
</tr>
<tr>
<td>sort</td>
<td>排序参考的字段，可以用:asc和:desc来指定升序和降序</td>
</tr>
<tr>
<td>timeout</td>
<td>超时时间</td>
</tr>
<tr>
<td>from</td>
<td>匹配结果的开始值，默认为0</td>
</tr>
<tr>
<td>size</td>
<td>匹配结果的条数，默认为10</td>
</tr>
</tbody></table>
</li>
<li><p>POST - <code>http://120.77.222.217:9200/demo/goods/_search</code></p>
<p>请求头：Content-Type: application/json</p>
<p>参数：</p>
<pre><code class="JSON">&#123;
    &quot;query&quot;: &#123;
        &quot;term&quot;: &#123;
            &quot;type&quot;: &quot;&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<p>POST搜索是基于DSL的。</p>
</li>
</ol>
<h4 id="Django对接ElasticSearch"><a href="#Django对接ElasticSearch" class="headerlink" title="Django对接ElasticSearch"></a>Django对接ElasticSearch</h4><p>Python对接ElasticSearch的第三方库是HayStack，在Django项目中可以使用django-haystack，通过HayStack可以在不修改代码对接多种搜索引擎服务。</p>
<pre><code class="shell">pip install django-haystack elasticsearch
</code></pre>
<p>配置文件：</p>
<pre><code class="Python">INSTALLED_APPS = [
    ...
    &#39;haystack&#39;,
    ...
]

HAYSTACK_CONNECTIONS = &#123;
    &#39;default&#39;: &#123;
        # 引擎配置
        &#39;ENGINE&#39;: &#39;haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine&#39;,
        # 搜索引擎服务的URL
        &#39;URL&#39;: &#39;http://1.2.3.4:9200&#39;,
        # 索引库的名称
        &#39;INDEX_NAME&#39;: &#39;goods&#39;,
    &#125;,
&#125;

# 添加/删除/更新数据时自动生成索引
HAYSTACK_SIGNAL_PROCESSOR = &#39;haystack.signals.RealtimeSignalProcessor&#39;
</code></pre>
<p>索引类：</p>
<pre><code class="Python">from haystack import indexes


class GoodsIndex(indexes.SearchIndex, indexes.Indexable):
    text = indexes.CharField(document=True, use_template=True)

    def get_model(self):
        return Goods

    def index_queryset(self, using=None):
        return self.get_model().objects.all()
</code></pre>
<p>编辑text字段的模板（需要放在templates/search/indexes/demo/goods_text.txt）：</p>
<pre><code>&#123;&#123;object.title&#125;&#125;
&#123;&#123;object.intro&#125;&#125;
</code></pre>
<p>配置URL：</p>
<pre><code class="Python">urlpatterns = [
    # ...
    url(&#39;search/&#39;, include(&#39;haystack.urls&#39;)),
]
</code></pre>
<p>生成初始索引：</p>
<pre><code class="Shell">python manage.py rebuild_index
</code></pre>
<blockquote>
<p> 说明：可以参考<a target="_blank" rel="noopener" href="https://www.zmrenwu.com/post/45/">《Django Haystack 全文检索与关键词高亮》</a>一文来更深入的了解基于Haystack的全文检索操作。</p>
</blockquote>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/96.软件测试和自动化测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.044Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/96.%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="软件测试和自动化测试"><a href="#软件测试和自动化测试" class="headerlink" title="软件测试和自动化测试"></a>软件测试和自动化测试</h2><h3 id="软件测试概述"><a href="#软件测试概述" class="headerlink" title="软件测试概述"></a>软件测试概述</h3><p>软件测试是一种用来促进鉴定软件的正确性、完整性、安全性和品质的过程，也就是在规定的条件下对程序进行操作以发现程序中的错误，衡量软件的品质并对其是否能满足设计要求进行评估的过程。</p>
<h4 id="测试的方法"><a href="#测试的方法" class="headerlink" title="测试的方法"></a>测试的方法</h4><p>黑盒测试：测试应用程序的功能，而不是其内部结构或运作。测试者不需具备应用程序的代码、内部结构和编程语言的专门知识。测试者只需知道什么是系统应该做的事，即当键入一个特定的输入，可得到一定的输出。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。此测试方法可适合大部分的软件测试，例如集成测试和系统测试。</p>
<p>白盒测试：测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑箱测试）。在白箱测试时，以编程语言的角度来设计测试案例。测试者输入数据验证数据流在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。</p>
<p>由于时间和成本的约束，软件测试中一个最为关键的问题就是：“<strong>在所有可能的测试用例中，哪个子集能发现最多的错误？</strong>”。所以在设计测试用例时，白盒测试看重程序逻辑覆盖的程度（语句覆盖、条件覆盖、分支覆盖），黑盒测试可以使用等价类划分、边界值分析、因果图分析、错误猜测等方法来设计测试用例。</p>
<h4 id="测试的种类（阶段）"><a href="#测试的种类（阶段）" class="headerlink" title="测试的种类（阶段）"></a>测试的种类（阶段）</h4><p>单元测试：对软件组成单元进行测试，其目的是检验软件基本组成单位的正确性，测试的对象是软件设计的最小单位 - 函数。</p>
<p>集成测试：将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。其主要目的是检查软件单位之间的接口是否正确，集成测试的对象是已经经过单元测试的模块。</p>
<p>系统测试：系统测试主要包括功能测试、界面测试、可靠性测试、易用性测试、性能测试。 </p>
<p>回归测试：为了检测代码修改而引入的错误所进行的测试活动。回归测试是软件维护阶段的重要工作，有研究表明，回归测试带来的耗费占软件生命周期的1/3总费用以上。</p>
<h4 id="测试驱动开发（敏捷测试）"><a href="#测试驱动开发（敏捷测试）" class="headerlink" title="测试驱动开发（敏捷测试）"></a>测试驱动开发（敏捷测试）</h4><p>测试驱动开发包括以下三个步骤：</p>
<ol>
<li>为未实现的新功能或者改进编写自动化测试。</li>
<li>提供通过所有定义的测试的最小代码量。</li>
<li>重构代码以满足所需的质量标准。</li>
</ol>
<p>测试驱动开发的好处在于可以有效的防止软件回归以及提供更有质量的代码。还有就是验收测试应该由客户来进行，客户通过对使用场景来设计验收测试，对应用程序是否满足他们的要求进行客观、公正的确认。能够通过单元测试、甚至是系统测试的功能未必能够通过客户的验收测试。</p>
<h4 id="互联网应用和移动应用的测试"><a href="#互联网应用和移动应用的测试" class="headerlink" title="互联网应用和移动应用的测试"></a>互联网应用和移动应用的测试</h4><p>互联网应用的测试策略：</p>
<ol>
<li>表示层测试（内容测试、站点结构测试、用户环境（浏览器、操作系统等））</li>
<li>业务层测试（性能、数据验证、事务、外部服务）</li>
<li>持久层测试（响应时间、数据完整性、容错性）</li>
</ol>
<p>移动应用的测试策略：</p>
<ol>
<li>真机测试</li>
<li>基于模拟器的测试</li>
</ol>
<h3 id="单元（模块）测试"><a href="#单元（模块）测试" class="headerlink" title="单元（模块）测试"></a>单元（模块）测试</h3><p>Python的标准库里有为编写单元测试而准备的unittest模块，执行测试时建议使用<a target="_blank" rel="noopener" href="https://docs.pytest.org/en/latest/">pytest</a>或nose2。pytest是一款能够自动搜索并执行测试的测试执行工具，并且会输出详细的错误报告。关于单元测试可以看看<a target="_blank" rel="noopener" href="https://blog.csdn.net/huilan_same/article/details/52944782">《Python必会的单元测试框架 - unittest》</a>。</p>
<p>可以安装<a target="_blank" rel="noopener" href="https://pypi.org/project/testfixtures/">testfixtures</a>库来辅助单元测试，它整合了多种典型配置器，提供了生成目录、更改系统日期、生成mock对象的功能模块，这些模块能够帮助我们将单元测试与单元测试所依赖的环境分离开。<a target="_blank" rel="noopener" href="https://pypi.org/project/mock/">mock</a> 是将测试对象所依赖的对象替换为虚拟对象的库，在测试的时候，我们可以为虚拟对象指定其在被调用时的返回值以及是否发生异常等。</p>
<p>tox能便捷地为我们准备好执行测试所需的环境。tox会在多个virtualenv环境中搭建测试 环境，然后在这些环境中执行测试并显示结果。它能够把测试工具的选项及环境变量等内容统 一起来，所以我们只需执行tox命令即能轻松完成所需的测试。 </p>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="UI自动化测试"><a href="#UI自动化测试" class="headerlink" title="UI自动化测试"></a>UI自动化测试</h4><h5 id="桌面端-PyAutoGui"><a href="#桌面端-PyAutoGui" class="headerlink" title="桌面端 - PyAutoGui"></a>桌面端 - <a target="_blank" rel="noopener" href="https://pyautogui.readthedocs.io/en/latest/">PyAutoGui</a></h5><h5 id="移动端-Appnium"><a href="#移动端-Appnium" class="headerlink" title="移动端 - Appnium"></a>移动端 - <a target="_blank" rel="noopener" href="http://appium.io/">Appnium</a></h5><h5 id="Web端-Selenium"><a href="#Web端-Selenium" class="headerlink" title="Web端 - Selenium"></a>Web端 - <a target="_blank" rel="noopener" href="https://docs.seleniumhq.org/">Selenium</a></h5><p>Selenium是实现Web应用程序的功能测试以及集成测试自动化的浏览器驱动测试工具群。和使用浏览器的用户相同，Selenium可以在浏览器进行的鼠标操作、在表单中输入文字、验证表单的值等，利用这一点就可以将手动操作变成自动化操作。</p>
<ol>
<li>Selenium优点</li>
</ol>
<ul>
<li>自动化测试用例制作简单。Selenium提供了Selenium IDE工具，该工具可以捕获鼠标、键盘的操作，然后通过重放功能来重复这些操作，这样就可以简单的制作测试用例。</li>
<li>支持多种浏览器和操作系统。</li>
</ul>
<ol start="2">
<li>Selenium的组件</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.seleniumhq.org/projects/ide/">Selenium IDE</a></li>
<li><a target="_blank" rel="noopener" href="https://www.seleniumhq.org/projects/remote-control/">Selenium Remote Control</a></li>
<li><a target="_blank" rel="noopener" href="https://www.seleniumhq.org/projects/webdriver/">Selenium WebDriver</a></li>
</ul>
<ol start="3">
<li><p>与持续集成工具协作</p>
<p>持续集成指的是频繁的将代码集成到主干。它的好处主要有两个：</p>
<ul>
<li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
</ul>
<p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成。编程大师Martin Fowler曾经说过：“持续集成并不能消除Bug，而是让它们非常容易发现和改正。”</p>
<p>可以在Jenkins中安装“Seleniumhq Plugin”插件，这样就可以将Selenium IDE制作的测试用例保存为HTML格式并提供给Jenkins来使用，基本步骤是：</p>
<ul>
<li><p>在执行测试的机器上，从版本控制系统中下载测试套件和测试用例。</p>
</li>
<li><p>在执行测试的机器上下载Selenium Server。</p>
</li>
<li><p>从Jenkins的“系统管理”中选择“插件管理”来安装“Seleniumhq Plugin”。</p>
</li>
<li><p>在Jenkins的“系统管理”中选择“系统设置”并配置“Selenium Remote Control”下的“HTMLSuite Runner”。</p>
</li>
<li><p>新建测试用的Jenkins任务并进行配置，配置的内容包括：浏览器、起始URL、测试套件和测试结果输出文件。</p>
</li>
</ul>
<p>配置完成后，就可以执行Jenkins的“立即构建”了。  </p>
</li>
</ol>
<p>除了Selenium之外，<a target="_blank" rel="noopener" href="https://pypi.org/project/WebTest/">WebTest</a>、<a target="_blank" rel="noopener" href="https://splinter.readthedocs.io/en/latest/">Splinter</a>和<a target="_blank" rel="noopener" href="https://robotframework.org/">RobotFramework</a>也是Web端测试的选择，其中WebTest可以对WSGI应用执行模拟请求并获取结果，基本上所有WSGI应用的测试都可以用它；Splinter是对Selenium的二次封装，使用上更加方便简单。</p>
<h4 id="接口测试自动化测试"><a href="#接口测试自动化测试" class="headerlink" title="接口测试自动化测试"></a>接口测试自动化测试</h4><ol>
<li><a target="_blank" rel="noopener" href="https://cn.python-requests.org/zh_CN/latest/">requests</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.httprunner.org/">HttpRunner</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/svanoort/pyresttest">PyRestTest</a></li>
</ol>
<h4 id="其他方面的自动化测试"><a href="#其他方面的自动化测试" class="headerlink" title="其他方面的自动化测试"></a>其他方面的自动化测试</h4><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.locust.io/">Locust</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/m4n3dw0lf/PytheM">pythem</a></p>
</li>
</ol>
<h3 id="测试相关工具"><a href="#测试相关工具" class="headerlink" title="测试相关工具"></a>测试相关工具</h3><ol>
<li>PostMan</li>
<li>AB</li>
<li>JMeter</li>
<li>LoadRunner</li>
<li>Benchmark Factory</li>
<li>WAS</li>
</ol>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/94.网络API接口设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.029Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/94.%E7%BD%91%E7%BB%9CAPI%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="网络API接口设计"><a href="#网络API接口设计" class="headerlink" title="网络API接口设计"></a>网络API接口设计</h2><p>目前许多的Web应用和移动应用都使用了前后端分离的开发模式，前后端分离简单的说就是前端或移动端通过网络API接口和后台进行交互，获得接口中提供的数据并负责用户界面的渲染。API是应用程序的编程接口的缩写，网络API通常指的是基于一个URL（统一资源定位符）可以访问到的资源，也就是说通过这个URL我们就可以请求服务器对某个资源进行操作并返回操作的结果。大家可以想想，网络API接口不也是一种封装吗，简单的说就是将复杂的业务逻辑隐藏在简单的API接口中。</p>
<p>URL的通用格式如下所示：</p>
<pre><code>协议://用户名:口令@主机:端口/路径1/.../路径N/资源名
</code></pre>
<blockquote>
<p><strong>说明</strong>：URL中的用户名（有可能不需要提供用户名）、口令（有可能不需要提供口令）、端口（有可能使用默认端口）、路径（资源有可能直接位于根路径<code>/</code>下）并不是必需的部分，可以根据需要进行设置。</p>
</blockquote>
<p>网络API通常基于HTTP或HTTPS进行访问，基于HTTP/HTTPS最大的好处就在于访问起来非常的简单方便，而且可以跨语言、跨应用进行访问和互操作。</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h4 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h4><p>为移动端或者PC端设计网络API接口一个非常重要的原则是：<strong>根据业务实体而不是用户界面或操作来设计API接口</strong>。如果API接口的设计是根据用户的操作或者界面上的功能设置来设计，随着需求的变更，用户界面也会进行调整，需要的数据也在发生变化，那么后端开发者就要不停的调整API，或者给一个API设计出多个版本，这些都会使项目的开发和维护成本增加。我们可以将业务实体理解为服务器提供的资源，而URL就是资源的定位符（标识符），这种方式是最为简单自然的。对于相对复杂的用户操作，我们可以提供一个“门面”（设计模式中的“门面模式”），通过该“门面”把多个接口的功能组装起来即可。</p>
<p>下面是某个网站开放API的接口，可以看出API的设计是围绕业务实体来进行的，而且都做到了“见名知意”。</p>
<table>
<thead>
<tr>
<th>评论</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>comments/show</td>
<td>获取某条微博的评论列表</td>
</tr>
<tr>
<td>comments/by_me</td>
<td>自己的评论列表</td>
</tr>
<tr>
<td>comments/to_me</td>
<td>收到的评论列表</td>
</tr>
<tr>
<td>comments/mentions</td>
<td>@了自己的评论列表</td>
</tr>
<tr>
<td>comments/create</td>
<td>创建一条评论</td>
</tr>
<tr>
<td>comments/destroy</td>
<td>删除一条评论</td>
</tr>
<tr>
<td>comments/reply</td>
<td>回复一条评论</td>
</tr>
</tbody></table>
<p>需要说明的是，<strong>上面的API接口并不是REST风格的</strong>。REST是一种网络应用架构风格，被认为最适合分布式的网络应用。关于REST的知识，可以阅读阮一峰的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/09/restful.html">《理解RESTful架构》</a>以及<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">《RESTful API设计指南》</a>，当然这两篇文章大家也要批判的阅读，因为上面阐述的观点并不完全正确，有些内容甚至是自相矛盾的。</p>
<p>API接口返回的数据通常都是<strong>JSON</strong>或<strong>XML</strong>格式，XML这种数据格式目前基本已经被弃用了。对于JSON格式的数据，我们需要做到不要返回null这的值，因为这样的值一旦处置失当，会给前端和移动端开发带来不必要的麻烦（因为开发者有可能会使用强类型语言）。要解决这个问题可以从源头入手，在设计数据库的时候，尽量给每个字段都加上“not null”约束或者设置合理的默认值约束。</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ol>
<li>更新提示问题：设计一个每次使用系统首先要访问的API，该API会向移动端返回系统更新的相关信息，这样就可以提升用户更新App了。</li>
<li>版本升级问题：API版本升级时应该考虑对低版本的兼容，同时要让新版本和旧版本都能够被访问，可以在URL中包含版本信息或者在将版本号放在HTTP(S)协议头部，关于这个问题有很多的争论，有兴趣的可以看看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/972226/how-to-version-rest-uris">stack overflow</a>上面对这个问题的讨论。</li>
<li>图片尺寸问题：移动端对于一张图片可能需要不同的尺寸，可以在获取图片时传入尺寸参数并获取对应的资源；更好的做法是直接使用云存储或CDN（直接提供了图片缩放的功能），这样可以加速对资源的访问。</li>
</ol>
<h3 id="文档撰写"><a href="#文档撰写" class="headerlink" title="文档撰写"></a>文档撰写</h3><p>下面以设计评论接口为例，简单说明接口文档应该如何撰写。</p>
<p>首先，我们可以定义全局返回状态码。</p>
<table>
<thead>
<tr>
<th>返回码</th>
<th>返回信息</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>10000</td>
<td>获取评论成功</td>
<td></td>
</tr>
<tr>
<td>10001</td>
<td>创建评论成功</td>
<td></td>
</tr>
<tr>
<td>10002</td>
<td>无法创建评论</td>
<td>创建评论时因违反审核机制而无法创建</td>
</tr>
<tr>
<td>10003</td>
<td>评论已被删除</td>
<td>查看评论时评论因不和谐因素已被删除</td>
</tr>
<tr>
<td>10004</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<ol>
<li><p>获取文章评论。</p>
<p><strong>GET</strong> <code>/articles/&#123;article-id&#125;/comments/</code></p>
<p>开发者：王大锤</p>
<p>最后更新时间：2018年8月10日</p>
<p>标签：v 1.0</p>
<p>接口说明：获取指定文章的所有评论</p>
<p>使用帮助：默认返回20条数据，需要在请求头中设置身份标识（key）</p>
<p>请求参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必填</th>
<th>参数位置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>page</td>
<td>整数</td>
<td>否</td>
<td>查询参数</td>
<td>页码，默认值1</td>
</tr>
<tr>
<td>size</td>
<td>整数</td>
<td>否</td>
<td>查询参数</td>
<td>每次获取评论数量（10~100），默认值20</td>
</tr>
<tr>
<td>key</td>
<td>字符串</td>
<td>是</td>
<td>请求头</td>
<td>用户的身份标识</td>
</tr>
</tbody></table>
<p>响应信息：</p>
<pre><code class="JSON">&#123;
    &quot;code&quot;: 10000,
    &quot;message&quot;: &quot;获取评论成功&quot;,
    &quot;page&quot;: 1,
    &quot;size&quot;: 10,
    &quot;totalPage&quot;: 35,
    &quot;contents&quot;: [
        &#123;
            &quot;userId&quot;: 1700095,
            &quot;nickname&quot;: &quot;王大锤&quot;,
            &quot;pubDate&quot;: &quot;2018年7月31日&quot;,
            &quot;content&quot;: &quot;小编是不是有病呀&quot;,
            /* ... */
        &#125;,
        &#123;
            &quot;userId&quot;, 1995322,
            &quot;nickname&quot;: &quot;白元芳&quot;,
            &quot;pubDate&quot;: &quot;2018年8月2日&quot;,
            &quot;content&quot;: &quot;楼上说得好&quot;,
            /* ... */
        &#125;
    ]
    /* ... */
&#125;
</code></pre>
</li>
<li><p>新增文章评论。</p>
<p><strong>POST</strong> <code>/articles/&#123;article-id&#125;/comments</code></p>
<p>开发者：王大锤</p>
<p>最后更新时间：2018年8月10日</p>
<p>标签：v 1.0</p>
<p>接口说明：为指定的文章创建评论</p>
<p>使用帮助：暂无</p>
<p>请求参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必填</th>
<th>参数位置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>userId</td>
<td>字符串</td>
<td>是</td>
<td>消息体</td>
<td>用户ID</td>
</tr>
<tr>
<td>key</td>
<td>字符串</td>
<td>是</td>
<td>请求头</td>
<td>用户的令牌</td>
</tr>
<tr>
<td>content</td>
<td>字符串</td>
<td>是</td>
<td>消息体</td>
<td>评论的内容</td>
</tr>
</tbody></table>
<p>响应信息：</p>
<pre><code class="JSON">&#123;
    &quot;code&quot;: 10001,
    &quot;message&quot;: &quot;创建评论成功&quot;,
    &quot;comment&quot;: &#123;
        &quot;pubDate&quot;: &quot;2018年7月31日&quot;,
        &quot;content&quot;: &quot;小编是不是有病呀&quot;
        /* ... */
    &#125;
    /* ... */
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>提示</strong>：如果没有接口文档撰写经验，可以使用在线接口文档编辑平台<a target="_blank" rel="noopener" href="http://rap2.taobao.org/">RAP2</a>或<a target="_blank" rel="noopener" href="http://yapi.demo.qunar.com/">YAPI</a>来进行接口文档撰写。</p>
</blockquote>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/93.MySQL性能优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.027Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/93.MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则。</p>
<ol>
<li>让MySQL回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离；</li>
<li>查询数据时，尽量单表查询，减少跨库查询和多表关联；</li>
<li>杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。<ul>
<li>大事务：运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。</li>
<li>大 SQL：复杂的SQL意味着过多的表的关联，MySQL 数据库处理关联超过3张表以上的SQL时，占用资源多，性能低下。</li>
<li>大批量：多条SQL一次性执行完成，可以减少一条条执行SQL产生的额外开销，但必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。</li>
<li>大字段：blob、text类型的大字段要尽量少用，必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。</li>
</ul>
</li>
</ol>
<h3 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h3><ol>
<li>必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。</li>
<li>默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。</li>
<li>关闭区分大小写功能。设置参数<code>lower_case_table_names</code>的值为<code>1</code>，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样。</li>
<li>存储过程、触发器、视图、event等功能尽量在程序中实现，一方面是为了存储和计算分离，另一方面是因为这些功能非常不完整，调试、排错、监控都非常困难，相关数据字典也不完善，存在潜在的风险。一般在生产数据库中，禁止使用。</li>
<li>单个数据库实例表数量控制在2000个以内。</li>
</ol>
<h4 id="InnoDB表的注意事项"><a href="#InnoDB表的注意事项" class="headerlink" title="InnoDB表的注意事项"></a>InnoDB表的注意事项</h4><ol>
<li>主键列使用<code>unsigned</code>整数，可以使用<code>auto_increment</code>，但是要禁止手动更新主键。</li>
<li>每个列都必须添加<code>comment</code>注释。</li>
<li>在建表时必须显示指定<code>engine</code>。</li>
<li>表必备三字段：<code>xxx_id</code>、 <code>xxx_create</code>、 <code>xxx_modified</code>。其中<code>xxx_id</code>为主键，类型<code>unsigned</code>整数类型（例如：<code>int unsigned</code>）；<code>xxx_create</code>、<code>xxx_modified</code>的类型均为<code>datetime</code>类型，分别记录该条数据的创建时间、修改时间。</li>
<li>所有字段必须指定<code>not null</code>，为空值指定<code>default</code>值，因为MySQL难以优化<code>null</code>值，含<code>null</code>值的复合索引会失效，最终导致查询效率低。</li>
<li>单张表的字段数尽量空值在50个字段以内，如果字段过多可以考虑垂直拆分。</li>
<li>禁用<code>enum</code>和<code>set</code>类型，因为这样的类型兼容性不好且性能较差。</li>
<li>大文件不应该使用<code>blob</code>类型而是保存它们的路径，<code>blob</code>和<code>text</code>这样的类型会导致处理性能下降，全表扫描代价大大增加。</li>
<li>对货币等对精度敏感的数据，应该使用定点数（<code>decimal</code>）而不是浮点数（<code>float</code>）。</li>
<li>保存IP地址不要用<code>char(15)</code>，应该使用<code>int unsigned</code>，可以使用<code>inet_aton</code>和<code>inet_ntoa</code>函数实现整数和IP地址的转换。</li>
</ol>
<h3 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h3><p>在前面<a href="../Day36-40/36-38.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL.md">《关系型数据库MySQL》</a>一文中，我们已经讲到过索引的相关知识，这里我们做一个简单的回顾。</p>
<h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ol>
<li>创建索引的列并不一定是<code>select</code>操作中要查询的列，最适合做索引的列是出现在<code>where</code>子句中经常用作筛选条件或连表子句中作为表连接条件的列。</li>
<li>具有唯一性的列，索引效果好；重复值较多的列，索引效果差。</li>
<li>如果为字符串类型创建索引，最好指定一个前缀长度，创建短索引。短索引可以减少磁盘I/O而且在做比较时性能也更好，更重要的是MySQL底层的高速索引缓存能够缓存更多的键值。</li>
<li>创建一个包含N列的复合索引（多列索引）时，相当于是创建了N个索引，此时应该利用最左前缀进行匹配。</li>
<li>不要过度使用索引。索引并不是越多越好，索引需要占用额外的存储空间而且会影响写操作的性能（插入、删除、更新数据时索引也需要更新）。MySQL在生成执行计划时，要考虑各个索引的使用，这个也是需要耗费时间的。</li>
<li>要注意可能使索引失效的场景，例如：模糊查询使用了前置通配符、使用负向条件进行查询等。</li>
</ol>
<h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><p>过程，通常也称之为存储过程，它是事先编译好存储在数据库中的一组SQL的集合。调用存储过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能是有帮助的，这些我们在之前的<a href="../Day36-40/36-38.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93MySQL.md">《关系型数据库MySQL》</a>一文中已经提到过。</p>
<h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>MySQL支持做数据分区，通过分区可以存储更多的数据、优化查询，获得更大的吞吐量并快速删除过期的数据。关于这个知识点建议大家看看MySQL的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html">官方文档</a>。数据分区有以下几种类型：</p>
<ol>
<li><p>RANGE分区：基于连续区间范围，把数据分配到不同的分区。</p>
<pre><code class="SQL">CREATE TABLE tb_emp (
    eno INT NOT NULL,
    ename VARCHAR(20) NOT NULL,
    job VARCHAR(10) NOT NULL,
    hiredate DATE NOT NULL,
    dno INT NOT NULL
)
PARTITION BY RANGE( YEAR(hiredate) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</code></pre>
</li>
<li><p>LIST分区：基于枚举值的范围，把数据分配到不同的分区。</p>
</li>
<li><p>HASH分区 / KEY分区：基于分区个数，把数据分配到不同的分区。</p>
<pre><code class="SQL">CREATE TABLE tb_emp (
    eno INT NOT NULL,
    ename VARCHAR(20) NOT NULL,
    job VARCHAR(10) NOT NULL,
    hiredate DATE NOT NULL,
    dno INT NOT NULL
)
PARTITION BY HASH(dno)
PARTITIONS 4;
</code></pre>
</li>
</ol>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ol>
<li><p>定位低效率的SQL语句 - 慢查询日志。</p>
<ul>
<li><p>查看慢查询日志相关配置</p>
<pre><code class="SQL">mysql&gt; show variables like &#39;slow_query%&#39;;
+---------------------------+----------------------------------+
| Variable_name             | Value                            |
+---------------------------+----------------------------------+
| slow_query_log            | OFF                              |
| slow_query_log_file       | /mysql/data/localhost-slow.log   |
+---------------------------+----------------------------------+

mysql&gt; show variables like &#39;long_query_time&#39;;
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
</code></pre>
</li>
<li><p>创建慢查询日志文件并修改所有者。</p>
<pre><code class="Bash">touch /var/log/mysqld-slow.log
chown mysql /var/log/mysqld-slow.log
</code></pre>
</li>
<li><p>修改全局慢查询日志配置。</p>
<pre><code class="SQL">mysql&gt; set global slow_query_log_file=&#39;/var/log/mysqld-slow.log&#39;
mysql&gt; set global slow_query_log=&#39;ON&#39;; 
mysql&gt; set global long_query_time=1;
</code></pre>
</li>
<li><p>或者直接修改MySQL配置文件启用慢查询日志。</p>
<pre><code class="INI">[mysqld]
slow_query_log=ON
slow_query_log_file=/var/log/mysqld-slow.log
long_query_time=1
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：修改了配置文件需要重启MySQL，CentOS上对应的命令是<code>systemctl restart mysqld</code>。</p>
</blockquote>
</li>
<li><p>通过<code>explain</code>了解SQL的执行计划。例如：</p>
<pre><code class="SQL">explain select ename, job, sal from tb_emp where dno=20\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_emp
         type: ref
possible_keys: fk_emp_dno
          key: fk_emp_dno
      key_len: 5
          ref: const
         rows: 7
        Extra: NULL
1 row in set (0.00 sec)
</code></pre>
<ul>
<li><code>select_type</code>：查询类型（SIMPLE - 简单查询、PRIMARY - 主查询、UNION - 并集、SUBQUERY - 子查询）。</li>
<li><code>table</code>：输出结果集的表。</li>
<li><code>type</code>：访问类型（ALL - 全表查询性能最差、index、range、ref、eq_ref、const、NULL）。</li>
<li><code>possible_keys</code>：查询时可能用到的索引。</li>
<li><code>key</code>：实际使用的索引。</li>
<li><code>key_len</code>：索引字段的长度。</li>
<li><code>rows</code>：扫描的行数，行数越少肯定性能越好。</li>
<li><code>extra</code>：额外信息。</li>
</ul>
</li>
<li><p>通过<code>show profiles</code>和<code>show profile for query</code>分析SQL。</p>
<p>MySQL从5.0.37开始支持剖面系统来帮助用户了解SQL执行性能的细节，可以通过下面的方式来查看MySQL是否支持和开启了剖面系统。</p>
<pre><code class="SQL">select @@have_profiling;
select @@profiling;
</code></pre>
<p>如果没有开启剖面系统，可以通过下面的SQL来打开它。</p>
<pre><code class="SQL">set profiling=1;
</code></pre>
<p>接下来就可以通过剖面系统来了解SQL的执行性能，例如：</p>
<pre><code class="SQL">mysql&gt; select count(*) from tb_emp;
+----------+
| count(*) |
+----------+
|       14 |
+----------+
1 row in set (0.00 sec)

mysql&gt; show profiles;
+----------+------------+-----------------------------+
| Query_ID | Duration   | Query                       |
+----------+------------+-----------------------------+
|        1 | 0.00029600 | select count(*) from tb_emp |
+----------+------------+-----------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; show profile for query 1;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000076 |
| checking permissions | 0.000007 |
| Opening tables       | 0.000016 |
| init                 | 0.000013 |
| System lock          | 0.000007 |
| optimizing           | 0.000005 |
| statistics           | 0.000012 |
| preparing            | 0.000010 |
| executing            | 0.000003 |
| Sending data         | 0.000070 |
| end                  | 0.000012 |
| query end            | 0.000008 |
| closing tables       | 0.000012 |
| freeing items        | 0.000032 |
| cleaning up          | 0.000013 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)
</code></pre>
</li>
<li><p>优化CRUD操作。</p>
<ul>
<li><p>优化<code>insert</code>语句</p>
<ul>
<li>在<code>insert</code>语句后面跟上多组值进行插入在性能上优于分开<code>insert</code>。</li>
<li>如果有多个连接向同一个表插入数据，使用<code>insert delayed</code>可以获得更好的性能。</li>
<li>如果要从一个文本文件装载数据到表时，使用<code>load data infile</code>比<code>insert</code>性能好得多。</li>
</ul>
</li>
<li><p>优化<code>order by</code>语句</p>
<ul>
<li>如果<code>where</code>子句的条件和<code>order by</code>子句的条件相同，而且排序的顺序与索引的顺序相同，如果还同时满足排序字段都是升序或者降序，那么只靠索引就能完成排序。</li>
</ul>
</li>
<li><p>优化<code>group by</code>语句</p>
<ul>
<li>在使用<code>group by</code>子句分组时，如果希望避免排序带来的开销，可以用<code>order by null</code>禁用排序。</li>
</ul>
</li>
<li><p>优化嵌套查询</p>
<ul>
<li>MySQL从4.1开始支持嵌套查询（子查询），这使得可以将一个查询的结果当做另一个查询的一部分来使用。在某些情况下，子查询可以被更有效率的连接查询取代，因为在连接查询时MySQL不需要在内存中创建临时表来完成这个逻辑上需要多个步骤才能完成的查询。</li>
</ul>
</li>
<li><p>优化or条件</p>
<ul>
<li>如果条件之间是<code>or</code>关系，则只有在所有条件都用到索引的情况下索引才会生效。</li>
</ul>
</li>
<li><p>优化分页查询</p>
<ul>
<li><p>分页查询时，一个比较头疼的事情是如同<code>limit 1000, 20</code>，此时MySQL已经排序出前1020条记录但是仅仅返回第1001到1020条记录，前1000条实际都用不上，查询和排序的代价非常高。一种常见的优化思路是在索引上完成排序和分页的操作，然后根据返回的结果做表连接操作来得到最终的结果，这样可以避免出现全表查询，也避免了外部排序。</p>
<pre><code class="SQL">select * from tb_emp order by ename limit 10000, 20;
select * from tb_emp t1 inner join (select eno from tb_emp order by ename limit 10000, 20) t2 on t1.eno=t2.eno;
</code></pre>
<p>上面的代码中，第2行SQL是优于第1行SQL的，当然我们的前提是已经在<code>ename</code>字段上创建了索引。</p>
</li>
</ul>
</li>
<li><p>使用SQL提示</p>
<ul>
<li>USE INDEX：建议MySQL使用指定的索引。</li>
<li>IGNORE INDEX：建议MySQL忽略掉指定的索引。</li>
<li>FORCE INDEX：强制MySQL使用指定的索引。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h3><p>可以使用下面的命令来查看MySQL服务器配置参数的默认值。</p>
<pre><code class="SQL">show variables;
show variables like &#39;key_%&#39;;
show variables like &#39;%cache%&#39;;
show variables like &#39;innodb_buffer_pool_size&#39;;
</code></pre>
<p>通过下面的命令可以了解MySQL服务器运行状态值。</p>
<pre><code class="SQL">show status;
show status like &#39;com_%&#39;;
show status like &#39;innodb_%&#39;;
show status like &#39;connections&#39;;
show status like &#39;slow_queries&#39;;
</code></pre>
<ol>
<li>调整<code>max_connections</code>：MySQL最大连接数量，默认151。在Linux系统上，如果内存足够且不考虑用户等待响应时间这些问题，MySQL理论上可以支持到万级连接，但是通常情况下，这个值建议控制在1000以内。</li>
<li>调整<code>back_log</code>：TCP连接的积压请求队列大小，通常是max_connections的五分之一，最大不能超过900。</li>
<li>调整<code>table_open_cache</code>：这个值应该设置为max_connections的N倍，其中N代表每个连接在查询时打开的表的最大个数。</li>
<li>调整<code>innodb_lock_wait_timeout</code>：该参数可以控制InnoDB事务等待行锁的时间，默认值是50ms，对于反馈响应要求较高的应用，可以将这个值调小避免事务长时间挂起；对于后台任务，可以将这个值调大来避免发生大的回滚操作。</li>
<li>调整<code>innodb_buffer_pool_size</code>：InnoDB数据和索引的内存缓冲区大小，以字节为单位，这个值设置得越高，访问表数据需要进行的磁盘I/O操作就越少，如果可能甚至可以将该值设置为物理内存大小的80%。</li>
</ol>
<h3 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h3><ol>
<li><p>通过拆分提高表的访问效率。</p>
<ul>
<li>垂直拆分</li>
<li>水平拆分</li>
</ul>
</li>
<li><p>逆范式理论。数据表设计的规范程度称之为范式（Normal Form），要提升表的规范程度通常需要将大表拆分为更小的表，范式级别越高数据冗余越小，而且在插入、删除、更新数据时出问题的可能性会大幅度降低，但是节省了空间就意味着查询数据时可能花费更多的时间，原来的单表查询可能会变成连表查询。为此，项目实践中我们通常会进行逆范式操作，故意降低范式级别增加冗余来减少查询的时间开销。</p>
<ul>
<li>1NF：列不能再拆分</li>
<li>2NF：所有的属性都依赖于主键</li>
<li>3NF：所有的属性都直接依赖于主键（消除传递依赖）</li>
<li>BCNF：消除非平凡多值依赖</li>
</ul>
</li>
<li><p>使用中间表提高统计查询速度。</p>
<p>使用<code>insert into 中间表 select ... where ...</code>这样的语句先将需要的数据筛选出来放到中间表中，然后再对中间表进行统计，避免不必要的运算和处理。</p>
</li>
<li><p>主从复制和读写分离，具体内容请参考<a href="./98.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md">《项目部署上线和性能调优》</a>。</p>
</li>
<li><p>配置MySQL集群。</p>
</li>
</ol>
<blockquote>
<p><strong>说明</strong>：本章内容参考了网易出品的《深入浅出MySQL》一书，该书和《高性能MySQL》一样，都对MySQL进行了深入细致的讲解，虽然总体感觉后者更加高屋建瓴，但是前者也算得上是提升MySQL技能的佳作（作者的文字功底稍显粗糙，深度也不及后者），建议有兴趣的读者可以阅读这两本书。</p>
</blockquote>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/92.Docker容器技术详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.024Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/92.Docker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Docker容器技术详解"><a href="#Docker容器技术详解" class="headerlink" title="Docker容器技术详解"></a>Docker容器技术详解</h2><p>Docker是基于Go语言开发的开源应用容器引擎，遵从Apache Licence 2.0协议，可以让开发者打包应用以及应用的依赖包到一个可移植的容器中，然后发布到各种发行版本的Linux系统上。</p>
<h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台下都可以正常的运转，而且在不同的环境下我们安装的软件需要依赖的软件包也是不一样的。</p>
<p>那么问题来了，我们安装软件的时候可不可以把软件运行的环境一并安装？我们是不是可以把原始环境一模一样地复制过来呢？</p>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统，在macOS上运行Windows，而应用程序对此毫无感知。使用过虚拟机的人都知道，虚拟机用起来跟真实系统一模一样，而对于虚拟机的宿主系统来说，虚拟机就是一个普通文件，不需要了就删掉，对宿主系统或者其他的程序并没有影响。但是虚拟机通常会占用较多的系统资源，启动和关闭也非常的缓慢，总之用户体验并没有想象中的那么好。</p>
<p>Docker属于对Linux容器技术（LXC）的一种封装（利用了Linux的namespace和cgroup技术），它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。下图是虚拟机和容器的对比，左边是传统的虚拟机，右边是Docker。</p>
<p><img src="./res/docker_vs_vm.png"></p>
<p>目前，Docker主要用于几下几个方面：</p>
<ol>
<li>提供一次性的环境。</li>
<li>提供弹性的云服务（利用Docker很容易实现扩容和收缩）。</li>
<li>实践微服务架构（隔离真实环境在容器中运行多个服务）。</li>
</ol>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>下面以CentOS为例讲解如何安装Docker，使用<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a>、<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/install/">macOS</a>或<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/install/">Windows</a>的用户可以通过点击对应的链接了解这些平台下如何进行安装。</p>
<ol>
<li><p>确定操作系统内核版本（CentOS 7要求64位，内核版本3.10+；CentOS 6要求64位，内核版本2.6+）。</p>
<pre><code class="Bash">uname -r
</code></pre>
</li>
<li><p>更新系统底层的库文件（建议一定要执行，否则在使用Docker时可能会出现莫名其妙的问题）。</p>
<pre><code class="Bash">yum update
</code></pre>
</li>
<li><p>移除可能存在的旧的Docker版本。</p>
<pre><code class="Bash">yum list installed | grep docker
yum erase -y docker docker-common docker-engine
</code></pre>
</li>
<li><p>安装yum工具包和依赖项。</p>
<pre><code class="Bash">yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre>
</li>
<li><p>通过yum工具包添加yum源（安装Docker-ce的源）。</p>
<pre><code class="Bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
</li>
<li><p>在CentOS下使用yum安装Docker-ce并启动。</p>
<pre><code class="Bash">yum -y install docker-ce
systemctl start docker
</code></pre>
</li>
<li><p>查看Docker的信息和版本。</p>
<pre><code class="Shell">docker version
docker info
</code></pre>
</li>
</ol>
<p>接下来可以通过下载镜像和创建容器来看看Docker是否可以运转起来。可以使用下面的命令从Docker的镜像仓库下载名为hello-world的镜像文件。</p>
<pre><code class="Shell">docker pull hello-world
</code></pre>
<p>查看所有镜像文件。</p>
<pre><code class="Shell">docker images
</code></pre>
<pre><code>REPOSITORY               TAG        IMAGE ID            CREATED             SIZE
docker.io/hello-world    latest     fce289e99eb9        7 months ago        1.84 kB
</code></pre>
<p>通过镜像文件创建并运行容器。</p>
<pre><code class="Shell">docker container run --name mycontainer hello-world
</code></pre>
<blockquote>
<p>说明：其中<code>mycontainer</code>是我们给容器起的名字，跟在<code>--name</code>参数之后；<code>hello-world</code>就是我们刚才下载的镜像文件。</p>
</blockquote>
<pre><code>Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<p>如果要删除这个容器，可以使用下面的命令。</p>
<pre><code class="Shell">docker container rm mycontainer
</code></pre>
<p>在删除容器之后，我们还可以删除刚才下载的镜像文件。</p>
<pre><code class="Shell">docker rmi hello-world
</code></pre>
<blockquote>
<p>说明：如果要在Ubuntu（内核版本3.10+）下面安装和启动Docker，可以按照如下的步骤进行。</p>
<pre><code class="Shell">apt update
apt install docker-ce
service docker start
</code></pre>
<p>国内用户可以通过更换Ubuntu软件下载源来提升下载速度，具体请参照清华大学开源软件镜像站上的<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">《Ubuntu镜像使用帮助》</a>。</p>
</blockquote>
<p>安装Docker后，由于直接访问<a target="_blank" rel="noopener" href="https://hub.docker.com/">dockerhub</a>下载镜像会非常缓慢，建议将服务器更换为国内镜像，可以通过修改 <code>/etc/docker/daemon.json</code> 文件来做到。一般的云服务器会有自己专属的镜像，就不需要手动修改了。</p>
<pre><code class="JavaScript">&#123;
    &quot;registry-mirrors&quot;: [
        &quot;http://hub-mirror.c.163.com&quot;,
        &quot;https://registry.docker-cn.com&quot;
    ]
&#125;
</code></pre>
<h3 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h3><p>想要玩转Docker，最简单的办法就是马上用Docker创建一些自己学习和工作中需要用到的容器，下面我们带着大家一起来创建这些容器。</p>
<h4 id="运行Nginx"><a href="#运行Nginx" class="headerlink" title="运行Nginx"></a>运行Nginx</h4><p>Nginx是高性能的Web服务器，同时也是做反向代理服务器的上佳选择。使用Docker可以非常简单的创建一个运行Nginx的容器，命令如下所示。</p>
<pre><code class="Shell">docker container run -d -p 80:80 --rm --name mynginx nginx
</code></pre>
<blockquote>
<p>说明：上面的参数<code>-d</code>表示容器在后台运行（不产生输出到Shell）并显示容器的ID；<code>-p</code>是用来映射容器的端口到宿主机的端口，冒号前面是宿主机的端口，冒号后面是容器内部使用的端口；<code>--rm</code>表示容器停止后自动删除容器，例如执行命令<code>docker container stop mynginx</code>后，容器就不复存在了；<code>--name</code>后面的mynginx是自定义的容器名字；在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载是自动完成的，如果没有指定版本号，默认是最新版本（latest）。</p>
</blockquote>
<p>如果需要将自己的Web项目（页面）部署到Nginx上，可以使用容器拷贝命令将指定路径下所有的文件和文件夹拷贝到容器的指定目录中。</p>
<pre><code class="Shell">docker container cp /root/web/index.html mynginx:/usr/share/nginx/html
</code></pre>
<p>如果不愿意拷贝文件也可以在创建容器时通过数据卷操作<code>--volume</code>将指定的文件夹映射到容器的某个目录中，例如将Web项目的文件夹直接映射到<code>/usr/share/nginx/html</code>目录。我们先通过下面的命令让刚才创建的容器停止运行。</p>
<pre><code class="Shell">docker container stop mynginx
</code></pre>
<p>然后用下面的命令重新创建容器。</p>
<pre><code class="Shell">docker container run -d -p 80:80 --rm --name mynginx --volume /root/docker/nginx/html:/usr/share/nginx/html nginx
</code></pre>
<blockquote>
<p>说明：上面创建容器和拷贝文件的命令中，<code>container</code>是可以省略的，也就是说<code>docker container run</code>和<code>docker run</code>是一样的，而<code>docker container cp</code>和<code>docker cp</code>是一样的。此外，命令中的<code>--volume</code>也可以缩写为<code>-v</code>，就如同<code>-d</code>是<code>--detach</code>的缩写，<code>-p</code>是<code>--publish</code>的缩写。<code>$PWD</code>代表宿主系统当前文件夹，这些对于使用过Unix或者Linux系统的人来说，应该是很容易理解的。</p>
</blockquote>
<p>要查看运行中的容器，可以使用下面的命令。</p>
<pre><code class="Shell">docker ps
</code></pre>
<pre><code>CONTAINER ID    IMAGE    COMMAND                  CREATED            STATUS             PORTS                 NAMES
3c38d2476384    nginx    &quot;nginx -g &#39;daemon ...&quot;   4 seconds ago      Up 4 seconds       0.0.0.0:80-&gt;80/tcp    mynginx
</code></pre>
<p>要启动和停止容器，可以使用下面的命令。</p>
<pre><code class="Shell">docker start mynginx
docker stop mynginx
</code></pre>
<p>由于在创建容器时使用了<code>--rm</code>选项，容器在停止时会被移除，当我们使用下面的命令查看所有容器时，应该已经看不到刚才的<code>mynginx</code>容器了。</p>
<pre><code class="Shell">docker container ls -a
</code></pre>
<p>如果在创建容器时没有指定<code>--rm</code>选项，那么也可以使用下面的命令来删除容器。</p>
<pre><code class="Shell">docker rm mynginx
</code></pre>
<p>要删除正在运行中的容器，需要使用<code>-f</code>选项。</p>
<pre><code class="Shell">docker rm -f mynginx
</code></pre>
<h4 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a>运行MySQL</h4><p>我们再来尝试用Docker安装一台MySQL服务器，首先可以先检查一下有没有MySQL的镜像文件。</p>
<pre><code class="Shell">docker search mysql
</code></pre>
<pre><code>INDEX        NAME            DESCRIPTION        STARS        OFFICIAL        AUTOMATED
docker.io    docker.io/mysql MySQL is a ...     8486         [OK]
...
</code></pre>
<blockquote>
<p>说明：上面查询结果的列依次代表索引、镜像名、镜像描述、用户评价、是否官方镜像、自动构建。</p>
</blockquote>
<p>下载MySQL镜像并指定镜像的版本号。</p>
<pre><code class="Shell">docker pull mysql:5.7
</code></pre>
<p>如果需要查看已经下载的镜像文件，可以使用下面的命令。</p>
<pre><code class="Shell">docker images
</code></pre>
<pre><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/nginx     latest              e445ab08b2be        2 weeks ago         126 MB
docker.io/mysql     5.7                 f6509bac4980        3 weeks ago         373 MB
</code></pre>
<p>创建并运行MySQL容器。</p>
<pre><code class="Shell">docker run -d -p 3306:3306 --name mysql57 -v /root/docker/mysql/conf:/etc/mysql/mysql.conf.d -v /root/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
</code></pre>
<blockquote>
<p><strong>注意</strong>：上面创建容器时我们又一次使用了数据卷操作，那是因为通常容器是随时创建随时删除的，而数据库中的数据却是需要保留下来的。</p>
</blockquote>
<p>上面的两个数据卷操作一个是映射了MySQL配置文件所在的文件夹，一个是映射了MySQL数据所在的文件夹，这两个数据卷操作非常重要。我们可以将MySQL的配置文件放在<code>$PWD/mysql/conf</code>目录下，配置文件的具体内容如下所示：</p>
<pre><code class="INI">[mysqld]
pid-file=/var/run/mysqld/mysqld.pid
socket=/var/run/mysqld/mysqld.sock
datadir=/var/lib/mysql
log-error=/var/log/mysql/error.log
server-id=1
log-bin=/var/log/mysql/mysql-bin.log
expire_logs_days=30
max_binlog_size=256M
symbolic-links=0
</code></pre>
<p>如果安装了MySQL 8.x版本（目前的最新版本），在使用客户端工具连接服务器时可能会遇到<code>error 2059: Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded</code>的问题，这是因为MySQL 8.x默认使用了名为“caching_sha2_password”的机制对用户口令进行了更好的保护，但是如果客户端工具不支持新的认证方式，连接就会失败。解决这个问题有两种方式：一是升级客户端工具来支持MySQL 8.x的认证方式；二是进入容器，修改MySQL的用户口令认证方式。下面是具体的步骤，我们先用<code>docker exec</code>命令进入容器的交互式环境，假设运行MySQL 8.x的容器名字叫<code>mysql8x</code>。</p>
<pre><code class="Shell">docker exec -it mysql8x /bin/bash
</code></pre>
<p>进入容器的交互式Shell之后，可以首先利用MySQL的客户端工具连接MySQL服务器。</p>
<pre><code class="Shell">mysql -u root -p
Enter password:
Your MySQL connection id is 16
Server version: 8.0.12 MySQL Community Server - GPL
Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
mysql&gt;
</code></pre>
<p>接下来通过SQL来修改用户口令就可以了。</p>
<pre><code class="SQL">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123456&#39; password expire never;
</code></pre>
<p>当然，如果愿意你也可以查看一下用户表检查是否修改成功。</p>
<pre><code class="SQL">use mysql;
select user, host, plugin, authentication_string from user where user=&#39;root&#39;;
+------+-----------+-----------------------+-------------------------------------------+
| user | host      | plugin                | authentication_string                     |
+------+-----------+-----------------------+-------------------------------------------+
| root | %         | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
| root | localhost | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |
+------+-----------+-----------------------+-------------------------------------------+
2 rows in set (0.00 sec)
</code></pre>
<p>在完成上面的步骤后，现在即便不更新客户端工具也可以连接MySQL 8.x了。</p>
<h4 id="运行Redis"><a href="#运行Redis" class="headerlink" title="运行Redis"></a>运行Redis</h4><p>接下来我们试一试运行多个容器并让多个容器之间通过网络通信。我们创建4个Redis容器来实现一主三从的主从复制结构。</p>
<pre><code class="Shell">docker run -d -p 6379:6379 --name redis-master redis
docker run -d -p 6380:6379 --name redis-slave-1 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379
docker run -d -p 6381:6379 --name redis-slave-2 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379
docker run -d -p 6382:6379 --name redis-slave-3 --link redis-master:redis-master redis redis-server --replicaof redis-master 6379
</code></pre>
<p>上面的命令中，<code>--link</code>参数用于给容器创建网络别名，因为三台从机（slave）需要通过网络连接自己的主机（master）。虽然，我们可以通过<code>docker inspect --format &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;container-ID&gt;</code>命令来查看到容器的IP地址，但是由于容器的即装即用性，容器的IP地址有可能会发生变化，如果直接使用IP地址，在容器重启后就可能会因为IP地址的变化导致从机无法连接到主机。使用<code>--link</code>参数创建网络别名就是为了在启动Redis服务器时在<code>redis-server</code>后面的<code>--replicaof</code>参数后使用这个别名而不是IP地址。</p>
<p>接下来我们进入名为<code>redis-master</code>的容器，看看主从复制的配置是否成功。</p>
<pre><code class="Shell">docker exec -it redis-master /bin/bash
</code></pre>
<p>通过<code>redis-cli</code>启动命令行工具。</p>
<pre><code class="Shell">redis-cli
127.0.0.1:6379&gt; info replication
# Replication
role:master
connected_slaves:3
slave0:ip=172.17.0.4,port=6379,state=online,offset=1988,lag=0
slave1:ip=172.17.0.5,port=6379,state=online,offset=1988,lag=1
slave2:ip=172.17.0.6,port=6379,state=online,offset=1988,lag=1
master_replid:94703cfa03c3ddc7decc74ca5b8dd13cb8b113ea
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1988
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1988
</code></pre>
<h4 id="运行GitLab"><a href="#运行GitLab" class="headerlink" title="运行GitLab"></a>运行GitLab</h4><p>GitLab是由GitLab Inc.开发的Git仓库管理工具，具有wiki、问题跟踪、持续集成等一系列的功能，分为社区版和企业版。通过Docker提供的虚拟化容器，我们可以安装社区版的Docker。因为GitLab需要使用SSH协议进行安全连接，我们要暴露容器的22端口，所以可以先将宿主机SSH连接的22端口修改为其他端口（如：12345），然后再进行后续的操作。</p>
<pre><code class="Shell">vim /etc/ssh/sshd_config
</code></pre>
<p>将其中定义端口的那行代码去掉注释并将端口修改为12345。</p>
<pre><code>Port 12345
</code></pre>
<p>重新启动<code>sshd</code>服务。 </p>
<pre><code class="Shell">systemctl restart sshd
</code></pre>
<blockquote>
<p><strong>提示</strong>：修改端口后应该确保防火墙上也开启对应的端口，否则无法使用SSH连接到Linux服务器。</p>
</blockquote>
<p>创建需要用于数据卷映射操作的文件夹。</p>
<pre><code class="Shell">mkdir -p /root/gitlab/&#123;config,logs,data&#125;
</code></pre>
<p>基于<code>gitlab/gitlab-ce</code>镜像创建容器，并暴露80端口（HTTP连接）和22端口（SSH连接）。</p>
<pre><code class="Shell">docker run -d -p 80:80 -p 22:22 --name gitlab -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce
</code></pre>
<blockquote>
<p>说明：GitLab的启动比较缓慢，创建好容器后可能需要等待一段时间才能通过浏览器来进行访问。</p>
</blockquote>
<p>首次进入GitLab访问界面会提示我们修改管理员密码，设置好管理员密码后就可以在登录界面输入用户名<code>root</code>和刚才设置的密码登录到管理员控制台，在使用上还是非常简单和人性化的。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>通过上面的讲解，我们已经掌握了如何通过官方提供的镜像来创建容器。当然如果愿意，我们也可以用配置好的容器来生成镜像。简而言之，<strong>Docker镜像是由文件系统叠加而成的，系统的最底层是bootfs，相当于就是Linux内核的引导文件系统；接下来第二层是rootfs，这一层可以是一种或多种操作系统（如Debian或Ubuntu文件系统），Docker中的rootfs是只读状态的；Docker利用联合挂载技术将各层文件系统叠加到一起，最终的文件系统会包含有底层的文件和目录，这样的文件系统就是一个镜像</strong>。</p>
<p>之前我们讲过了如何查找、列出镜像和拉取（下载）镜像，接下来看看构建镜像的两种方式：</p>
<ol>
<li>使用<code>docker commit</code>命令。（不推荐）</li>
<li>使用<code>docker build</code>命令和Dockerfile文件。</li>
</ol>
<h4 id="使用commit命令构建镜像"><a href="#使用commit命令构建镜像" class="headerlink" title="使用commit命令构建镜像"></a>使用commit命令构建镜像</h4><p>为了演示如何构建镜像，我们先使用Ubuntu镜像来定制一个容器，命令如下所示。</p>
<pre><code class="Shell">docker run --name myubuntu -it ubuntu /bin/bash
</code></pre>
<p>在容器中执行下面的命令来安装Apache服务器并退出容器。</p>
<pre><code class="Shell">apt -y upgrade
apt -y install apache2
exit
</code></pre>
<p>我们将这个容器作为一个定制的Web服务器保存起来，当需要这样一台Web服务器的时候，就没有必要重新创建容器并安装Apache了。</p>
<p>首先我们通过下面的命令查看容器的ID。</p>
<pre><code class="Shell">docker container ls -a
</code></pre>
<pre><code>docker container ls -a
CONTAINER ID    IMAGE    COMMAND        CREATED        STATUS        PORTS    NAMES
014bdb321612    ubuntu   &quot;/bin/bash&quot;    5 minutes ago  Exited (0)             myubuntu
</code></pre>
<p>提交定制的容器。</p>
<pre><code class="Shell">docker commit 014bdb321612 jackfrued/mywebserver
</code></pre>
<p>查看镜像文件。</p>
<pre><code class="Shell">docker images
</code></pre>
<pre><code>REPOSITORY              TAG       IMAGE ID        CREATED             SIZE
jackfrued/mywebserver   latest    795b294d265a    14 seconds ago      189 MB
</code></pre>
<p>生成镜像文件以后，后面就可以利用刚才创建的镜像文件来创建新的容器。</p>
<h4 id="使用Dockerfile构建镜像"><a href="#使用Dockerfile构建镜像" class="headerlink" title="使用Dockerfile构建镜像"></a>使用Dockerfile构建镜像</h4><p>Dockerfile使用DSL（Domain Specific Language）来构建一个Docker镜像，只要编辑好了Dockerfile文件，就可以使用<code>docker build</code>命令来构建一个新的镜像。</p>
<p>我们先创建一个名为myapp的文件夹来保存项目代码和Dockerfile的文件，如下所示：</p>
<pre><code class="Shell">[ECS-root temp]# tree myapp
myapp
├── api
│   ├── app.py
│   ├── requirements.txt
│   └── start.sh
└── Dockerfile
</code></pre>
<p>其中api是Flask项目的文件夹，其中包括了项目代码、依赖项以及启动脚本等文件，具体内容如下所示：</p>
<p><code>app.py</code>文件：</p>
<pre><code class="Python">from flask import Flask
from flask_restful import Resource, Api
from flask_cors import CORS

app = Flask(__name__)
CORS(app, resources=&#123;r&#39;/api/*&#39;: &#123;&#39;origins&#39;: &#39;*&#39;&#125;&#125;)
api = Api(app)


class Product(Resource):

    def get(self):
        products = [&#39;Ice Cream&#39;, &#39;Chocolate&#39;, &#39;Coca Cola&#39;, &#39;Hamburger&#39;]
        return &#123;&#39;products&#39;: products&#125;


api.add_resource(Product, &#39;/api/products&#39;)
</code></pre>
<p><code>requirements.txt</code>文件：</p>
<pre><code class="INI">flask
flask-restful
flask-cors
gunicorn
</code></pre>
<p><code>start.sh</code>文件：</p>
<pre><code class="Shell">#!/bin/bash
exec gunicorn -w 4 -b 0.0.0.0:8000 app:app
</code></pre>
<blockquote>
<p><strong>提示</strong>：需要给start.sh文件以执行权限，可以使用<code>chmod 755 start.sh</code>命令来做到。</p>
</blockquote>
<p>Dockerfile文件：</p>
<pre><code class="Dockerfile"># 指定基础镜像
FROM python:3.7
# 指定镜像的维护者
MAINTAINER jackfrued &quot;jackfrued@126.com&quot;
# 将指定文件添加到容器中指定的位置
ADD api/* /root/api/
# 设置工作目录
WORKDIR /root/api
# 执行命令(安装Flask项目的依赖项)
RUN pip install -r requirements.txt -i https://pypi.doubanio.com/simple/
# 容器启动时要执行的命令
ENTRYPOINT [&quot;./start.sh&quot;]
# 暴露端口
EXPOSE 8000
</code></pre>
<p>我们来解释一下上面的Dockerfile文件。Dockerfile文件通过特殊的指令来指定基础镜像（FROM指令）、创建容器后需要指定的命令（RUN指令）以及需要暴露的端口（EXPOSE）等信息。我们稍后会专门为大家介绍这些Dockfile中的指令。</p>
<p>接下来我们可以使用<code>docker build</code>命令来创建镜像，如下所示。</p>
<pre><code class="Shell">docker build -t &quot;jackfrued/myapp&quot; .
</code></pre>
<blockquote>
<p>提示：上面的命令最后面的<code>.</code> 千万不要漏掉了哦，它表示从当前路径下寻找Dockerfile。</p>
</blockquote>
<p>通过下面的命令可以查看创建好的镜像。</p>
<pre><code class="Shell">docker images
</code></pre>
<pre><code>REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
jackfrued/myapp              latest              6d6f026a7896        5 seconds ago       930 MB
</code></pre>
<p>如果想知道镜像文件是如何创建出来的，可以使用下面的命令。</p>
<pre><code class="Shell">docker history jackfrued/myapp
</code></pre>
<pre><code>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
6d6f026a7896        31 seconds ago      /bin/sh -c #(nop)  EXPOSE 8000/tcp              0 B                 
3f7739173a79        31 seconds ago      /bin/sh -c #(nop)  ENTRYPOINT [&quot;./start.sh&quot;]    0 B                 
321e6bf09bf1        32 seconds ago      /bin/sh -c pip install -r requirements.txt...   13 MB               
2f9bf2c89ac7        37 seconds ago      /bin/sh -c #(nop) WORKDIR /root/api             0 B                 
86119afbe1f8        37 seconds ago      /bin/sh -c #(nop) ADD multi:4b76f9c9dfaee8...   870 B               
08d465e90d4d        3 hours ago         /bin/sh -c #(nop)  MAINTAINER jackfrued &quot;j...   0 B                 
fbf9f709ca9f        12 days ago         /bin/sh -c #(nop)  CMD [&quot;python3&quot;]              0 B 
</code></pre>
<p>使用该镜像来创建容器运行Web服务器。</p>
<pre><code class="Shell">docker run -d -p 8000:8000 --name myapp jackfrued/myapp
</code></pre>
<p>如果希望将上面创建的镜像文件放到dockerhub仓库中，可以按照如下所示的步骤进行操作。</p>
<p>通过下面的命令登录到dockerhub。</p>
<pre><code class="Shell">docker login
</code></pre>
<p>输入用户名和口令进行登录。</p>
<pre><code>Login with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.
Username: jackfrued
Password: 
Login Succeeded
</code></pre>
<p>通过下面的命令将镜像推到仓库中。</p>
<pre><code class="Shell">docker push jackfrued/webserver
</code></pre>
<p><img src="./res/dockerhub-repo.png"></p>
<h4 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h4><p>想了解Dockerfile的指令可以查看官方提供的<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">参考手册</a>，下面我们为大家介绍一些常用的指令。</p>
<ol>
<li><p><strong>FROM</strong>：设置基础镜像，必须是Dockerfile中的第一条指令。</p>
<pre><code class="Dockerfile">FROM &lt;镜像名&gt; [AS &lt;别名&gt;]
</code></pre>
<p>或</p>
<pre><code class="Dockerfile">FROM &lt;镜像名&gt;[:&lt;标签&gt;] [AS &lt;别名&gt;]
</code></pre>
</li>
<li><p><strong>RUN</strong>：指定构建镜像时要执行的命令。</p>
<pre><code class="Dockerfile">RUN &lt;命令&gt; [参数1], [参数2], ... 
</code></pre>
<p>或</p>
<pre><code class="Dockerfile">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...]
</code></pre>
</li>
<li><p><strong>CMD</strong>：指定构建镜像后要执行的命令。</p>
<pre><code class="Dockerfile">CMD &lt;命令&gt; [参数1], [参数2], ...
</code></pre>
<p>或</p>
<pre><code class="Dockerfile">CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...]
</code></pre>
<blockquote>
<p>说明：Docker不同于虚拟机，容器本身就是一个进程，容器中的应用应该位于前台运行。CMD命令相当于就是用来指定容器主进程（创建容器后要在前台执行的程序）的，如果主进程结束了，容器也就停止运行了。所以在容器中启动Nginx不能使用<code>service nginx start</code>或是<code>systemctl start nginx</code>而是要通过<code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code>让它在前台运行。</p>
</blockquote>
</li>
<li><p><strong>ENTRYPOINT</strong>：和CMD类似，也可以执行命令，但<code>docker run</code>命令行中指定的任何参数都会被当做参数再次传给ENTRYPOINT指令中的命令，这就使得我们可以构建一个镜像，它既可以运行一个默认的命令，也支持通过<code>docker run</code>命令行为该命令指定可覆盖的参数选项。</p>
<pre><code class="Dockerfile">ENTRYPOINT &lt;命令&gt; [参数1], [参数2], ...
</code></pre>
<p>或</p>
<pre><code class="Dockerfile">ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...]
</code></pre>
</li>
<li><p><strong>WORKDIR</strong>：在通过镜像创建新容器时，在容器内部创建一个工作目录，ENTRYPOINT和CMD指定的程序会在这个目录下执行。在使用<code>docker run</code>命令时可以通过<code>-w</code>参数来覆盖由WORKDIR指定的工作目录。例如：</p>
<pre><code class="Dockerfile">WORKDIR /opt/webapp
</code></pre>
<pre><code class="Shell">docker run -w /usr/share/webapp ...
</code></pre>
</li>
<li><p><strong>ENV</strong>：在创建镜像时设置环境变量。在使用<code>docker run</code>命令时，可以通过<code>-e</code>参数来修改环境变量的设置。例如：</p>
<pre><code class="Dockerfile">ENV DEFAULT_PORT=8080
</code></pre>
<pre><code class="Shell">docker run -e &quot;DEFAULT_PORT=8000&quot; ...
</code></pre>
</li>
<li><p><strong>USER</strong>：指定镜像会以什么用户身份去运行。例如：</p>
<pre><code class="Dockerfile">USER nginx
</code></pre>
</li>
<li><p><strong>VOLUME</strong>：在创建容器时添加一个数据卷的挂载点。通过数据卷操作可以实现容器间数据的共享和重用，对卷所作的修改可以马上生效而不需要重新启动容器，我们之前创建容器时使用<code>--volume</code>参数就是为了实现数据卷的映射操作。</p>
<pre><code class="Dockerfile">VOLUME [&quot;/路径1&quot;, &quot;/路径2/子路径2.1/&quot;, ...]
</code></pre>
</li>
<li><p><strong>ADD</strong>：将构建目录下的文件和文件夹复制到镜像中，如果是压缩文件和归档文件，ADD命令会对这些文件进行解压缩解归档的操作。</p>
<pre><code class="Dockerfile">ADD [--chown=&lt;用户&gt;:&lt;用户组&gt;] &lt;源文件&gt; &lt;目标文件&gt;
</code></pre>
</li>
<li><p><strong>COPY</strong>：非常类似于ADD，但不会主动对文件进行提取操作。</p>
</li>
<li><p><strong>LABEL</strong>：为Docker镜像添加一些元数据，在使用<code>docker inspect</code>命令时会看到这些元数据。</p>
<pre><code class="Dockerfile">LABEL version=&quot;1.0.0&quot; location=&quot;Chengdu&quot;
</code></pre>
</li>
<li><p><strong>ONBUILD</strong>：为镜像添加触发器，当一个镜像被用作其他镜像的基础镜像，触发器将会被执行。例如：</p>
<pre><code class="Dockerfile">ONBUILD ADD . /app/src
ONBUILD RUN cd /app/src &amp;&amp; make
</code></pre>
</li>
</ol>
<h3 id="多容器管理"><a href="#多容器管理" class="headerlink" title="多容器管理"></a>多容器管理</h3><p>我们的项目可能会使用了多个容器，容器多了之后管理容器的工作就会变得麻烦。如果要对多个容器进行自动配置使得容器可以相互协作甚至实现复杂的调度，这就需要进行容器编排。Docker原生对容器编排的支持非常弱，但是可以通过社区提供的工具来实现容器编排。</p>
<h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h4><p>可以通过安装Docker Compose工具来实现基于YAML文件的容器编排，YAML文件会定义一系列的容器以及容器运行时的属性，Docker Compose会根据这些配置来管理容器。</p>
<ol>
<li><p>安装Docker Compose。</p>
<pre><code class="Shell">curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>
<blockquote>
<p>说明：如果没有curl工具，在CentOS下可以先通过包管理工具yum安装curl再执行上面的命令。</p>
</blockquote>
<p>当然我们也可以使用Python的包管理工具pip来安装Docker Compose，命令如下所示。</p>
<pre><code class="Shell">pip3 install -U docker-compose
</code></pre>
</li>
<li><p>使用Docker Compose。</p>
<p>我们在刚才的Flask项目中引入缓存，然后再利用Flask提供的数据接口为前端页面提供数据，使用Vue.js进行页面渲染并将静态页面部署在Nginx服务器上。项目文件夹结构如下所示：</p>
<pre><code class="Shell">[ECS-root ~]# tree temp
temp
├── docker-compose.yml
├── html
│   └── index.html
└── myapp
    ├── api
    │   ├── app.py
    │   ├── requirements.txt
    │   └── start.sh
    └── Dockerfile
</code></pre>
<p>修改后的app.py文件代码如下所示：</p>
<pre><code class="Python">from pickle import dumps, loads

from flask import Flask
from flask_restful import Resource, Api
from flask_cors import CORS
from redis import Redis

app = Flask(__name__)
CORS(app, resources=&#123;r&#39;/api/*&#39;: &#123;&#39;origins&#39;: &#39;*&#39;&#125;&#125;)
api = Api(app)
redis = Redis(host=&#39;redis-master&#39;, port=6379)


class Product(Resource):

    def get(self):
        data = redis.get(&#39;products&#39;)
        if data:
            products = loads(data)
        else:
            products = [&#39;Ice Cream&#39;, &#39;Chocolate&#39;, &#39;Coca Cola&#39;, &#39;Hamburger&#39;]
            redis.set(&#39;products&#39;, dumps(products))
        return &#123;&#39;products&#39;: products&#125;


api.add_resource(Product, &#39;/api/products&#39;)
</code></pre>
<p>html文件夹用来保存静态页面，稍后我们会通一个运行Nginx的容器来向浏览器提供静态页面。index.html文件的内容如下所示：</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;产品列表&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;product in products&quot;&gt;&#123;&#123; product &#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        new Vue(&#123;
            el: &#39;#app&#39;, 
            data: &#123;
                products: []
            &#125;,
            created() &#123;
                fetch(&#39;http://1.2.3.4:8000/api/products&#39;)
                    .then(resp =&gt; resp.json())
                    .then(json =&gt; &#123;this.products = json.products&#125;)
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接下来，我们要通过docker-compose.yml文件来创建三个容器并指明容器之间的依赖关系。</p>
<pre><code class="YAML">version: &#39;3&#39;
services:
  api-server:
    build: ./myapp
    ports:
      - &#39;8000:8000&#39;
    links:
      - redis-master
  web-server:
    image: nginx
    ports:
      - &#39;80:80&#39;
    volumes:
      - ./html:/usr/share/nginx/html
  redis-master:
    image: redis
    expose:
      - &#39;6379&#39;
</code></pre>
<p>有了这个YAML文件，我们就可以使用<code>docker-compose</code>命令来创建容器运行项目，其命令如下所示：</p>
<pre><code class="Shell">[ECS-root temp]# docker-compose up
Creating network &quot;temp_default&quot; with the default driver
Creating temp_web-server_1   ... done
Creating temp_redis-master_1 ... done
Creating temp_api-server_1   ... done
Attaching to temp_redis-master_1, temp_web-server_1, temp_api-server_1
redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # Redis version=5.0.6, bits=64, commit=00000000, modified=0, pid=1, just started
redis-master_1  | 1:C 05 Dec 2019 11:57:26.828 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
redis-master_1  | 1:M 05 Dec 2019 11:57:26.830 * Running mode=standalone, port=6379.
redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # Server initialized
redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory = 1&#39; to /etc/sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory=1&#39; for this to take effect.
redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
redis-master_1  | 1:M 05 Dec 2019 11:57:26.831 * Ready to accept connections
api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Starting gunicorn 20.0.4
api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Listening at: http://0.0.0.0:8000 (1)
api-server_1    | [2019-12-05 11:57:27 +0000] [1] [INFO] Using worker: sync
api-server_1    | [2019-12-05 11:57:27 +0000] [8] [INFO] Booting worker with pid: 8
api-server_1    | [2019-12-05 11:57:27 +0000] [9] [INFO] Booting worker with pid: 9
api-server_1    | [2019-12-05 11:57:27 +0000] [10] [INFO] Booting worker with pid: 10
api-server_1    | [2019-12-05 11:57:27 +0000] [11] [INFO] Booting worker with pid: 11
</code></pre>
<p> 要停止容器的运行，可以使用下面的命令。</p>
<pre><code class="Shell">docker-compose down
</code></pre>
</li>
</ol>
<h4 id="Kubernetes（K8S）"><a href="#Kubernetes（K8S）" class="headerlink" title="Kubernetes（K8S）"></a>Kubernetes（K8S）</h4><p>实际的生产环境中常常需要部署和管理多个协同工作的容器，docker compose解决了多容器创建和管理的问题，但是实际项目中，我们还需要Kubernetes（以下都简称为K8S）来提供一个跨主机集群的容器调度平台。K8S可以进行自动化容器的部署、扩展和操作，从而提供以容器为中心的基础架构。该项目是谷歌在2014年启动的项目，建立在谷歌公司十余年运维经验的基础之上，而且谷歌自己的应用也是运行在容器上的。</p>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/91.团队项目开发的问题和解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.022Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/91.%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="团队项目开发的问题和解决方案"><a href="#团队项目开发的问题和解决方案" class="headerlink" title="团队项目开发的问题和解决方案"></a>团队项目开发的问题和解决方案</h2><p>个人开发和团队开发这两个词相信对大家来说并不陌生。所谓个人开发就是一个人把控产品的所有内容；而团队开发则是由多个人组团并完成产品的开发。要实施团队开发以下几点是不可或缺的：</p>
<ol>
<li>对开发过程中的各种事件（例如：谁到什么时间完成了什么事情）进行管理和共享。</li>
<li>在团队内部共享各类工作成果以及新的知识技巧等。</li>
<li>管理工作成果的变更，既要防止成果被破坏，又要保证各个成员利用现有成果并行作业。</li>
<li>证明团队开发出的软件在任何时候都是可以正常运行的。</li>
<li>使用自动化的工作流程，让团队成员能够正确的实施开发、测试和部署。</li>
</ol>
<h3 id="团队项目开发常见问题"><a href="#团队项目开发常见问题" class="headerlink" title="团队项目开发常见问题"></a>团队项目开发常见问题</h3><p>团队开发相较于个人开发，容易遇到以下几个方面的问题。</p>
<h4 id="问题1：传统的沟通方式无法确定处理的优先级"><a href="#问题1：传统的沟通方式无法确定处理的优先级" class="headerlink" title="问题1：传统的沟通方式无法确定处理的优先级"></a>问题1：传统的沟通方式无法确定处理的优先级</h4><p>例如：使用邮件进行沟通可能出现邮件数量太多导致重要的邮件被埋没，无法管理状态，不知道哪些问题已经解决，哪些问题尚未处理，如果用全文检索邮件的方式来查询相关问题效率过于低下。</p>
<p>解决方案：使用缺陷管理工具。</p>
<h4 id="问题2：没有能够用于验证的环境"><a href="#问题2：没有能够用于验证的环境" class="headerlink" title="问题2：没有能够用于验证的环境"></a>问题2：没有能够用于验证的环境</h4><p>例如：收到项目正式环境中发生的故障报告后，需要还原正式环境需要花费很长的时间。</p>
<p>解决方法：实施持续交付。</p>
<h4 id="问题3：用别名目录管理项目分支"><a href="#问题3：用别名目录管理项目分支" class="headerlink" title="问题3：用别名目录管理项目分支"></a>问题3：用别名目录管理项目分支</h4><p>解决方法：实施版本控制。</p>
<h4 id="问题4：重新制作数据库非常困难"><a href="#问题4：重新制作数据库非常困难" class="headerlink" title="问题4：重新制作数据库非常困难"></a>问题4：重新制作数据库非常困难</h4><p>例如：正式环境和开发环境中数据库表结构不一致或者某个表列的顺序不一致。</p>
<p>解决方法：实施版本控制。</p>
<h4 id="问题5：不运行系统就无法察觉问题"><a href="#问题5：不运行系统就无法察觉问题" class="headerlink" title="问题5：不运行系统就无法察觉问题"></a>问题5：不运行系统就无法察觉问题</h4><p>例如：解决一个bug可能引入其他的bug或者造成系统退化，不正确的使用版本系统覆盖了其他人的修改，修改的内容相互发生了干扰，如果问题不能尽早发现，那么等过去几个月后再想追溯问题就非常麻烦了。</p>
<p>解决方法：实施持续集成，将团队成员的工作成果经常、持续的进行构建和测试。</p>
<h4 id="问题6：覆盖了其他成员修正的代码"><a href="#问题6：覆盖了其他成员修正的代码" class="headerlink" title="问题6：覆盖了其他成员修正的代码"></a>问题6：覆盖了其他成员修正的代码</h4><p>解决方法：实施版本控制。</p>
<h4 id="问题7：无法实施代码重构"><a href="#问题7：无法实施代码重构" class="headerlink" title="问题7：无法实施代码重构"></a>问题7：无法实施代码重构</h4><p>例如：在实施代码重构（在不影响代码产生的结果的前提下对代码内部的构造进行调整）时可能引发退化。</p>
<p>解决方法：大量的可重用的测试并实施持续集成。</p>
<h4 id="问题8：不知道bug的修正日期无法追踪退化"><a href="#问题8：不知道bug的修正日期无法追踪退化" class="headerlink" title="问题8：不知道bug的修正日期无法追踪退化"></a>问题8：不知道bug的修正日期无法追踪退化</h4><p>解决方法：版本控制系统、缺陷管理系统和持续集成之间需要交互，最好能够和自动化部署工具集成到一起来使用。</p>
<h4 id="问题9：发布过程太复杂"><a href="#问题9：发布过程太复杂" class="headerlink" title="问题9：发布过程太复杂"></a>问题9：发布过程太复杂</h4><p>解决方法：实施持续交付。</p>
<p>基于对上述问题的阐述和分析，我们基本上可以得到以下的结论，在团队开发中版本控制、缺陷管理和持续集成都是非常重要且不可或缺的。</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>针对上面提到的一系列问题，我们可以得出一个简单的结论，版本控制是实施团队开发的首要前提，必须通过版本控制对产品研发过程中产生的各种信息进行管理，这些内容包括：</p>
<ol>
<li>代码。</li>
<li>需求和设计的相关文档。</li>
<li>数据库模式和初始数据。</li>
<li>配置文件。</li>
<li>库的依赖关系定义。</li>
</ol>
<h4 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h4><p><img src="./res/git-logo.png"></p>
<p>Git是诞生于2005年的一个开源分布式版本控制系统，最初是Linus Torvalds（Linux之父） 为了帮助管理Linux内核开发而开发的一个版本控制软件。Git与常用的版本控制工具Subversion等不同，它采用了分布式版本控制的方式，在没有中央服务器支持的环境下也能够实施版本控制。</p>
<p>对于有使用Subversion（以下简称为SVN）经验的人来说，Git和SVN的共同点是摒弃了传统的基于锁定模式的版本控制（早期的CVS和VSS使用了锁定模式，当一个开发者编辑一个文件时会锁定该文件，其他开发者在此期间无法编辑该文件），采用了更有效率的基于合并模式的版本控制，而二者的区别在于：</p>
<ol>
<li>Git是分布式的，SVN是集中式的，SVN需要中央服务器的支持才能工作。</li>
<li>Git把内容按元数据方式存储，而SVN是按文件，即把文件的元信息隐藏在一个.svn文件夹里。</li>
<li>Git分支和SVN的分支不同，SVN对分支的处理是相当“狗血”的。</li>
<li>Git没有一个全局版本号，但是可以自己维护一个版本标签。</li>
<li>Git的内容完整性要优于SVN，Git的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。  </li>
</ol>
<p>总而言之，<strong>Git真的非常棒！！！</strong></p>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>可以在<a target="_blank" rel="noopener" href="http://git-scm.com/">Git官方网站</a>找到适合自己系统的Git下载链接并进行安装，macOS和Windows平台下安装Git都非常简单，Linux下如果要安装官方最新的版本，建议通过官方提供的Git源代码进行构建安装，步骤如下所示（以CentOS为例）。</p>
<p>下载Git源代码压缩文件。</p>
<pre><code class="Shell">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.23.0.tar.xz
</code></pre>
<p>解压缩和解归档。</p>
<pre><code class="Shell">xz -d git-2.23.0.tar.xz
tar -xvf git-2.23.0.tar
</code></pre>
<p>安装底层依赖库。</p>
<pre><code class="Shell">yum -y install libcurl-devel
</code></pre>
<blockquote>
<p>说明：没有这个依赖库，git的网络功能将无法执行。</p>
</blockquote>
<p>安装前的配置。</p>
<pre><code class="Shell">cd git-2.23.0
./configure --prefix=/usr/local
</code></pre>
<p>构建和安装。</p>
<pre><code class="Shell">make &amp;&amp; make install
</code></pre>
<p>安装成功后可以在终端中键入下面的命令检查自己的Git版本。</p>
<pre><code class="Shell">git --version
</code></pre>
<p>如果之前完全没有接触过Git，可以先阅读<a target="_blank" rel="noopener" href="http://www.bootcss.com/p/git-guide/">《git - 简易指南》</a>来对Git有一个大致的了解。</p>
<h4 id="Git本地操作"><a href="#Git本地操作" class="headerlink" title="Git本地操作"></a>Git本地操作</h4><p>可以使用下面的命令将一个文件夹变成Git仓库。</p>
<pre><code class="Shell">git init 
</code></pre>
<p>当你完成了上述操作后，本地目录就变成了下面的样子，下图左边是你的工作区（正在操作的工作目录），而右边是你的本地仓库，中间是工作区和本地仓库之间的暂存区（也称为缓存区）。</p>
<p><img src="./res/git_repository.png"></p>
<blockquote>
<p><strong>提示</strong>：用<code>ls -la</code>查看所有文件会发现在执行完上面的命令后，文件夹下多了一个名为<code>.git</code>的隐藏文件夹，这个就是本地的Git版本仓库。</p>
</blockquote>
<p>通过<code>git add</code>可以将指定的文件或所有文件添加到暂存区。</p>
<pre><code class="Shell">git add &lt;file&gt;
git add .
</code></pre>
<p>这个时候使用下面的命令可以查看工作区、暂存区和本地仓库的状态。</p>
<pre><code class="Shell">git status
</code></pre>
<blockquote>
<p><strong>提示</strong>：如果不希望将文件添加到暂存区，可以按照提示，使用<code>git rm --cached &lt;file&gt;</code>命令将文件从暂存区放回到工作区。</p>
</blockquote>
<p>如果这个时候对工作区的文件又进行了修改使得工作区和暂存区的内容并不相同了，再次执行<code>git status</code>可以看到哪个或哪些文件被修改了，如果希望用暂存区的内容恢复工作区，可以使用下面的命令。</p>
<pre><code class="Shell">git restore &lt;file&gt;
git restore .
</code></pre>
<blockquote>
<p><strong>注意</strong>：上面的命令目前仍然处于试验性阶段，在Git较早的版本中对应的命令是<code>git checkout -- &lt;file&gt;</code>。由于<code>git checkout</code>这个命令还可以用于切换分支，容易引起混淆，所以Git最新版本中将这个命令的两项功能分别赋予两个新的命令，一个就是上面的<code>git restore</code>，另一个是<code>git switch</code>。</p>
</blockquote>
<p>如果第一次使用Git，需要配置用户名和邮箱，然后才能将代码提交到仓库。</p>
<pre><code class="Shell">git config --global user.name &quot;jackfrued&quot;
git config --global user.email &quot;jackfrued@126.com&quot;
</code></pre>
<blockquote>
<p><strong>提示</strong>：可以用<code>git config --list</code>来查看Git的配置信息。</p>
</blockquote>
<p>通过下面的命令可以将暂存区的内容纳入本地仓库，</p>
<pre><code class="Shell">git commit -m &#39;本次提交的说明&#39;
</code></pre>
<p>可以通过<code>git log</code>查看每次提交对应的日志。</p>
<pre><code class="Shell">git log
git log --graph --oneline --abbrev-commit
</code></pre>
<h4 id="Git服务器概述"><a href="#Git服务器概述" class="headerlink" title="Git服务器概述"></a>Git服务器概述</h4><p>Git不像SVN那样一定需要中央服务器才能工作，上面我们演示的版本控制操作都是在本地执行的，但是对于企业开发多人协作这样的场景还是需要中央服务器的支持。通常，企业可以选择使用代码托管平台（如<a target="_blank" rel="noopener" href="https://github.com/">GitHub</a>）或自己搭建Git私服的方式来建立中央服务器（版本仓库），当然大多数的企业更倾向于后者。Github创办于2008年4月，目前是全世界最大的代码托管平台，支持企业用户（可以创建私有仓库，私有仓库内容不对外界公开）和普通用户（受限的使用私有仓库，不受限的使用公开仓库，公开仓库内容对他人可见）。Github上面代码库惊人的增长速度证明了它是非常成功的，在2018年6月被微软以75亿美元的天价收购。</p>
<p>国内也有不少类似Github的代码托管平台，最有名的当属<a target="_blank" rel="noopener" href="https://gitee.com/">码云</a>和<a target="_blank" rel="noopener" href="https://coding.net/">CODING</a>，目前码云和CODING对注册用户都提供了受限的使用私有仓库的功能，支持<strong>Pull Request</strong>（一种对话机制，可以在提交你的工作成果时让相关人员或团队注意到这件事情），同时还提供了对<strong>缺陷管理</strong>、<strong>Webhook</strong>等功能支持，这些使得版本控制系统还具备了缺陷管理和持续集成的能力。当然，很多公司都不愿意将自己的商业代码托管于别人的平台，这样的公司可以用<a target="_blank" rel="noopener" href="https://about.gitlab.com/">Gitlab</a>来搭建公司内部的Git私服，具体的做法在下一章为大家介绍。</p>
<p><img src="./res/gitlab-about.png"></p>
<p>这里我们直接以码云为例来说明使用Git服务器的一些注意事项。首先需要在码云上注册账号，当然也可以使用第三方登录（github账号、微信账号、新浪微博账号、CSDN账号等），登录成功后就可以创建项目，创建项目几乎是“傻瓜式”的，无需赘述，我们只对几个地方加以说明。</p>
<ol>
<li><p>创建项目时不建议勾选如下图所示的这些选项，编程语言可以暂时不做选择，而<code>.gitignore</code>模板也可以稍后自己编写或者通过更专业的工具（如：<a target="_blank" rel="noopener" href="http://gitignore.io/">http://gitignore.io/</a>网站）自动生成。</p>
<p><img src="./res/gitee-create-project.png"></p>
</li>
<li><p>添加项目成员。创建项目后，可以在项目的“设置”或“管理”中找到“成员管理”功能，这样就可以将其他开发者设置为项目团队的成员，项目成员通常分为“所有者”、“管理者”、“普通成员”和“受限成员”几种角色。</p>
<p><img src="./res/gitee-add-members.png"></p>
</li>
<li><p>项目的分支。创建项目后，项目只有一个默认的<strong>master</strong>分支，应该将该分支设置为“保护分支”来避免项目管理者之外的成员修改该分支（不可直接提交）。当然，如果需要我们也可以在线创建新的代码分支。</p>
</li>
<li><p>设置公钥实现免密访问。在项目的“设置”或“管理”中我们还可以找到“部署公钥管理”的选项，通过添加部署公钥，可以通过SSH（安全远程连接）的方式访问服务器而不用每次输入用户名和口令。可以使用<code>ssh-keygen</code>命令来创建密钥对。</p>
<pre><code class="Shell">ssh-keygen -t rsa -b 2048 -C &quot;your_email@example.com&quot;
</code></pre>
<blockquote>
<p><strong>说明</strong>：上面命令生成的密钥对在<code>~/.ssh</code>目录下，公钥文件默认的名字为<code>id_rsa.pub</code>，可以通过<code>cat id_rsa.pub</code>来查看自己的公钥。Windows用户在安装Git工具后，可以通过<strong>Git Bash</strong>来输入上面的命令。</p>
</blockquote>
</li>
</ol>
<h4 id="Git远程操作"><a href="#Git远程操作" class="headerlink" title="Git远程操作"></a>Git远程操作</h4><p>拥有了Git服务器之后，我们就可以通过Git的远程操作将自己的工作成果推到服务器的仓库中，也可以将他人的工作成果从服务器仓库更新到本地。我们以刚才在码云上创建的仓库（仓库名为<code>python</code>）为例来说明如何进行远程操作。可以在如下所示的页面上找到仓库的地址（URL），如果配置了<strong>SSH Key</strong>就使用SSH方式访问仓库，否则就用HTTPS方式，后者需要在进行远程操作时提供用户名和口令。</p>
<p><img src="./res/gitee-project-index.png"></p>
<ol>
<li><p>添加远程仓库（Git服务器）。</p>
<pre><code class="Shell">git remote add origin git@gitee.com:jackfrued/python.git
</code></pre>
<p>其中<code>git@gitee.com:jackfrued/python.git</code>是上图中显示的仓库的URL，而前面的<code>origin</code>是替代这个冗长的URL的字符串，简单的说<code>origin</code>就是服务器上仓库的别名（如果有多个Git服务器，这个简短的名字也会有多个）。可以用<code>git remote -v</code>来查看已经指定的Git服务，也可以用<code>git remote remove</code>来删除指定的Git服务器。</p>
</li>
<li><p>将本地代码（工作成果）推送到远程仓库。</p>
<pre><code class="Shell">git push -u origin master:master
</code></pre>
<p>其中，<code>-u</code>是<code>--set-upstream</code>的缩写，用来指定推送的服务器仓库，后面的<code>origin</code>就是刚才给仓库起的简短的别名，冒号前面的<code>master</code>是本地分支名，冒号后面的<code>master</code>是远程分支名，如果本地分支<code>master</code>已经和远程分支<code>master</code>建立过关联，则冒号以及后面的部分可以省略。</p>
</li>
<li><p>从远程仓库取回代码。</p>
<pre><code class="Shell">git pull origin master
</code></pre>
</li>
</ol>
<h4 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h4><ol>
<li><p><strong>创建</strong>和<strong>切换</strong>分支。下面的命令创建了名为<code>dev</code> 的分支并切换到该分支。</p>
<pre><code class="Shell">git branch &lt;branch-name&gt;
git switch &lt;branch-name&gt;
</code></pre>
<p>或</p>
<pre><code class="Shell">git switch -c &lt;branch-name&gt;
</code></pre>
<blockquote>
<p><strong>注意</strong>：在之前的Git版本中，切换分支使用<code>git checkout &lt;branch-name&gt;</code>命令，也可以通过<code>git checkout -b &lt;branch-name&gt;</code>来创建并切换分支。<code>git switch</code>命令目前仍然处于试验性阶段，但很明显这个命令更加清晰的表达了它要做的事情。</p>
</blockquote>
</li>
<li><p><strong>关联远程</strong>分支。例如：如果当前所在的分支还没有关联到远程分支，可以使用下面的命令为它们建立关联。</p>
<pre><code class="Shell">git branch --set-upstream-to origin/develop
</code></pre>
<p>如果需要为指定的分支关联远程分支，可以如下操作。</p>
<pre><code class="Shell">git branch --set-upstream-to origin/develop &lt;branch-name&gt;
</code></pre>
<blockquote>
<p>提示：上面的操作假设Git服务器上存在名为<code>develop</code>的分支，<code>--set-upstream-to</code>可以缩写为<code>-u</code>。</p>
</blockquote>
<p>当然，在创建分支时，如果使用了<code>--track</code>参数，也可以直接指定与本地分支关联的远程分支，如下所示。</p>
<pre><code class="Shell">git branch --track &lt;branch-name&gt; origin/develop
</code></pre>
<p>如果需要解除本地分支与远程分支的关联，可以使用下面的命令。</p>
<pre><code class="Shell">git branch --unset-upstream &lt;branch-name&gt;
</code></pre>
</li>
<li><p>分支<strong>合并</strong>。例如在<code>dev</code>分支上完成开发任务之后，如果希望将<code>dev</code>分支上的成果合并到<code>master</code>，可以先切回到<code>master</code>分支然后使用<code>git merge</code>来做分支合并，合并的结果如下图右上方所示。</p>
<pre><code class="Shell">git switch master
git merge --no-ff dev
</code></pre>
<p>使用<code>git merge</code>合并分支时，默认使用<code>Fast Forward</code>合并，这意味着如果删除了分支，分支上的信息就全都丢掉了，如果希望将分支上的历史版本保留下来，可以使用<code>--no-ff</code>参数来禁用<code>Fast Forward</code>。</p>
<p>在合并分支时，没有冲突的部分Git会做自动合并。如果发生了冲突（如<code>dev</code>和<code>master</code>分支上都修改了同一个文件），会看到<code>CONFLICT (content): Merge conflict in &lt;filename&gt;. Automatic merge failed; fix conflicts and then commit the result</code>（自动合并失败，修复冲突之后再次提交）的提示，这个时候我们可以用<code>git diff</code>来查看产生冲突的内容。解决冲突通常需要当事人当面沟通之后才能决定保留谁的版本，冲突解决后需要重新提交代码。</p>
</li>
<li><p>分支<strong>变基</strong>。分支合并操作可以将多个分支上的工作成果最终合并到一个分支上，但是再多次合并操作之后，分支可能会变得非常的混乱和复杂，为了解决这个问题，可以使用<code>git rebase</code>操作来实现分支变基。如下图所示，当我们希望将<code>master</code>和<code>dev</code>上的工作成果统一到一起的时候，也可以使用变基操作。</p>
<p><img src="./res/git-rebase.png"></p>
<pre><code class="Shell">git rebase master
git switch master
git merge dev
</code></pre>
<p>当我们在<code>dev</code>分支执行<code>git rebase</code>命令时，将首先计算<code>dev</code>分支和<code>master</code>分支的差集，然后应用该差集到<code>dev</code>分支，最后我们切回到<code>master</code>分支并执行操作合并，这样就看到了如上图右下方所示的干净的分支。</p>
</li>
<li><p><strong>删除</strong>分支。删除分支可以使用<code>git branch</code>加上<code>-d</code>参数，如果分支上的工作成果还没有合并，那么在删除分支时会看到<code>error: The branch &#39;&lt;branch-name&gt;&#39; is not fully merged.</code>这样的错误提示。如果希望强行删除分支，可以使用<code>-D</code>参数。删除分支的操作如下所示。</p>
<pre><code class="Shell">git branch -d &lt;branch-name&gt;
error: The branch &#39;&lt;branch-name&gt;&#39; is not fully merged.
If you are sure you want to delete it, run &#39;git branch -D &lt;branch-name&gt;&#39;.
git branch -D &lt;branch-name&gt;
</code></pre>
<p>如果要删除远程分支，可以使用下面的命令，但是请慎重的操作。</p>
<pre><code class="Shell">git branch -r -d origin/develop
git push origin :develop
</code></pre>
<p>或者</p>
<pre><code class="Shell">git push origin --delete develop
</code></pre>
</li>
</ol>
<h4 id="Git其他操作"><a href="#Git其他操作" class="headerlink" title="Git其他操作"></a>Git其他操作</h4><ol>
<li><p><code>git fetch</code>：下载远程仓库的所有变动，可以将远程仓库下载到一个临时分支，然后再根据需要进行合并操作，<code>git fetch</code>命令和<code>git merge</code>命令可以看作是之前讲的<code>git pull</code>命令的分解动作。</p>
<pre><code class="Shell">git fetch origin master:temp
git merge temp
</code></pre>
</li>
<li><p><code>git diff</code>：常用于比较工作区和仓库、暂存区与仓库、两个分支之间有什么差别。</p>
</li>
<li><p><code>git stash</code>：将当前工作区和暂存区发生的变动放到一个临时的区域，让工作区变干净。这个命令适用于手头工作还没有提交，但是突然有一个更为紧急的任务（如线上bug需要修正）需要去处理的场景。</p>
<pre><code class="Shell">git stash
git stash list
git stash pop
</code></pre>
</li>
<li><p><code>git reset</code>：回退到指定的版本。该命令主要有三个参数，如下图所示。</p>
<p><img src="./res/git-reset.png"></p>
</li>
<li><p><code>git cherry-pick</code>：挑选某个分支的单次提交并作为一个新的提交引入到你当前分支上。</p>
</li>
<li><p><code>git revert</code>：撤回提交信息。</p>
</li>
<li><p><code>git tag</code>：经常用于查看或新增一个标签。</p>
</li>
</ol>
<h4 id="Git工作流程（分支管理策略）"><a href="#Git工作流程（分支管理策略）" class="headerlink" title="Git工作流程（分支管理策略）"></a>Git工作流程（分支管理策略）</h4><p>既然Git是团队开发必备的工具，那么在团队协作时就必须有一个规范的工作流程，这样才能让团队高效的工作，让项目顺利的进展下去，否则工具再厉害但团队成员各自为战，冲突就会无处不在，协作更加无从谈起。我们仍然以刚才码云上创建的<code>python</code>项目为例，来说明Git的分支管理策略。</p>
<h5 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github-flow"></a>Github-flow</h5><ol>
<li><p>克隆服务器上的代码到本地。</p>
<pre><code class="Shell">git clone git@gitee.com:jackfrued/python.git
</code></pre>
</li>
<li><p>创建并切换到自己的分支。</p>
<pre><code class="Shell">git switch -c &lt;branch-name&gt;
</code></pre>
<p>或</p>
<pre><code class="Shell">git checkout -b &lt;branch-name&gt;
</code></pre>
</li>
<li><p>在自己的分支上开发并在本地做版本控制。</p>
</li>
<li><p>将自己的分支（工作成果）推到服务器。</p>
<pre><code class="Shell">git push origin &lt;branch-name&gt;
</code></pre>
</li>
<li><p>在线发起一次合并请求（通常称之为<strong>Pull Request</strong>，有的地方称为<strong>Merge Request</strong>），请求将自己的工作成果合并到<code>master</code>分支，合并之后可以删除该分支。</p>
<p><img src="./res/gitee-pull-request.png"></p>
</li>
</ol>
<p>上面这种分支管理策略就是被称为<strong>github-flow</strong>或<strong>PR</strong>的流程，它非常简单容易理解，只需要注意以下几点：</p>
<ol>
<li><code>master</code>的内容都是可以进行发布的内容（不能直接在<code>master</code>上进行修改）。</li>
<li>开发时应该以<code>master</code>为基础建立新分支（日常开发任务在自己的分支上进行）。</li>
<li>分支先在本地实施版本控制，然后以同名分支定期向服务器进行push操作。</li>
<li>开发任务完成后向<code>master</code>发送合并请求。</li>
<li>合并请求通过审查之后合并到<code>master</code>，并从<code>master</code>向正式环境发布。</li>
</ol>
<p>当然，github-flow的缺点也很明显，<code>master</code>分支默认就是当前的线上代码，但是有的时候工作成果合并到<code>master</code>分支，并不代表它就能立刻发布，这样就会导致线上版本落后于<code>master</code>分支。</p>
<h5 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git-flow"></a>Git-flow</h5><p>除了上述的github-flow分支管理策略外，还有一种名为git-flow的分支管理策略，它也是大多数公司愿意使用的一套流程。Git-flow借鉴了中央集权型版本控制系统的长处，为团队内部统一建立、合并和关闭分支的方法，如下图所示。</p>
<p><img src="./res/git-flow.png"></p>
<p>在这种模式下，项目有两个长线分支，分别是<code>master</code>和<code>develop</code>，其他都是临时的的辅助分支，包括<code>feature</code>（开发特定功能的分支，开发结束后合并到<code>develop</code>）、<code>release</code>（从<code>develop</code>分离出来的为发布做准备的分支，发布结束后合并到<code>master</code>和<code>develop</code>）和<code>hotfix</code>（产品发布后出现问题时紧急建立的分支，直接从<code>master</code>分离，问题修复后合并到<code>master</code>并打上标签，同时还要合并到<code>develop</code>来避免将来的版本遗漏了这个修复工作，如果此时有正在发布中的<code>release</code>分支，还要合并到<code>release</code>分支）。具体的实施过程如下所示：</p>
<p><img src="./res/git-flow-detail.png"></p>
<ol>
<li><p>最开始的时候只有<code>master</code>和<code>develop</code>分支，如上图左侧所示。</p>
</li>
<li><p>从<code>develop</code>分支创建<code>feature</code>分支（上图右上），工作完成后将工作成果合并到<code>develop</code>分支（上图右中）。</p>
<p>创建<code>feature</code>分支：</p>
<pre><code class="Shell">git switch -c feature/user develop
</code></pre>
<p>或</p>
<pre><code class="Shell">git checkout -b feature/user develop
</code></pre>
<p>接下来就是在<code>feature</code>分支上进行开发并实施版本控制，这一段如何操作我们就不再赘述了。工作完成后，将<code>feature</code>分支合并到<code>develop</code>分支：</p>
<pre><code class="Shell">git checkout develop
git merge --no-ff feature/user
git branch -d feature/user
git push origin develop
</code></pre>
</li>
<li><p>从<code>develop</code>分支创建<code>release</code>分支，发布结束后合并回<code>master</code>和<code>develop</code>分支。</p>
<p>创建<code>release</code>分支：</p>
<pre><code class="Shell">git checkout -b release-0.1 develop
git push -u origin release-0.1
... ... ...
git pull
git commit -a -m &quot;............&quot;
</code></pre>
<p>将<code>release</code>分支合并回<code>master</code>和<code>develop</code>分支：</p>
<pre><code class="Shell">git checkout master
git merge --no-ff release-0.1
git push

git checkout develop
git merge --no-ff release-0.1
git push

git branch -d release-0.1
git push --delete release-0.1
git tag v0.1 master
git push --tags
</code></pre>
</li>
<li><p>从<code>master</code>分支创建<code>hotfix</code>分支，在修复bug后合并到<code>develop</code>和<code>master</code>分支（上图右下）。</p>
<p>创建<code>hotfix</code>分支：</p>
<pre><code class="Shell">git checkout -b hotfix-0.1.1 master
git push -u origin hotfix-0.1.1
... ... ...
git pull
git commit -a -m &quot;............&quot;
</code></pre>
<p>将<code>hotfix</code>分支合并回<code>develop</code>和<code>master</code>分支。</p>
<pre><code class="Shell">git checkout master
git merge --no-ff hotfix-0.1.1
git push

git checkout develop
git merge --no-ff hotfix-0.1.1
git push

git branch -d hotfix-0.1.1
git push --delete hotfix-0.1.1
git tag v0.1.1 master
git push --tags
</code></pre>
</li>
</ol>
<p>Git-flow流程比较容易控制各个分支的状况，但是在运用上github-flow要复杂得多，因此实际使用的时候通常会安装名为<code>gitflow</code>的命令行工具（Windows环境的Git自带了该工具）或者使用图形化的Git工具（如：SmartGit、SourceTree等）来简化操作，具体的可以参考<a target="_blank" rel="noopener" href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow">《git-flow 的工作流程》</a>一文，因为这篇文章写得已经很好了，本文不再进行赘述。</p>
<h3 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h3><p>没有好的团队管理工具必然导致项目进展不顺利，任务管理困难，而引入缺陷管理系统正好可以解决这些问题，通常一个缺陷管理系统都包含了以下的功能：</p>
<ol>
<li>任务管理（包括必须做什么、谁来做、什么时候完成、现在处于什么状态等）。</li>
<li>直观而且可以检索过去发生的各种问题。</li>
<li>能够对信息进行统一的管理和共享。</li>
<li>能够生成各类报表。</li>
<li>能够关联到其他系统，具有可扩展性。</li>
</ol>
<h4 id="禅道"><a href="#禅道" class="headerlink" title="禅道"></a>禅道</h4><p><a target="_blank" rel="noopener" href="https://www.zentao.net/">禅道</a>是国产的专业项目管理软件，它不仅仅是缺陷管理工具，它提供了完整软件生命周期管理功能，支持<a target="_blank" rel="noopener" href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html">Scrum敏捷开发</a>，能够实现需求管理、缺陷管理、任务管理等一系列的功能，而且拥有强大的扩展机制和丰富的功能插件。可以从禅道的官方网站提供的<a target="_blank" rel="noopener" href="https://www.zentao.net/download.html">下载链接</a>来下载禅道，推荐使用一键安装包。</p>
<p>下面仍然以CentOS Linux为例，讲解如何利用官方提供的一键安装包来安装禅道。</p>
<pre><code class="Shell">cd /opt
wget http://dl.cnezsoft.com/zentao/pro8.5.2/ZenTaoPMS.pro8.5.2.zbox_64.tar.gz
gunzip ZenTaoPMS.pro8.5.2.zbox_64.tar.gz
tar -xvf ZenTaoPMS.pro8.5.2.zbox_64.tar
</code></pre>
<p>我们在<code>/opt</code>目录下（官方推荐使用这个目录）下载了禅道的归档压缩文件，并进行了解压缩和解归档的操作，完成上述步骤后，会看到一个名为<code>zbox</code>的文件夹。一键安装包中内置了Apache、MySQL、PHP等应用，也就是说这些都不需要单独安装部署了，接下来我们通过下面的命令来启动禅道。</p>
<pre><code class="Shell">/opt/zbox/zbox -ap 8080 -mp 3307
/opt/zbox/zbox start
</code></pre>
<blockquote>
<p>说明：上面使用<code>zbox</code>文件夹下的<code>zbox</code>命令，其中<code>-ap</code>是为了指定Apache服务器使用的端口，<code>-mp</code>是为了指定MySQL数据库使用的端口，这里使用3307端口是为了避开服务器上可能已经存在的MySQL服务的3306端口；<code>start</code>表示启动服务，<code>stop</code>可以用来停止服务。此外，需要打开防火墙8080端口以便访问禅道，注意<strong>数据库的端口决不能暴露给公网</strong>。</p>
</blockquote>
<p>打开浏览器，输入服务器的公网IP地址就可以访问禅道，如果愿意，也可以通过DNS解析绑定一个域名来进行访问，禅道的首页如下图所示，默认的管理员是<code>admin</code>，口令是<code>123456</code>。</p>
<p><img src="./res/zentao-login.png"></p>
<p>第一次使用禅道时，建议通过点击用户名，然后通过“帮助”菜单的“新手教程”来迅速了解禅道。官方网站的文档链接中提供了<a target="_blank" rel="noopener" href="https://www.zentao.net/video/c1454.html">视频教程</a>，初学者也可以通过视频教程来上手。</p>
<p><img src="./res/zentao-index.png"></p>
<p>对敏捷开发以及敏捷闭环工具不是特别了解的，可以参考<a target="_blank" rel="noopener" href="https://blog.51cto.com/newthink/1775427">《基于JIRA的Scrum敏捷开发的项目管理》</a>一文。</p>
<h4 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h4><p>常用的代码托管平台和之前提到的Git私服Gitlab都提供了缺陷管理的功能，当我们要报告一个bug时，可以在如下图所示的界面创建一个新的问题票（issue ticket）。填写的内容包括：</p>
<ol>
<li>**[必填]**出现问题的软件版本号、具体的使用环境（如操作系统）等相关信息。</li>
<li>**[必填]**能够稳定重现该问题的相关步骤。</li>
<li>**[必填]**描述此处期待的行为和实际的行为。</li>
<li>**[可选]**你对这个bug的看法（产生bug的原因是什么）。</li>
</ol>
<p><img src="./res/gitlab-new-issue.png"></p>
<p>如上图所示，我们在创建问题票时，还需要将问题指派给处理问题的人，如果不清楚应该由谁来修复这个bug，就指派给项目管理者，除此之外还要指定问题的优先级（十分紧急、紧急、普通、不紧急等）、问题的标签（功能缺陷、新特性、改进增强、前瞻研究等）、里程碑（通过里程碑可以将问题与某些特定的项目节点关联起来，之后可以查看每一个里程碑的进展，可以基于软件版本号来建立里程碑，也可以基于迭代周期来建立里程碑）以及需要在哪个时间点以前修复等信息。</p>
<p>有些敏捷团队使用问题票来管理产品的需求，称之为“问题驱动开发”（TiDD），也就是说新功能的开发是通过创建问题票来驱动的，具体的步骤包括：建立问题票、指定责任人、开发、提交、Push到代码库。如果要创建一个和需求相关的问题票，应该要填写以下的内容：</p>
<ol>
<li>**[必填]**简短的描述需求，并用它作为标题。</li>
<li>**[必填]**这个需求是解决什么问题的。</li>
<li>**[必填]**这个需求对软件现有功能会造成什么影响。</li>
<li>**[必填]**这个需求应该实现什么样的功能。</li>
<li>**[必填]**这个需求是否依赖其他模块提供相关支持。</li>
<li>**[可选]**这个需求有哪些实现方式。</li>
<li>**[可选]**这些可选的实现方式分别有哪些优缺点。</li>
</ol>
<h4 id="其他产品"><a href="#其他产品" class="headerlink" title="其他产品"></a>其他产品</h4><p>除了禅道和GitLab之外，<a target="_blank" rel="noopener" href="https://www.atlassian.com/zh/software/jira">JIRA</a>、<a target="_blank" rel="noopener" href="https://www.redmine.org/">Redmine</a>、Backlog等也是不错的缺陷管理系统。目前，这些系统大都不仅仅提供了缺陷管理的功能，更多的时候它们可以作为敏捷闭环工具来使用，关于敏捷闭环工具这个话题，请大家参考<a target="_blank" rel="noopener" href="https://blog.51cto.com/newthink/1775427">《基于JIRA的Scrum敏捷开发的项目管理》</a>一文。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>为了快速的产出高质量的软件，在团队开发中持续集成（CI）是一个非常重要的环节。所谓CI，就是一种让计算机自动任意次重复编译、测试、汇报等工作的方法，通过CI可以帮助开发者提早发现问题，降低各种人为失误给项目带来的风险。按照经典的软件过程模型（瀑布模型），集成的工作一般要等到所有的开发工作都结束后才能开始，但这个时候如果发现了问题，修复问题的代价是非常具体的。基本上，集成实施得越晚，代码量越大，解决问题就越困难。持续集成将版本控制、自动化构建、代码测试融入到一起，让这些工作变得自动化和可协作。由于其频繁重复整个开发流程（在指定时间内多次pull源代码并运行测试代码），所以能帮助开发者提早发现问题。</p>
<p>在所有的CI工具中，Jenkins和<a target="_blank" rel="noopener" href="https://www.travis-ci.org/">TravisCI</a>是最具有代表性的，前者是基于 Java的开源CI工具，后者是新晋的在线CI工具，下图是Jenkins的工作面板。</p>
<p><img src="./res/jenkins_new_project.png"></p>
<p>持续集成对于编译型语言的意义更大，对于Python这样的解释型语言，更多的时候是用于对接版本控制系统触发自动化测试并产生相应的报告，类似的功能也可以通过配置<strong>Webhook</strong>来完成。如果要通过Docker这样的虚拟化容器进行项目打包部署或者通过K8S进行容器管理，可以在持续集成平台安装对应的插件来支持这些功能。码云甚至可以直接对接<a target="_blank" rel="noopener" href="https://ding-doc.dingtalk.com/">钉钉开放平台</a>使用钉钉机器人来向项目相关人员发送即时消息。GitLab也对CI和CD（持续交付）提供了支持，具体内容请大家参考<a target="_blank" rel="noopener" href="https://blog.stdioa.com/2018/06/gitlab-cicd-fundmental/">《GitLab CI/CD基础教程》</a>。</p>
<blockquote>
<p><strong>说明</strong>：</p>
<ol>
<li><p>关于敏捷开发的相关内容，有兴趣的读者可以阅读知乎上的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33472102">《这才是敏捷开发》</a>一文。</p>
</li>
<li><p>本章中的部分插图来自于网易云课堂<a target="_blank" rel="noopener" href="https://study.163.com/course/introduction/1003268008.htm">《人人都会用Git》</a>课程（免费哟），在此表示感谢。</p>
</li>
</ol>
</blockquote>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day91-100/100.Python面试题实录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.019Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day91-100/100.Python%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E5%BD%95/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Python面试题实录"><a href="#Python面试题实录" class="headerlink" title="Python面试题实录"></a>Python面试题实录</h2><blockquote>
<p><strong>温馨提示</strong>：请访问我的另一个项目<a target="_blank" rel="noopener" href="https://github.com/jackfrued/Python-Interview-Bible">“Python面试宝典”</a>。</p>
</blockquote>

        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day86-90/90.大数据分析项目实战" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.013Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day86-90/90.%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h2>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day86-90/89.Flink和流式数据处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.010Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day86-90/89.Flink%E5%92%8C%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h2>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-Python-100-Days-master/Day86-90/88.PySpark和离线数据处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-10-17T13:24:56.008Z" itemprop="datePublished">2021年10月17日</time>
</span>
      
      
      
<a href="/2021/10/17/Python-100-Days-master/Day86-90/88.PySpark%E5%92%8C%E7%A6%BB%E7%BA%BF%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h2>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/page/3/index.html">http://example.com/page/3/index.html</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/page/2/">Previous</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/">Next</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/PEP8/" style="font-size: 10px;">PEP8</a> <a href="/tags/PEP899/" style="font-size: 10px;">PEP899</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Python99/" style="font-size: 10px;">Python99</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%80/">Python基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python%E5%9F%BA%E7%A1%8000/">Python基础00</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年10月</a><span class="archive-list-count">173</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年08月</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP8/" rel="tag">PEP8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP899/" rel="tag">PEP899</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python99/" rel="tag">Python99</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example1.com/">site-name1</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example2.com/">site-name2</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="http://www.example3.com/">site-name3</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2021 John Doe.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        
            <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank">busuanzi.</a></span>
        
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
<script src="/localshare/js/social-share.js"></script>

  
<script src="/localshare/js/qrcode.js"></script>




















  </div>
</body>
</html>