<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-05T16:55:16.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</id>
    <published>2021-10-17T13:24:56.851Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="那些年我们踩过的那些坑"><a href="#那些年我们踩过的那些坑" class="headerlink" title="那些年我们踩过的那些坑"></a>那些年我们踩过的那些坑</h2><h3 id="坑1-整数比较的坑"><a href="#坑1-整数比较的坑" class="headerlink" title="坑1 - 整数比较的坑"></a>坑1 - 整数比较的坑</h3><p>在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符<code>==</code>和<code>is</code>，它们的区别是：</p><ul><li><code>is</code>比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。</li><li><code>==</code>比较的是两个整数对象的内容是否相等，使用<code>==</code>时其实是调用了对象的<code>__eq__()</code>方法。</li></ul><p>知道了<code>is</code>和<code>==</code>的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑，<strong>以CPython解释器为例</strong>，大家先看看下面的代码。</p><pre><code class="Python">def main():    x = y = -1    while True:        x += 1        y += 1        if x is y:            print(&#39;%d is %d&#39; % (x, y))        else:            print(&#39;Attention! %d is not %d&#39; % (x, y))            break                x = y = 0    while True:        x -= 1        y -= 1        if x is y:            print(&#39;%d is %d&#39; % (x, y))        else:            print(&#39;Attention! %d is not %d&#39; % (x, y))            breakif __name__ == &#39;__main__&#39;:    main()</code></pre><p>上面代码的部分运行结果如下图所示。这个结果是因为CPython出于性能优化的考虑，把频繁使用的整数对象用一个叫<code>small_ints</code>的对象池缓存起来造成的。<code>small_ints</code>缓存的整数值被设定为<code>[-5, 256]</code>这个区间，也就是说，如果使用CPython解释器，在任何引用这些整数的地方，都不需要重新创建<code>int</code>对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。</p><p><img src="./res/int-is-comparation.png"></p><p>当然仅仅如此这个坑就不值一提了，如果你理解了上面的规则，我们就再看看下面的代码。</p><pre><code class="Python">a = 257def main():    b = 257  # 第6行    c = 257  # 第7行    print(b is c)  # True    print(a is b)  # False    print(a is c)  # Falseif __name__ == &quot;__main__&quot;:    main()</code></pre><p>程序的执行结果已经用注释写在代码上了。够坑吧！看上去<code>a</code>、<code>b</code>和<code>c</code>的值都是一样的，但是<code>is</code>运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，<code>a = 257</code>是一个代码块，<code>main</code>函数是另外一个代码块。CPython底层为了进一步提升性能还做了一个设定：对于同一个代码块中值不在<code>small_ints</code>缓存范围之内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的<code>int</code>对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点可以自行证明。<br>为了验证刚刚的结论，我们可以借用<code>dis</code>模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看<a href="(http://www.cnblogs.com/restran/p/4903056.html)">《谈谈 Python 程序的运行原理》</a>这篇文章。可以先用<code>import dis</code>导入<code>dis</code>模块并按照如下所示的方式修改代码。</p><pre><code class="Python">import disdis.dis(main)</code></pre><p>代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是<code>main</code>函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的<code>a</code>明显是从不同的地方加载的，因此引用的是不同的对象。</p><p><img src="./res/result-of-dis.png"></p><p>如果还想对这个问题进行进一步深挖，推荐大家阅读<a href="https://foofish.net/python_int_implement.html">《Python整数对象实现原理》</a>这篇文章。</p><h3 id="坑2-嵌套列表的坑"><a href="#坑2-嵌套列表的坑" class="headerlink" title="坑2 - 嵌套列表的坑"></a>坑2 - 嵌套列表的坑</h3><p>Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。</p><pre><code class="Python">names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]subjs = [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;]scores = [[0] * 3] * 5for row, name in enumerate(names):    print(&#39;请输入%s的成绩&#39; % name)    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#39;: &#39;))        print(scores)</code></pre><p>我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。</p><p>要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序员大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量<code>a</code>并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量<code>b</code>是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。</p><pre><code class="Python">a = object()b = [&#39;apple&#39;, &#39;pitaya&#39;, &#39;grape&#39;]</code></pre><p>知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行<code>[[0] * 3] * 5</code>操作时，仅仅是将<code>[0, 0, 0]</code>这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过<code>id</code>函数检查<code>scores[0]</code>和<code>scores[1]</code>的地址得到证实。所以正确的代码应该按照如下的方式进行修改。</p><pre><code class="Python">names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]subjs = [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;]scores = [[]] * 5for row, name in enumerate(names):    print(&#39;请输入%s的成绩&#39; % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#39;: &#39;))        print(scores)</code></pre><p>或者</p><pre><code class="Python">names = [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]subjs = [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;]scores = [[0] * 3 for _ in range(5)]for row, name in enumerate(names):    print(&#39;请输入%s的成绩&#39; % name)    scores[row] = [0] * 3    for col, subj in enumerate(subjs):        scores[row][col] = float(input(subj + &#39;: &#39;))        print(scores)</code></pre><p>如果对内存的使用不是很理解，可以看看<a href="http://www.pythontutor.com/">PythonTutor网站</a>上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。</p><p><img src="./res/python-tutor-visualize.png"></p><p><img src="./res/python-tutor-visualize2.png"></p><h3 id="坑3-访问修饰符的坑"><a href="#坑3-访问修饰符的坑" class="headerlink" title="坑3 - 访问修饰符的坑"></a>坑3 - 访问修饰符的坑</h3><p>用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。</p><pre><code class="Python">class Student(object):    def __init__(self, name, age):        self.__name = name        self.__age = age    def __str__(self):        return self.__name + &#39;: &#39; + str(self.__age)stu = Student(&#39;骆昊&#39;, 38)print(stu._Student__name)print(stu._Student__age)</code></pre><p>Python为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。</p><p>所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。</p><p>需要提醒大家注意的是，Python类中的那些魔法方法，如<code>__str__</code>、<code>__repr__</code>等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;那些年我们踩过的那些坑&quot;&gt;&lt;a href=&quot;#那些年我们踩过的那些坑&quot; class=&quot;headerlink&quot; title=&quot;那些年我们踩过的那些坑&quot;&gt;&lt;/a&gt;那些年我们踩过的那些坑&lt;/h2&gt;&lt;h3 id=&quot;坑1-整数比较的坑&quot;&gt;&lt;a href=&quot;#坑1-整数比较的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/</id>
    <published>2021-10-17T13:24:56.847Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="英语面试"><a href="#英语面试" class="headerlink" title="英语面试"></a>英语面试</h2><p>以下用I表示面试官（Interviewer），用C表示面试者（Candidate）。</p><h3 id="开场寒暄"><a href="#开场寒暄" class="headerlink" title="开场寒暄"></a>开场寒暄</h3><ol><li><p>I: Thanks for waiting. (Please follow me.)</p><p>C: It’s no problem.</p></li><li><p>I: How are you doing this morning?</p><p>C: I’m great. / I’m doing fine. Thank you. / How about you?</p></li><li><p>I: How did you get here?</p><p>C: I took the subway here. / I drove here.</p></li><li><p>I: Glad to meet you.</p><p>C: Glad to meet you. / It’s great to finally meet you in person. (之前电话沟通过的)</p></li></ol><h3 id="正式面试"><a href="#正式面试" class="headerlink" title="正式面试"></a>正式面试</h3><h4 id="人力面试"><a href="#人力面试" class="headerlink" title="人力面试"></a>人力面试</h4><ol><li><p>I: Can you tell me a little bit about yourself? (介绍下自己)</p><p>原则：不要谈私生活和奇怪的癖好（英雄联盟干到钻石），因为别人更想知道的是你的专业技能（qulifications）和工作经验（experience），所以重点在你之前的公司（company name）、职位（title）、时间（years）和主要职责（major responsibilities）</p><p>C: Thank you for having me. My name is Dachui WANG. I’m 25 years old, and I’m single. I have a Bachelor’s Degree of Computer Science from Tsinghua University. I was a Junior Java Programmer for ABC Technologies during my college life. Then I become an intermediate Java engineer for XYZ Corporation in last two years. Programming is my everyday life and programming is where my passion is. I think I have a good knowledge of Java enterprise application developement using light-weight frameworks like Spring, Guice, Hibernate and other open source middle-ware like Dubbo, Mycat, rocketmq and so on and so forth. I love reading, travelling and playing basketball in my spare time. That’s all! Thank you!</p></li><li><p>I: How would you describe your personality? (你的性格)</p><p>C: I’m hard working, eager to learn, and very serious about my work. I enjoy working with other people and I love challenges.</p></li><li><p>I: What do you know about our company? (你对我们公司有什么了解)</p><p>(需要做功课，了解公司的状况和企业文化，该公司在这个行业中的一个状况，有什么核心业务，主要的竞争对手有哪些)</p><p>C: The one thing that I like the most about our company is your core values. I think they’re very important in this industry because …(自由发挥的部分)… I personally really believe in the cause as well. Of course, I’m very interested in your products such as …(功课部分)… and the techniques behind them.</p></li><li><p>I: Why are you leaving your last job? (为什么离职)</p><p>C: I want to advance my career and I think this job offers more challenges and  opportunities for me do to that.</p></li><li><p>I: What do you see yourself in 3 or 5 years? (3-5年职业规划)</p><p>C: My long term goals involve growing with the company, where I can continue to learn, to take on additional responsibilities and to contribute as much value as I can. I intend to take advantage of all of these.</p></li><li><p>I: What’s your salary expectation? (期望薪资)</p><p>C: My salary expectation is in line with my experience and qualifications. I believe our company will pay me and every other employee fairly. (把球踢给对方先看看对方报价是多少，如果对方非要你报价再说后面的内容) I think 15 thousands RMB or above is fitting for me to leave in Chengdu.</p></li><li><p>I: Do you have any questions for me? (问面试官的问题)</p><p>C: What’s the growth potential for this position?</p></li></ol><h4 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h4><ol><li>I: What’s difference between an interface and an abstract class?</li><li>I: What are pass by reference and pass by value?</li><li>I: What’s the difference between process and threads?</li><li>I: Explain the available thread state in high-level.</li><li>I: What’s deadlocks? How to avoid them?</li><li>I: How HashMap works in Java?</li><li>I: What’s the difference between ArrayList and LinkedList? (类似的问题还有很多，比如比较HashSet和TreeSet、HashMap和Hashtable)</li><li>I: Tell me what you know about garbage collection in Java.</li><li>I: What’re two types of exceptions in Java?</li><li>I: What’s the advantage of PreparedStatement over Statement?</li><li>I: What’s the use of CallableStatement?</li><li>I: What does connection pool mean?</li><li>I: Explain the life cycle of a Servlet.</li><li>I: What’s the difference between redirect and forward?</li><li>I: What’s EL? What’re implicit objects of EL?</li><li>I: Tell me what you know about Spring framework and its benefits.</li><li>I: What’re different types of dependency injection.</li><li>I: Are singleton beans thread safe in Spring framework?</li><li>I: What’re the benefits of Spring framework’s transaction management?</li><li>I: Explain what’s AOP.</li><li>I: What’s a proxy and how to implement proxy pattern?</li><li>I: How Spring MVC works?</li><li>I: What’s the working scenario of Hibernate and MyBatis?</li><li>I: How to implement SOA?</li><li>I: Make a brief introduction of the projects you are involved before?</li></ol><p>上面主要是面试Java程序员的问题，但是整个流程大致如此。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;英语面试&quot;&gt;&lt;a href=&quot;#英语面试&quot; class=&quot;headerlink&quot; title=&quot;英语面试&quot;&gt;&lt;/a&gt;英语面试&lt;/h2&gt;&lt;p&gt;以下用I表示面试官（Interviewer），用C表示面试者（Candidate）。&lt;/p&gt;
&lt;h3 id=&quot;开场寒暄&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E7%AD%94/</id>
    <published>2021-10-17T13:24:56.844Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知乎问题回答"><a href="#知乎问题回答" class="headerlink" title="知乎问题回答"></a>知乎问题回答</h2><h3 id="Python学习完基础语法知识后，如何进一步提高？"><a href="#Python学习完基础语法知识后，如何进一步提高？" class="headerlink" title="Python学习完基础语法知识后，如何进一步提高？"></a>Python学习完基础语法知识后，如何进一步提高？</h3><p>如果你已经完成了Python基础语法的学习，想要知道接下来如何提高，那么你得先问问自己你要用Python来做什么？目前学习Python后可能的就业方向包括以下几个领域，我把每个领域需要的技术作为了一个简单的关键词摘要。</p><blockquote><p>说明：以下数据参考了主要的招聘门户网站以及职友集。</p></blockquote><table><thead><tr><th>职位</th><th>所需技能</th><th>招聘需求量</th></tr></thead><tbody><tr><td>Python后端开发工程师</td><td>Python基础<br>Django / Flask / Tornado / Sanic<br>RESTful / 接口文档撰写<br>MySQL / Redis / MongoDB / ElasticSearch<br>Linux / Git / Scrum / PyCharm</td><td>一般</td></tr><tr><td>Python爬虫开发工程师</td><td>Python基础<br>常用标准库和三方库<br>Scrapy / PySpider<br>Selenium / Appnium<br>Redis / MongoDB / MySQL<br>前端 / HTTP(S) / 抓包工具</td><td>较少</td></tr><tr><td>Python量化交易开发工程师</td><td>Python基础<br>数据结构 / 算法 / 设计模式<br>NoSQL（KV数据库）<br>金融学（两融、期权、期货、股票） / 数字货币</td><td>一般</td></tr><tr><td>Python数据分析工程师 /<br>Python机器学习工程师</td><td>统计学专业 / 数学专业 / 计算机专业<br>Python基础 / 算法设计<br>SQL / NoSQL / Hive / Hadoop / Spark<br>NumPy / Scikit-Learn / Pandas / Seaborn<br>PyTorch / Tensorflow / OpenCV</td><td>大</td></tr><tr><td>Python自动化测试工程师</td><td>Python基础 / 单元测试 / 软件测试基础<br>Linux / Shell / JIRA / 禅道 / Jenkins / CI / CD<br>Selenium / Robot Framework / Appnium<br>ab / sysbench / JMeter / LoadRunner / QTP</td><td>大</td></tr><tr><td>Python自动化运维工程师</td><td>Python基础 / Linux / Shell <br>Fabric / Ansible / Playbook<br>Zabbix / Saltstack / Puppet<br>Docker / paramiko</td><td>大</td></tr><tr><td>Python云平台开发工程师</td><td>Python基础<br>OpenStack / CloudStack<br>Ovirt / KVM<br>Docker / K8S</td><td>较少</td></tr></tbody></table><p>如果弄清了自己将来要做的方向，就可以开始有针对性的学习了，下面给大家一个推荐书籍的清单。</p><ol><li><p>入门读物</p><ul><li>《Python基础教程》（<em>Beginning Python From Novice to Professional</em>）</li><li>《Python学习手册》（<em>Learning Python</em>）</li><li>《Python编程》（<em>Programming Python</em>）</li><li>《Python编程从入门到实践》（<em>Python Crash Course</em>）</li><li>《Python Cookbook》</li></ul></li><li><p>进阶读物</p><ul><li>《软件架构 - Python语言实现》（<em>Software Architecture with Python</em>）</li><li>《流畅的Python》（<em>Fluent Python</em>）</li><li>《Python设计模式》（<em>Learning Python Design Patterns</em>）</li><li>《Python高级编程》（<em>Expert Python Programming</em>）</li><li>《Python性能分析与优化》（<em>Mastering Python High Performance</em>）</li></ul></li><li><p>数据库相关</p><ul><li>《MySQL必知必会》（<em>MySQL Crash Course</em>）</li><li>《深入浅出MySQL - 数据库开发、优化与管理维护》</li><li>《MongoDB权威指南》（<em>MongoDB: The Definitive Guide</em>）</li><li>《Redis实战》（<em>Redis in Action</em>）</li><li>《Redis开发与运维》</li></ul></li><li><p>Linux / Shell / Docker / 运维</p><ul><li>《鸟哥的Linux私房菜》</li><li>《Linux命令行与shell脚本编程大全》（<em>Linux Command Line and Shell Scripting Bible</em>）</li><li>《Python自动化运维:技术与最佳实践》</li><li>《第一本Docker书》（<em>The Docker Book</em>）</li><li>《Docker经典实例》（Docker Cookbook）</li></ul></li><li><p>Django / Flask / Tornado</p><ul><li><p>《Django基础教程》（<em>Tango with Django</em>）</p></li><li><p>《轻量级Django》（<em>Lightweight Django</em>）</p></li><li><p>《精通Django》（<em>Mastering Django: Core</em>）</p></li><li><p>《Python Web开发：测试驱动方法》（<em>Test-Driven Development with Python</em>）</p></li><li><p>《Two Scoops of Django: Best Practice of Django 1.8》</p></li><li><p>《Flask Web开发：基于Python的Web应用开发实战》（<em>Flask Web Development: Developing Web Applications with Python</em>）</p></li><li><p>《深入理解Flask》（<em>Mastering Flask</em>）</p></li><li><p>《Introduction to Tornado》</p></li></ul></li><li><p>爬虫开发</p><ul><li><p>《用Python写网络爬虫》（<em>Web Scraping with Python</em>）</p></li><li><p>《精通Python爬虫框架Scrapy》（<em>Learning Scrapy</em>）</p></li><li><p>《Python网络数据采集》（<em>Web Scraping with Python</em>）</p></li><li><p>《Python爬虫开发与项目实战》</p></li><li><p>《Python 3网络爬虫开发实战》</p></li></ul></li><li><p>数据分析</p><ul><li>《利用Python进行数据分析》（<em>Python for Data Analysis</em>）</li><li>《Python数据科学手册》（<em>Python Data Science Handbook</em>）</li><li>《Python金融大数据分析》（<em>Python for Finance</em>）</li><li>《Python数据可视化编程实战》（<em>Python Data Visualization Cookbook</em>）</li><li>《Python数据处理》（<em>Data Wrangling with Python</em>）</li></ul></li><li><p>机器学习</p><ul><li><p>《Python机器学习基础教程》（<em>Introduction to Machine Learning with Python</em>）</p></li><li><p>《Python机器学习实践指南》（<em>Python Machine Learning Blueprints</em>）</p></li><li><p>《Python机器学习实践：测试驱动的开发方法》（<em>Thoughtful Machine Learning with Python A Test Driven Approach</em>）</p></li><li><p>《Python机器学习经典实例》（<em>Python Machine Learning Cookbook</em>）</p></li><li><p>《TensorFlow：实战Google深度学习框架》</p></li></ul></li><li><p>其他书籍</p><ul><li>《Pro Git》</li><li>《Selenium自动化测试 - 基于Python语言》（<em>Learning Selenium Testing Tools with Python</em>）</li><li>《Selenium自动化测试之道》</li><li>《Scrum敏捷软件开发》（<em>Software Development using Scrum</em>）</li><li>《高效团队开发 - 工具与方法》</li></ul></li></ol><p>当然学习编程，最重要的通过项目实战来提升自己的综合能力，Github上有大量的优质开源项目，其中不乏优质的Python项目。有一个名为<a href="https://github.com/mahmoud/awesome-python-applications">“awesome-python-applications”</a>的项目对这些优质的资源进行了归类并提供了传送门，大家可以了解下。如果自学能力不是那么强，可以通过网络上免费或者付费的视频课程来学习对应的知识；如果自律性没有那么强，那就只能建议花钱参加培训班了，因为花钱在有人监督的环境下学习对很多人来说确实是一个捷径，但是要记得：“师傅领进门，修行靠各人”。选择自己热爱的东西并全力以赴，不要盲目的跟风学习，这一点算是过来人的忠告吧。记得我自己刚开始进入软件开发这个行业时，有人跟我说过这么一句话，现在也分享出来与诸君共勉：“浮躁的人有两种：只观望而不学习的人，只学习而不坚持的人；浮躁的人都不是高手。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知乎问题回答&quot;&gt;&lt;a href=&quot;#知乎问题回答&quot; class=&quot;headerlink&quot; title=&quot;知乎问题回答&quot;&gt;&lt;/a&gt;知乎问题回答&lt;/h2&gt;&lt;h3 id=&quot;Python学习完基础语法知识后，如何进一步提高？&quot;&gt;&lt;a href=&quot;#Python学习完基础语</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-10-17T13:24:56.841Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用函数还是用复杂的表达式"><a href="#用函数还是用复杂的表达式" class="headerlink" title="用函数还是用复杂的表达式"></a>用函数还是用复杂的表达式</h2><p>Perl语言的原作者<em>Larry Wall</em>曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。</p><p>那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。</p><pre><code class="Python">a = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))if a &gt; b:    the_max = aelse:    the_max = bif c &gt; the_max:    the_max = cprint(&#39;The max is:&#39;, the_max)</code></pre><p>但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。</p><pre><code class="Python">a = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))the_max = a if a &gt; b else bthe_max = c if c &gt; the_max else the_maxprint(&#39;The max is:&#39;, the_max)</code></pre><p>需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为<code>?:</code>放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用<code>and</code>和<code>or</code>运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。</p><pre><code class="Python">a = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))the_max = a &gt; b and a or bthe_max = c &gt; the_max and c or the_maxprint(&#39;The max is:&#39;, the_max)</code></pre><p>但是这种做法在某些场景下是不能成立的，且看下面的代码。</p><pre><code class="Python">a = 0b = -100# 下面的代码本来预期输出a的值，结果却得到了b的值# 因为a的值0在进行逻辑运算时会被视为False来处理print(True and a or b)# print(a if True else b)</code></pre><p>所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。</p><pre><code class="Python">a = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))print(&#39;The max is:&#39;, (a if a &gt; b else b) if (a if a &gt; b else b) &gt; c else c)</code></pre><p>但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。</p><pre><code class="Python">def the_max(x, y):    return x if x &gt; y else ya = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))print(&#39;The max is:&#39;, the_max(the_max(a, b), c))</code></pre><p>上面的代码中，我定义了一个辅助函数<code>the_max</code>用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用<code>the_max</code>函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。</p><p>当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。</p><pre><code class="Python">a = int(input(&#39;a = &#39;))b = int(input(&#39;b = &#39;))c = int(input(&#39;c = &#39;))print(&#39;The max is:&#39;, max(a, b, c))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用函数还是用复杂的表达式&quot;&gt;&lt;a href=&quot;#用函数还是用复杂的表达式&quot; class=&quot;headerlink&quot; title=&quot;用函数还是用复杂的表达式&quot;&gt;&lt;/a&gt;用函数还是用复杂的表达式&lt;/h2&gt;&lt;p&gt;Perl语言的原作者&lt;em&gt;Larry Wall&lt;/em&gt;曾</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm/</id>
    <published>2021-10-17T13:24:56.837Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="玩转PyCharm"><a href="#玩转PyCharm" class="headerlink" title="玩转PyCharm"></a>玩转PyCharm</h2><p>PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发。</p><h3 id="PyCharm的下载和安装"><a href="#PyCharm的下载和安装" class="headerlink" title="PyCharm的下载和安装"></a>PyCharm的下载和安装</h3><p>可以在<a href="https://www.jetbrains.com/">JetBrains公司的官方网站</a>找到PyCharm的<a href="https://www.jetbrains.com/pycharm/download/">下载链接</a>，有两个可供下载的版本，一个是社区版（PyCharm CE），一个是专业版（PyCharm Professional）。社区版在Apache许可证下发布，可以免费使用；专业版在专用许可证下发布，需要购买授权后才能使用，但新用户可以试用30天。很显然，专业版提供了更为强大的功能和对企业级开发的各种支持，但是对于初学者来说，社区版已经足够强大和好用了。安装PyCharm只需要直接运行下载的安装程序，然后持续的点击“Next”（下一步）按钮就可以啦。下面是我在Windows系统下安装PyCharm的截图，安装完成后点击“Finish”（结束）按钮关闭安装向导，然后可以通过双击桌面的快捷方式来运行PyCharm。</p><p><img src="res/pycharm-installation.png"></p><h3 id="首次使用的设置"><a href="#首次使用的设置" class="headerlink" title="首次使用的设置"></a>首次使用的设置</h3><p>第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可，下面是我在macOS系统下第一次使用PyCharm时的截图。</p><p><img src="res/pycharm-import-settings.png"></p><p>专业版的PyCharm是需要激活的，<strong>强烈建议大家在条件允许的情况下支付费用来支持优秀的产品</strong>，如果不用做商业用途或者不需要使用PyCharm的高级功能，我们可以暂时选择试用30天或者使用社区版的PyCharm。如果你是一名学生，希望购买PyCharm来使用，可以看看<a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369">教育优惠官方申请指南</a>。如下图所示，我们需要点击“Evaluate”按钮来试用专业版PyCharm。</p><p><img src="res/pycharm-activation.png"></p><p>接下来是选择UI主题，可以根据个人喜好进行选择，深色的主题比较护眼而浅色的主题对比度更好。</p><p><img src="res/pycharm-ui-themes.png"></p><p>再接下来是创建可以在“终端”或“命令行提示符”中运行PyCharm的启动脚本，当然也可以不做任何勾选，直接点击“Next: Featured plugins”按钮进入下一环节。</p><p><img src="res/pycharm-create-launcher.png"></p><p>然后可以选择需要安装哪些插件，我们可以暂时什么都不安装，等需要的时候再来决定。</p><p><img src="res/pycharm-install-plugins.png"></p><p>最后点击上图右下角的“Start using PyCharm”（开始使用PyCharm）就可以开启你的PyCharm之旅了。</p><h3 id="用PyCharm创建项目"><a href="#用PyCharm创建项目" class="headerlink" title="用PyCharm创建项目"></a>用PyCharm创建项目</h3><p>启动PyCharm之后会来到一个欢迎页，在欢迎页上我们可以选择“创建新项目”（Create New Project）、“打开已有项目”（Open）和“从版本控制系统中检出项目”（Get from Version Control）。</p><p><img src="res/pycharm-welcome.png"></p><p>如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。下图所示是PyCharm专业版创建新项目的向导页，可以看出专业版支持的项目类型非常的多，而社区版只能创建纯Python项目（Pure Python），没有这一系列的选项。</p><p><img src="res/pycharm-project-wizard.png"></p><p>接下来，我们要为项目创建专属的虚拟环境，每个Python项目最好都在自己专属的虚拟环境中运行，因为每个项目对Python解释器和三方库的需求并不相同，虚拟环境对不同的项目进行了隔离。在上图所示的界面在，我们可以选择新建虚拟环境（New environment using Virtualenv），这里的“Virtualenv”是PyCharm默认选择的创建虚拟环境的工具，我们就保留这个默认的选项就可以了。</p><p>项目创建完成后就可以开始新建各种文件来书写Python代码了，如下图所示。左侧是项目浏览器，可以看到刚才创建的项目文件夹以及虚拟环境文件夹。我们可以在项目上点击鼠标右键，选择“New”，在选择“Python File”来创建Python代码文件，下图中我们创建了两个Python文件，分别是<code>poker_game.py</code>和<code>salary_system.py</code>。当然，如果愿意，也可以使用复制粘贴的方式把其他地方的Python代码文件复制到项目文件夹下。</p><p><img src="res/pycharm-workspace.png"></p><p>在工作窗口点击鼠标右键可以在上下文菜单中找到“Run”选项，例如要运行<code>salary_system.py</code>文件，右键菜单会显示“Run ‘salary_system’”选项，点击这个选项我们就可以运行Python代码啦，运行结果在屏幕下方的窗口可以看到，如下图所示。</p><p><img src="res/pycharm-run-result.png"></p><h3 id="常用操作和快捷键"><a href="#常用操作和快捷键" class="headerlink" title="常用操作和快捷键"></a>常用操作和快捷键</h3><p>PyCharm为写Python代码提供了自动补全和高亮语法功能，这也是PyCharm作为集成开发环境（IDE）的基本功能。PyCharm的“File”菜单有一个“Settings”菜单项（macOS上是在“PyCharm”菜单的“Preferences…”菜单项），这个菜单项会打开设置窗口，可以在此处对PyCharm进行设置，如下图所示。</p><p><img src="/Users/Hao/Desktop/Python-Core-50-Courses/res/pycharm-settings.png"></p><p>PyCharm的菜单项中有一个非常有用的“Code”菜单，菜单中提供了自动生成代码、自动补全代码、格式化代码、移动代码等选项，这些功能对开发者来说是非常有用的，大家可以尝试使用这些菜单项或者记住它们对应的快捷键，例如在macOS上，格式化代码这个菜单项对应的快捷键是<code>alt+command+L</code>。除此之外，“Refactor”菜单也非常有用，它提供了一些重构代码的选项。所谓重构是在不改变代码执行结果的前提下调整代码的结构，这也是资深程序员的一项重要技能。还有一个值得一提的菜单是“VCS”，VCS是“Version Control System”（版本控制系统）的缩写，这个菜单提供了对代码版本管理的支持。版本控制的知识会在其他的课程中为大家讲解。</p><p>下表列出了一些PyCharm中特别常用的快捷键，当然如果愿意，也可以通过设置窗口中“Keymap”菜单项自定义快捷键，PyCharm本身也针对不同的操作系统和使用习惯对快捷键进行了分组。</p><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><code>command + j</code></td><td>显示可用的代码模板</td></tr><tr><td><code>command + b</code></td><td>查看函数、类、方法的定义</td></tr><tr><td><code>ctrl + space</code></td><td>万能代码提示快捷键，一下不行按两下</td></tr><tr><td><code>command + alt + l</code></td><td>格式化代码</td></tr><tr><td><code>alt + enter</code></td><td>万能代码修复快捷键</td></tr><tr><td><code>ctrl + /</code></td><td>注释/反注释代码</td></tr><tr><td><code>shift + shift</code></td><td>万能搜索快捷键</td></tr><tr><td><code>command + d</code> / <code>command + y</code></td><td>复制/删除一行代码</td></tr><tr><td><code>command + shift + -</code> / <code>command + shift + +</code></td><td>折叠/展开所有代码</td></tr><tr><td><code>F2</code></td><td>快速定位到错误代码</td></tr><tr><td><code>command+ alt + F7</code></td><td>查看哪些地方用到了指定的函数、类、方法</td></tr></tbody></table><blockquote><p><strong>说明</strong>：Windows系统下如果使用PyCharm的默认设置，可以将上面的<code>command</code>键换成<code>ctrl</code>键即可，唯一的例外是<code>ctrl + space</code>那个快捷键，因为它跟Windows系统切换输入法的快捷键是冲突的，所以在Windows系统下默认没有与之对应的快捷键。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;玩转PyCharm&quot;&gt;&lt;a href=&quot;#玩转PyCharm&quot; class=&quot;headerlink&quot; title=&quot;玩转PyCharm&quot;&gt;&lt;/a&gt;玩转PyCharm&lt;/h2&gt;&lt;p&gt;PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E7%A4%BA%E4%BE%8B/</id>
    <published>2021-10-17T13:24:56.834Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口文档参考示例"><a href="#接口文档参考示例" class="headerlink" title="接口文档参考示例"></a>接口文档参考示例</h2><ol start="0"><li><p>用户登录 - <strong>POST</strong> <code>/api/login/</code></p><p>   开发者：骆昊</p><p>   版本号：v1</p><p>   最后修改时间：</p><p>   接口说明：登录成功后，会生成或更新用户令牌（token）。</p><p>   使用帮助：测试数据库中预设了四个可供使用的账号，如下表所示。</p><table><thead><tr><th>用户名</th><th>用户口令</th><th>角色</th></tr></thead><tbody><tr><td>jackfrued</td><td>123456</td><td>管理员</td></tr><tr><td>wangdachui</td><td>123123</td><td>普通用户</td></tr><tr><td>hellokitty</td><td>123123</td><td>房地产经理人</td></tr><tr><td>wuzetian</td><td>123456</td><td>房东</td></tr></tbody></table><p>   请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>username</td><td>字符串</td><td>是</td><td>消息体</td><td>用户名</td></tr><tr><td>password</td><td>字符串</td><td>是</td><td>消息体</td><td>用户口令</td></tr></tbody></table><p>   响应信息：</p><ul><li><p>登录成功：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 30000,    &quot;message&quot;: &quot;用户登录成功&quot;,    &quot;token&quot;: &quot;f83e0f624e2311e9af1f00163e02b646&quot;&#125;</code></pre></li><li><p>登录失败：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 30001,    &quot;message&quot;: &quot;用户名或密码错误&quot;&#125;</code></pre></li></ul></li><li><p>发送短信验证码 - <strong>GET</strong> <code>/api/mobile_code/&#123;国内手机号&#125;/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：给指定手机号发送短信验证码的接口，手机号必须是国内手机号，作为路径参数写到URL中。接口显示短信发送成功时，指定的手机号并不会收到短息，因为使用的三方短信平台赠送的测试短信已经用完了。</p><p>使用帮助：国内手机号暂不支持国际区号。</p><p>请求参数：暂无。</p><p>响应信息：</p><ul><li><p>请求成功：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 10001,    &quot;msg&quot;: &quot;短信验证码发送成功&quot;&#125;</code></pre></li><li><p>两次请求间隔小于60秒：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 10002,    &quot;msg&quot;: &quot;请不要在60秒以内重复发送手机验证码&quot;&#125;</code></pre></li><li><p>手机号无效：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 10003,    &quot;msg&quot;: &quot;请提供有效的手机号&quot;&#125;</code></pre></li><li><p>短信服务平台故障：</p><pre><code class="JSON">&#123;    &quot;code&quot;: 10004,    &quot;msg&quot;: &quot;短信服务暂时无法使用&quot;&#125;</code></pre></li></ul></li><li><p>获取所有省级行政单位 - <strong>GET</strong> <code>/api/districts/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：暂无。</p><p>使用帮助：暂无。</p><p>请求参数：暂无。</p><p>响应信息：</p><pre><code class="JSON">[    &#123;        &quot;distid&quot;: 110000,        &quot;name&quot;: &quot;北京市&quot;    &#125;,    &#123;        &quot;distid&quot;: 120000,        &quot;name&quot;: &quot;天津市&quot;    &#125;]</code></pre></li><li><p>获取指定行政单位详情及其管辖的行政单位 - <strong>GET</strong> <code>/api/districts/&#123;行政单位编号&#125;/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：通过URL参数指定行政单位编号，如果行政单位编号为省级行政单位编号，则返回该省以及该省所辖市级行政单位的信息；如果行政单位编号为市级行政单位编号，则返回该市以及该市所辖区县的信息；如果行政单位编号为区县一级行政单位编号，则返回该区县的信息，下级行政单位<code>cities</code>属性值为<code>[]</code>。</p><p>使用帮助：数据库中除四川省外其他行政单位的“intro”数据都没有录入，该字段可能为空字符串。</p><p>请求参数：暂无。</p><p>响应信息：</p><pre><code class="JSON">&#123;    &quot;distid&quot;: 510000,    &quot;name&quot;: &quot;四川省&quot;,    &quot;intro&quot;: &quot;位于中国西南地区内陆，东连重庆，南邻云南、贵州，西接西藏，北界陕西、甘肃、青海，四川省总面积48.6万平方千米，省会成都。截至2018年底，四川省下辖18个省辖市，3个自治州，17个县级市，108个县，4个自治县，54个市辖区。&quot;,    &quot;cities&quot;: [        &#123;            &quot;distid&quot;: 510100,            &quot;name&quot;: &quot;成都市&quot;        &#125;,        &#123;            &quot;distid&quot;: 510300,            &quot;name&quot;: &quot;自贡市&quot;        &#125;,        &#123;            &quot;distid&quot;: 510400,            &quot;name&quot;: &quot;攀枝花市&quot;        &#125;    ]&#125;</code></pre></li><li><p>获取热门城市 - <strong>GET</strong> <code>/api/hotcities/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：暂无。</p><p>使用帮助：暂无。</p><p>请求参数：暂无。</p><p>响应信息：</p><pre><code class="JSON">[    &#123;        &quot;distid&quot;: 110100,        &quot;name&quot;: &quot;北京市&quot;    &#125;,    &#123;        &quot;distid&quot;: 120100,        &quot;name&quot;: &quot;天津市&quot;    &#125;,    &#123;        &quot;distid&quot;: 130100,        &quot;name&quot;: &quot;石家庄&quot;    &#125;]</code></pre></li><li><p>分页获取房地产经理人信息 - <strong>GET</strong> <code>/api/agents/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：经理人姓名按照前缀模糊匹配的方式进行处理；经理人服务星级是指经理人服务星级不得低于该星级；经理人是否持证只有0（未持证上岗）和1（持证上岗）两个选项。三个参数代表的筛选条件之间是而且的关系。返回结果为分页之后的房地产经理人信息。</p><p>使用帮助：暂无。</p><p>请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>否</td><td>查询参数</td><td>经理人姓名</td></tr><tr><td>key</td><td>字符串</td><td>否</td><td>查询参数</td><td>经理人服务星级</td></tr><tr><td>cert</td><td>字符串</td><td>否</td><td>查询参数</td><td>经理人是否持证</td></tr><tr><td>page</td><td>整数</td><td>否</td><td>查询参数</td><td>页码，默认值为1</td></tr><tr><td>size</td><td>整数</td><td>否</td><td>查询参数</td><td>页面大小，默认值为5，最大值不超过50</td></tr></tbody></table><p>响应信息：</p><pre><code class="JSON">&#123;    &quot;count&quot;: 1,    &quot;next&quot;: null,    &quot;previous&quot;: null,    &quot;results&quot;: [        &#123;            &quot;agentid&quot;: 6,            &quot;estates&quot;: [                &#123;                    &quot;estateid&quot;: 11,                    &quot;name&quot;: &quot;灵芝新村&quot;,                    &quot;hot&quot;: 20                &#125;            ],            &quot;name&quot;: &quot;肖利丽&quot;,            &quot;tel&quot;: &quot;13040813886&quot;,            &quot;servstar&quot;: 4,            &quot;realstar&quot;: 4,            &quot;profstar&quot;: 4,            &quot;certificated&quot;: false        &#125;    ]&#125;</code></pre></li><li><p>新增房地产经理人 - <strong>POST</strong> <code>/api/agents/</code></p><p>开发者：骆昊</p><p>版本号：v1</p><p>接口说明：暂无。</p><p>使用帮助：需要登录且拥有管理员权限，用户身份令牌在请求头中提供。</p><p>请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>是</td><td>消息体</td><td>经理人姓名</td></tr><tr><td>tel</td><td>字符串</td><td>是</td><td>消息体</td><td>经理人手机</td></tr><tr><td>servstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>realstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>profstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>certificated</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>token</td><td>字符串</td><td>是</td><td>请求头</td><td>用户身份认证令牌</td></tr></tbody></table><p>响应信息：</p><ul><li><p>新增成功 - 状态码<strong>201</strong>：</p><pre><code class="JSON">&#123;    &quot;agentid&quot;: 8,    &quot;estates&quot;: [],    &quot;name&quot;: &quot;孙小美&quot;,    &quot;tel&quot;: &quot;13800991234&quot;,    &quot;servstar&quot;: 0,    &quot;realstar&quot;: 0,    &quot;profstar&quot;: 0,    &quot;certificated&quot;: false&#125;</code></pre></li><li><p>未提供身份认证信息 - 状态码<strong>401</strong>：</p><pre><code class="JSON">&#123;    &quot;detail&quot;: &quot;不正确的身份认证信息。&quot;&#125;</code></pre></li><li><p>当前用户没有操作权限 - 状态码<strong>403</strong>：</p><pre><code class="JSON">&#123;    &quot;detail&quot;: &quot;您没有执行该操作的权限。&quot;&#125;</code></pre></li></ul></li><li><p>编辑房地产经理人信息 - <strong>PUT</strong> <code>/api/agents/&#123;房地产经理人编号&#125;/</code></p><p> 开发者：骆昊</p><p> 版本号：v1</p><p> 接口说明：暂无。</p><p> 使用帮助：需要登录且拥有管理员权限，用户身份令牌在请求头中提供。</p><p> 请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>是</td><td>消息体</td><td>经理人姓名</td></tr><tr><td>tel</td><td>字符串</td><td>是</td><td>消息体</td><td>经理人手机</td></tr><tr><td>servstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>realstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>profstar</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>certificated</td><td>整数</td><td>否</td><td>消息体</td><td>默认值0</td></tr><tr><td>token</td><td>字符串</td><td>是</td><td>请求头</td><td>用户身份认证令牌</td></tr></tbody></table><p> 响应信息：</p><ul><li>更新成功 - 状态码<strong>200</strong>：</li></ul><pre><code class="JSON">&#123;    &quot;agentid&quot;: 1,    &quot;estates&quot;: [        &#123;            &quot;estateid&quot;: 1,            &quot;name&quot;: &quot;今日家园&quot;,            &quot;hot&quot;: 20        &#125;,        &#123;            &quot;estateid&quot;: 2,            &quot;name&quot;: &quot;翡翠园&quot;,            &quot;hot&quot;: 30        &#125;,        &#123;            &quot;estateid&quot;: 3,            &quot;name&quot;: &quot;万科城市花园&quot;,            &quot;hot&quot;: 22        &#125;    ],    &quot;name&quot;: &quot;袁晓梦&quot;,    &quot;tel&quot;: &quot;158173555285&quot;,    &quot;servstar&quot;: 5,    &quot;realstar&quot;: 4,    &quot;profstar&quot;: 3,    &quot;certificated&quot;: true&#125;</code></pre><ul><li>未提供身份认证信息 - 状态码<strong>403</strong> - 与新增类同</li><li>当前用户没有操作权限 - 状态码<strong>403</strong> - 与新增类同</li></ul></li><li><p>删除房地产经理人 - <strong>DELETE</strong> <code>/api/agents/&#123;房地产经理人编号&#125;/</code></p><p> 开发者：骆昊</p><p> 版本号：v1</p><p> 接口说明：暂无。</p><p> 使用说明：暂无。</p><p> 请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>token</td><td>字符串</td><td>是</td><td>请求头</td><td>用户身份认证令牌</td></tr></tbody></table><p> 响应信息：</p><ul><li>删除成功 - 状态码<strong>204</strong></li><li>未提供身份认证信息 - 状态码<strong>403</strong> - 与新增类同</li><li>当前用户没有操作权限 - 状态码<strong>403</strong> - 与新增类同</li></ul></li><li><p>分页获取楼盘信息 - <strong>GET</strong> <code>/api/estates/</code></p><p> 开发者：骆昊</p><p> 版本号：v1</p><p> 接口说明：经理人姓名按照前缀模糊匹配的方式进行处理；经理人服务星级是指经理人服务星级不得低于该星级；经理人是否持证只有0（未持证上岗）和1（持证上岗）两个选项。三个参数代表的筛选条件之间是而且的关系。返回结果为分页之后的房地产经理人信息。</p><p> 使用帮助：暂无。</p><p> 请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>否</td><td>查询参数</td><td>楼盘名（模糊匹配）</td></tr><tr><td>dist</td><td>字符串</td><td>否</td><td>查询参数</td><td>楼盘所在地区编号</td></tr><tr><td>page</td><td>整数</td><td>否</td><td>查询参数</td><td>页码，默认值为1</td></tr><tr><td>size</td><td>整数</td><td>否</td><td>查询参数</td><td>页面大小，默认值为5，最大值不超过50</td></tr></tbody></table><p> 响应信息：</p><pre><code class="JSON">&#123;    &quot;count&quot;: 16,    &quot;next&quot;: &quot;https://120.77.222.217/api/estates/?page=2&quot;,    &quot;previous&quot;: null,    &quot;results&quot;: [        &#123;            &quot;estateid&quot;: 6,            &quot;district&quot;: &#123;                &quot;distid&quot;: 440303,                &quot;name&quot;: &quot;罗湖区&quot;            &#125;,            &quot;agents&quot;: [                &#123;                    &quot;agentid&quot;: 2,                    &quot;name&quot;: &quot;杨伟&quot;,                    &quot;tel&quot;: &quot;13352939550&quot;,                    &quot;servstar&quot;: 3                &#125;,                &#123;                    &quot;agentid&quot;: 4,                    &quot;name&quot;: &quot;郭志鹏&quot;,                    &quot;tel&quot;: &quot;13686810707&quot;,                    &quot;servstar&quot;: 4                &#125;            ],            &quot;name&quot;: &quot;幸福里&quot;,            &quot;hot&quot;: 300,            &quot;intro&quot;: &quot;&quot;        &#125;    ]&#125;</code></pre></li><li><p>新增楼盘 - <strong>POST</strong> <code>/api/estates/</code></p></li></ol><p>  开发者：骆昊</p><p>  版本号：v1</p><p>  接口说明：暂无。</p><p>  使用帮助：需要登录且拥有管理员权限，用户身份令牌在请求头中提供。</p><p>  请求参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>是</td><td>消息体</td><td>楼盘名称</td></tr><tr><td>hot</td><td>整数</td><td>否</td><td>消息体</td><td>楼盘热度，默认值0</td></tr><tr><td>intro</td><td>字符串</td><td>否</td><td>消息体</td><td>楼盘介绍，默认值空字符串</td></tr><tr><td>distid</td><td>整数</td><td>是</td><td>消息体</td><td>楼盘所在地区编号</td></tr><tr><td>token</td><td>字符串</td><td>是</td><td>请求头</td><td>用户身份认证令牌</td></tr></tbody></table><p>  响应信息：</p><ul><li><p>新增成功 - 状态码<strong>201</strong>：</p><pre><code class="JSON">&#123;    &quot;estateid&quot;: 17,    &quot;district&quot;: 510107,    &quot;name&quot;: &quot;世纪锦苑&quot;,    &quot;hot&quot;: 100,    &quot;intro&quot;: &quot;&quot;&#125;</code></pre></li><li><p>未提供身份认证信息 - 状态码<strong>403</strong>：</p><pre><code class="JSON">&#123;    &quot;detail&quot;: &quot;请提供有效的身份认证信息&quot;&#125;</code></pre></li><li><p>当前用户没有操作权限 - 状态码<strong>403</strong>：</p><pre><code class="JSON">&#123;    &quot;detail&quot;: &quot;You do not have permission to perform this action.&quot;&#125;</code></pre></li></ul><ol start="11"><li><p>编辑楼盘信息 - <strong>PUT</strong> <code>/api/estates/&#123;楼盘编号&#125;</code></p></li><li><p>删除楼盘信 - <strong>DELETE</strong> <code>/api/estates/&#123;楼盘编号&#125;</code></p></li><li><p>获取所有户型信息 - <strong>GET</strong> <code>/api/housetypes/</code></p></li><li><p>新增户型 - <strong>POST</strong> <code>/api/housetypes/</code></p></li><li><p>编辑户型信息 - <strong>PUT</strong> <code>/api/housetypes/&#123;户型编号&#125;</code></p></li><li><p>删除户型 - <strong>DELETE</strong> <code>/api/housetypes/&#123;户型编号&#125;</code></p></li><li><p>分页获取房源信息 - <strong>GET</strong> <code>/api/houseinfos/</code></p><p> 开发者：骆昊</p><p> 版本号：v1</p><p> 接口说明：暂无。</p><p> 使用帮助：暂无。</p><p> 请求参数：    </p><table><thead><tr><th>参数名</th><th>类型</th><th>是否必填</th><th>参数位置</th><th>说明</th></tr></thead><tbody><tr><td>title</td><td>字符串</td><td>否</td><td>查询参数</td><td>房源标题关键词</td></tr><tr><td>dist</td><td>整数</td><td>否</td><td>查询参数</td><td>楼盘所在地区编号</td></tr><tr><td>min_price</td><td>整数</td><td>否</td><td>查询参数</td><td>价格区间下限</td></tr><tr><td>max_price</td><td>整数</td><td>否</td><td>查询参数</td><td>价格区间上限</td></tr><tr><td>type</td><td>整数</td><td>否</td><td>查询参数</td><td>户型编号</td></tr><tr><td>page</td><td>整数</td><td>否</td><td>查询参数</td><td>页码，默认值为1</td></tr><tr><td>size</td><td>整数</td><td>否</td><td>查询参数</td><td>页面大小，默认值为5，最大值不超过50</td></tr></tbody></table><p> 响应信息：</p><pre><code class="JSON">&#123;    &quot;count&quot;: 7,    &quot;next&quot;: &quot;http://localhost:8000/api/houseinfos/?dist=440303&amp;page=2&quot;,    &quot;previous&quot;: null,    &quot;results&quot;: [    ]&#125;</code></pre></li><li><p>查看房源详情 - <strong>GET</strong> <code>/api/houseinfos/&#123;房源编号&#125;</code></p></li><li><p>新增房源 - <strong>POST</strong> <code>/api/houseinfos/</code></p></li><li><p>编辑房源信息 - <strong>PUT</strong> <code>/api/houseinfos/&#123;房源编号&#125;</code></p></li><li><p>删除房源 - <strong>DELETE</strong> <code>/api/houseinfos/&#123;房源编号&#125;</code></p></li><li><p>随机获取指定数量的房源标签 - <strong>GET</strong> <code>/api/tags/</code></p></li><li><p>分页查看房源标签 - <strong>GET</strong> <code>/api/tags/</code></p></li><li><p>新增房源标签 - <strong>POST</strong> <code>/api/tags/</code></p></li><li><p>删除房源标签 - <strong>DELETE</strong>  <code>/api/tags/&#123;房源编号&#125;</code></p></li><li><p>查看房源的图片 - <strong>GET</strong> <code>/api/houseinfos/&#123;房源编号&#125;/photos/</code></p></li><li><p>为房源添加图片 - <strong>POST</strong> <code>/api/houseinfos/&#123;房源编号&#125;/photos/</code></p></li><li><p>删除房源图片 - <strong>DELETE</strong> <code>/api/houseinfos/&#123;房源编号&#125;/photos/&#123;图片编号&#125;</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;接口文档参考示例&quot;&gt;&lt;a href=&quot;#接口文档参考示例&quot; class=&quot;headerlink&quot; title=&quot;接口文档参考示例&quot;&gt;&lt;/a&gt;接口文档参考示例&lt;/h2&gt;&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;&lt;p&gt;用户登录 - &lt;strong&gt;POST&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86Python/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86Python/</id>
    <published>2021-10-17T13:24:56.831Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我为什么选择了Python"><a href="#我为什么选择了Python" class="headerlink" title="我为什么选择了Python"></a>我为什么选择了Python</h2><p>目前，Python语言的发展势头在国内国外都是不可阻挡的，Python凭借其简单优雅的语法，强大的生态圈从众多语言中脱颖而出，如今已经是稳坐编程语言排行榜前三的位置。国内很多Python开发者都是从Java开发者跨界过来的，我自己也不例外。我简单的跟大家交代一下，我为什么选择了Python。</p><h3 id="Python-vs-Java"><a href="#Python-vs-Java" class="headerlink" title="Python vs. Java"></a>Python vs. Java</h3><p>我们通过几个例子来比较一下，做同样的事情Java和Python的代码都是怎么写的。</p><p>例子1：在终端中输出“hello, world”。</p><p>Java代码：</p><pre><code class="Java">class Test &#123;        public static void main(String[] args) &#123;        System.out.println(&quot;hello, world&quot;);    &#125;&#125;</code></pre><p>Python代码：</p><pre><code class="Python">print(&#39;hello, world&#39;)</code></pre><p>例子2：从1到100求和。</p><p>Java代码：</p><pre><code class="Java">class Test &#123;        public static void main(String[] args) &#123;        int total = 0;        for (int i = 1; i &lt;= 100; i += 1) &#123;            total += i;        &#125;        System.out.println(total);    &#125;&#125;</code></pre><p>Python代码：</p><pre><code class="Python">print(sum(range(1, 101)))</code></pre><p>例子3：双色球随机选号。</p><p>Java代码：</p><pre><code class="Java">import java.util.List;import java.util.ArrayList;import java.util.Collections;class Test &#123;    /**     * 产生[min, max)范围的随机整数     */    public static int randomInt(int min, int max) &#123;        return (int) (Math.random() * (max - min) + min);    &#125;    public static void main(String[] args) &#123;        // 初始化备选红色球        List&lt;Integer&gt; redBalls = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= 33; ++i) &#123;            redBalls.add(i);        &#125;        List&lt;Integer&gt; selectedBalls = new ArrayList&lt;&gt;();        // 选出六个红色球        for (int i = 0; i &lt; 6; ++i) &#123;            selectedBalls.add(redBalls.remove(randomInt(0, redBalls.size())));        &#125;        // 对红色球进行排序        Collections.sort(selectedBalls);        // 添加一个蓝色球        selectedBalls.add(randomInt(1, 17));        // 输出选中的随机号码        for (int i = 0; i &lt; selectedBalls.size(); ++i) &#123;            System.out.printf(&quot;%02d &quot;, selectedBalls.get(i));            if (i == selectedBalls.size() - 2) &#123;                System.out.print(&quot;| &quot;);            &#125;        &#125;        System.out.println();    &#125;&#125;</code></pre><p>Python代码：</p><pre><code class="Python">from random import randint, sample# 初始化备选红色球red_balls = [x for x in range(1, 34)]# 选出六个红色球selected_balls = sample(red_balls, 6)# 对红色球进行排序selected_balls.sort()# 添加一个蓝色球selected_balls.append(randint(1, 16))# 输出选中的随机号码for index, ball in enumerate(selected_balls):    print(&#39;%02d&#39; % ball, end=&#39; &#39;)    if index == len(selected_balls) - 2:        print(&#39;|&#39;, end=&#39; &#39;)print()</code></pre><p>相信，看完这些例子后，你一定感受到了我选择了Python是有道理的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我为什么选择了Python&quot;&gt;&lt;a href=&quot;#我为什么选择了Python&quot; class=&quot;headerlink&quot; title=&quot;我为什么选择了Python&quot;&gt;&lt;/a&gt;我为什么选择了Python&lt;/h2&gt;&lt;p&gt;目前，Python语言的发展势头在国内国外都是不可阻</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E5%B8%B8%E8%A7%81%E5%8F%8D%E7%88%AC%E7%AD%96%E7%95%A5%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E5%B8%B8%E8%A7%81%E5%8F%8D%E7%88%AC%E7%AD%96%E7%95%A5%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/</id>
    <published>2021-10-17T13:24:56.828Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见反爬策略及应对方案"><a href="#常见反爬策略及应对方案" class="headerlink" title="常见反爬策略及应对方案"></a>常见反爬策略及应对方案</h2><ol><li><p>构造合理的HTTP请求头。</p><ul><li><p>Accept</p></li><li><p>User-Agent</p></li><li><p>Referer</p></li><li><p>Accept-Encoding</p></li><li><p>Accept-Language</p></li></ul></li><li><p>检查网站生成的Cookie。</p><ul><li>有用的插件：<a href="http://www.editthiscookie.com/">EditThisCookie</a></li><li>如何处理脚本动态生成的Cookie</li></ul></li><li><p>抓取动态内容。</p><ul><li>Selenium + WebDriver</li><li>Chrome / Firefox - Driver</li></ul></li><li><p>限制爬取的速度。</p></li><li><p>处理表单中的隐藏域。</p><ul><li>在读取到隐藏域之前不要提交表单</li><li>用RoboBrowser这样的工具辅助提交表单</li></ul></li><li><p>处理表单中的验证码。</p><ul><li><p>OCR（Tesseract） - 商业项目一般不考虑 </p></li><li><p>专业识别平台 - 超级鹰 / 云打码</p><pre><code class="Python">from hashlib import md5class ChaoClient(object):    def __init__(self, username, password, soft_id):        self.username = username        password =  password.encode(&#39;utf-8&#39;)        self.password = md5(password).hexdigest()        self.soft_id = soft_id        self.base_params = &#123;            &#39;user&#39;: self.username,            &#39;pass2&#39;: self.password,            &#39;softid&#39;: self.soft_id,        &#125;        self.headers = &#123;            &#39;Connection&#39;: &#39;Keep-Alive&#39;,            &#39;User-Agent&#39;: &#39;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&#39;,        &#125;    def post_pic(self, im, codetype):        params = &#123;            &#39;codetype&#39;: codetype,        &#125;        params.update(self.base_params)        files = &#123;&#39;userfile&#39;: (&#39;captcha.jpg&#39;, im)&#125;        r = requests.post(&#39;http://upload.chaojiying.net/Upload/Processing.php&#39;, data=params, files=files, headers=self.headers)        return r.json()if __name__ == &#39;__main__&#39;:    client = ChaoClient(&#39;用户名&#39;, &#39;密码&#39;, &#39;软件ID&#39;)    with open(&#39;captcha.jpg&#39;, &#39;rb&#39;) as file:                                                        print(client.post_pic(file, 1902))                                          </code></pre></li></ul></li><li><p>绕开“陷阱”。</p><ul><li>网页上有诱使爬虫爬取的爬取的隐藏链接（陷阱或蜜罐）</li><li>通过Selenium+WebDriver+Chrome判断链接是否可见或在可视区域</li></ul></li><li><p>隐藏身份。</p><ul><li><p>代理服务 -  快代理 / 讯代理 / 芝麻代理 / 蘑菇代理 / 云代理</p><p><a href="https://cuiqingcai.com/5094.html">《爬虫代理哪家强？十大付费代理详细对比评测出炉！》</a></p></li><li><p>洋葱路由 - 国内需要翻墙才能使用</p><pre><code class="Shell">yum -y install toruseradd admin -d /home/adminpasswd adminchown -R admin:admin /home/adminchown -R admin:admin /var/run/tortor</code></pre></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见反爬策略及应对方案&quot;&gt;&lt;a href=&quot;#常见反爬策略及应对方案&quot; class=&quot;headerlink&quot; title=&quot;常见反爬策略及应对方案&quot;&gt;&lt;/a&gt;常见反爬策略及应对方案&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构造合理的HTTP请求头。&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90%E5%8A%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90%E5%8A%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/</id>
    <published>2021-10-17T13:24:56.822Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个小例子助你彻底理解协程"><a href="#一个小例子助你彻底理解协程" class="headerlink" title="一个小例子助你彻底理解协程"></a>一个小例子助你彻底理解协程</h2><p>协程，可能是Python中最让初学者困惑的知识点之一，它也是Python中实现并发编程的一种重要方式。Python中可以使用多线程和多进程来实现并发，这两种方式相对来说是大家比较熟悉的。事实上，还有一种实现并发的方式叫做异步编程，而协程就是实现异步编程的必要方式。</p><p>所谓协程，可以简单的理解为多个相互协作的子程序。在同一个线程中，当一个子程序阻塞时，我们可以让程序马上从一个子程序切换到另一个子程序，从而避免CPU因程序阻塞而闲置，这样就可以提升CPU的利用率，相当于用一种协作的方式加速了程序的执行。所以，我们可以言简意赅的说：<strong>协程实现了协作式并发</strong>。</p><p>接下来用一个小例子帮助大家理解什么是协作式并发，先看看下面的代码。</p><pre><code class="Python">import timedef display(num):    time.sleep(1)    print(num)for num in range(10):    display(num)</code></pre><p>上面这段代码相信大家很容看懂，程序会输出0到9的数字，每隔1秒中输出一个数字，因此整个程序的执行需要大约10秒时间。值得注意的是，因为没有使用多线程或多进程，程序中只有一个执行单元，而<code>time.sleep(1)</code>的休眠操作会让整个线程停滞1秒钟，对于上面的代码来说，在这段时间里面CPU是完全闲置的没有做什么事情。</p><p>我们再来看看使用协程会发生什么事情。从Python 3.5开始，使用协程实现协作式编发有了更为便捷的语法，我们可以使用<code>async</code>来定义异步函数，可以使用<code>await</code>让一个阻塞的子程序将CPU让给与它协作的子程序。在Python 3.7中，<code>asyanc</code>和<code>await</code>成为了正式的关键字，让开发者有一种喜大普奔的感觉。我们先看看如何定义一个异步函数。</p><pre><code class="Python">import asyncioasync def display(num):    await asyncio.sleep(1)    print(num)</code></pre><p>接下来敲黑板说重点。异步函数不同于普通函数，调用普通函数会得到返回值，而调用异步函数会得到一个协程对象。我们需要将协程对象放到一个事件循环中才能达到与其他协程对象协作的效果，因为事件循环会负责处理子程序切换的操作，简单的说就是让阻塞的子程序让出CPU给可以执行的子程序。</p><p>我们先通过下面的列表生成式来代码10个协程对象，跟刚才在循环中调用display函数的道理一致。</p><pre><code class="Python">coroutines = [display(num) for num in range(10)]</code></pre><p>通过下面的代码可以获取事件循环并将协程对象放入事件循环中。</p><pre><code class="Python">loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(coroutines))loop.close()</code></pre><p>执行上面的代码会发现，10个分别会阻塞1秒钟的协程总共只阻塞了约1秒种的时间，这就说明<strong>协程对象一旦阻塞会将CPU让出而不是让CPU处于闲置状态</strong>，这样就大大的<strong>提升了CPU的利用率</strong>。而且我们还会注意到，0到9的数字并不是按照我们创建协程对象的顺序打印出来的，这正是我们想要的结果啊；另外，多次执行该程序会发现每次输出的结果都不太一样，这正是并发程序本身执行顺序不确定性造成的结果。</p><p>上面的例子来自于著名的“花书”（《Python高级并发编程》），为了让大家对协程的体会更加深刻，对原书的代码做了小的改动，这个例子虽然简单，但是它已经让你体会到了协作式并发的魅力。在商业项目中，如果需要使用协作式并发，还可以将系统默认的事件循环替换为<code>uvloop</code>提供的事件循环，这样会获得更好的性能，因为<code>uvloop</code>是基于著名的跨平台异步I/O库libuv实现的。另外，如果要做基于HTTP的网络编程，三方库<strong>aiohttp</strong>是不错的选择，它基于asyncio实现了异步的HTTP服务器和客户端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个小例子助你彻底理解协程&quot;&gt;&lt;a href=&quot;#一个小例子助你彻底理解协程&quot; class=&quot;headerlink&quot; title=&quot;一个小例子助你彻底理解协程&quot;&gt;&lt;/a&gt;一个小例子助你彻底理解协程&lt;/h2&gt;&lt;p&gt;协程，可能是Python中最让初学者困惑的知识点之一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E7%BC%96%E7%A8%8B%E6%83%AF%E4%BE%8B/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E7%BC%96%E7%A8%8B%E6%83%AF%E4%BE%8B/</id>
    <published>2021-10-17T13:24:56.819Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python编程惯例"><a href="#Python编程惯例" class="headerlink" title="Python编程惯例"></a>Python编程惯例</h2><p>“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。</p><ol><li><p>让代码既可以被导入又可以被执行。</p><pre><code class="Python">if __name__ == &#39;__main__&#39;:</code></pre></li></ol><ol start="2"><li><p>用下面的方式判断逻辑“真”或“假”。</p><pre><code class="Python">if x:if not x:</code></pre><p><strong>好</strong>的代码：</p><pre><code class="Python">name = &#39;jackfrued&#39;fruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]owners = &#123;&#39;1001&#39;: &#39;骆昊&#39;, &#39;1002&#39;: &#39;王大锤&#39;&#125;if name and fruits and owners:    print(&#39;I love fruits!&#39;)</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">name = &#39;jackfrued&#39;fruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]owners = &#123;&#39;1001&#39;: &#39;骆昊&#39;, &#39;1002&#39;: &#39;王大锤&#39;&#125;if name != &#39;&#39; and len(fruits) &gt; 0 and owners != &#123;&#125;:    print(&#39;I love fruits!&#39;)</code></pre></li><li><p>善于使用in运算符。</p><pre><code class="Python">if x in items: # 包含for x in items: # 迭代</code></pre><p><strong>好</strong>的代码：</p><pre><code class="Python">name = &#39;Hao LUO&#39;if &#39;L&#39; in name:    print(&#39;The name has an L in it.&#39;)</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">name = &#39;Hao LUO&#39;if name.find(&#39;L&#39;) != -1:    print(&#39;This name has an L in it!&#39;)</code></pre></li><li><p>不使用临时变量交换两个值。</p><pre><code class="Python">a, b = b, a</code></pre></li><li><p>用序列构建字符串。</p><p><strong>好</strong>的代码：</p><pre><code class="Python">chars = [&#39;j&#39;, &#39;a&#39;, &#39;c&#39;, &#39;k&#39;, &#39;f&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;, &#39;d&#39;]name = &#39;&#39;.join(chars)print(name)  # jackfrued</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">chars = [&#39;j&#39;, &#39;a&#39;, &#39;c&#39;, &#39;k&#39;, &#39;f&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;, &#39;d&#39;]name = &#39;&#39;for char in chars:    name += charprint(name)  # jackfrued</code></pre></li><li><p>EAFP优于LBYL。</p><p>EAFP - <strong>E</strong>asier to <strong>A</strong>sk <strong>F</strong>orgiveness than <strong>P</strong>ermission.</p><p>LBYL - <strong>L</strong>ook <strong>B</strong>efore <strong>Y</strong>ou <strong>L</strong>eap.</p><p><strong>好</strong>的代码：</p><pre><code class="Python">d = &#123;&#39;x&#39;: &#39;5&#39;&#125;try:    value = int(d[&#39;x&#39;])    print(value)except (KeyError, TypeError, ValueError):    value = None</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">d = &#123;&#39;x&#39;: &#39;5&#39;&#125;if &#39;x&#39; in d and isinstance(d[&#39;x&#39;], str) \        and d[&#39;x&#39;].isdigit():    value = int(d[&#39;x&#39;])    print(value)else:    value = None</code></pre></li><li><p>使用enumerate进行迭代。</p><p><strong>好</strong>的代码：</p><pre><code class="Python">fruits = [&#39;orange&#39;, &#39;grape&#39;, &#39;pitaya&#39;, &#39;blueberry&#39;]for index, fruit in enumerate(fruits):    print(index, &#39;:&#39;, fruit)</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">fruits = [&#39;orange&#39;, &#39;grape&#39;, &#39;pitaya&#39;, &#39;blueberry&#39;]index = 0for fruit in fruits:    print(index, &#39;:&#39;, fruit)    index += 1</code></pre></li><li><p>用生成式生成列表。</p><p><strong>好</strong>的代码：</p><pre><code class="Python">data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10]print(result)  # [60, 45, 33]</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">data = [7, 20, 3, 15, 11]result = []for i in data:    if i &gt; 10:        result.append(i * 3)print(result)  # [60, 45, 33]</code></pre></li><li><p>用zip组合键和值来创建字典。</p><p><strong>好</strong>的代码：</p><pre><code class="Python">keys = [&#39;1001&#39;, &#39;1002&#39;, &#39;1003&#39;]values = [&#39;骆昊&#39;, &#39;王大锤&#39;, &#39;白元芳&#39;]d = dict(zip(keys, values))print(d)</code></pre><p><strong>不好</strong>的代码：</p><pre><code class="Python">keys = [&#39;1001&#39;, &#39;1002&#39;, &#39;1003&#39;]values = [&#39;骆昊&#39;, &#39;王大锤&#39;, &#39;白元芳&#39;]d = &#123;&#125;for i, key in enumerate(keys):    d[key] = values[i]print(d)</code></pre></li></ol><blockquote><p><strong>说明</strong>：这篇文章的内容来自于网络，有兴趣的读者可以阅读<a href="http://safehammad.com/downloads/python-idioms-2014-01-16.pdf">原文</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python编程惯例&quot;&gt;&lt;a href=&quot;#Python编程惯例&quot; class=&quot;headerlink&quot; title=&quot;Python编程惯例&quot;&gt;&lt;/a&gt;Python编程惯例&lt;/h2&gt;&lt;p&gt;“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-10-17T13:24:56.817Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python数据分析师面试题"><a href="#Python数据分析师面试题" class="headerlink" title="Python数据分析师面试题"></a>Python数据分析师面试题</h2><h3 id="基础知识部分"><a href="#基础知识部分" class="headerlink" title="基础知识部分"></a>基础知识部分</h3><h3 id="编程能力部分"><a href="#编程能力部分" class="headerlink" title="编程能力部分"></a>编程能力部分</h3><h3 id="商业项目部分"><a href="#商业项目部分" class="headerlink" title="商业项目部分"></a>商业项目部分</h3><ol><li>近期公司的X指标出现了明显的下滑，说说你会如果系统化的分析指标下滑的原因。</li><li>公司对App进行了版本迭代，对X功能做出了调整，请说明你会如何评估改版的效果。</li><li>公司对App做了一次营销拉新活动，请说明你会如何评估本次拉新活动的效果。</li><li>请说说你在设计数据报表时一般会考虑哪些问题。</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python数据分析师面试题&quot;&gt;&lt;a href=&quot;#Python数据分析师面试题&quot; class=&quot;headerlink&quot; title=&quot;Python数据分析师面试题&quot;&gt;&lt;/a&gt;Python数据分析师面试题&lt;/h2&gt;&lt;h3 id=&quot;基础知识部分&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D/</id>
    <published>2021-10-17T13:24:56.815Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python参考书籍"><a href="#Python参考书籍" class="headerlink" title="Python参考书籍"></a>Python参考书籍</h2><h3 id="入门读物"><a href="#入门读物" class="headerlink" title="入门读物"></a>入门读物</h3><ol><li>《Python基础教程》（<em>Beginning Python From Novice to Professional</em>）</li><li>《Python学习手册》（<em>Learning Python</em>）</li><li>《Python编程》（<em>Programming Python</em>）</li><li>《Python Cookbook》</li><li>《Python程序设计》（<em>Python Programming: An Introduction to Computer Science</em>）</li><li>《Modern Python Cookbook》</li></ol><h3 id="进阶读物"><a href="#进阶读物" class="headerlink" title="进阶读物"></a>进阶读物</h3><ol><li>《Python核心编程》（<em>Core Python Applications Programming</em>）</li><li>《流畅的Python》（<em>Fluent Python</em>）</li><li>《Effective Python：编写高质量Python代码的59个有效方法》（<em>Effective Python 59 Specific Ways to Write Better Python</em>）</li><li>《Python设计模式》（<em>Learning Python Design Patterns</em>）</li><li>《Python高级编程》（<em>Expert Python Programming</em>）</li><li>《Python性能分析与优化》（<em>Mastering Python High Performance</em>）</li></ol><h3 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h3><ol><li>《Django基础教程》（<em>Tango with Django</em>）</li><li>《轻量级Django》（<em>Lightweight Django</em>）</li><li>《Python Web开发：测试驱动方法》（<em>Test-Driven Development with Python</em>）</li><li>《Web Development with Django Cookbook》</li><li>《Test-Driven Development with Django》</li><li>《Django Project Blueprints 》</li><li>《Flask Web开发：基于Python的Web应用开发实战》（<em>Flask Web Development: Developing Web Applications with Python</em>）</li><li>《深入理解Flask》（<em>Mastering Flask</em>）</li></ol><h3 id="爬虫开发"><a href="#爬虫开发" class="headerlink" title="爬虫开发"></a>爬虫开发</h3><ol><li>《用Python写网络爬虫》（<em>Web Scraping with Python</em>）</li><li>《精通Python爬虫框架Scrapy》（<em>Learning Scrapy</em>）</li><li>《Python网络数据采集》（<em>Web Scraping with Python</em>）</li><li>《Python爬虫开发与项目实战》</li><li>《Python 3网络爬虫开发实战》</li></ol><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ol><li>《利用Python进行数据分析》（<em>Python for Data Analysis</em>）</li><li>《Python数据科学手册》（<em>Python Data Science Handbook</em>）</li><li>《Python金融大数据分析》（<em>Python for Finance</em>）</li><li>《Python数据可视化编程实战》（<em>Python Data Visualization Cookbook</em>）</li><li>《Python数据处理》（<em>Data Wrangling with Python</em>）</li></ol><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ol><li>《Python机器学习基础教程》（<em>Introduction to Machine Learning with Python</em>）</li><li>《Python机器学习实践指南》（<em>Python Machine Learning Blueprints</em>）</li><li>《Python Machine Learning Case Studies》</li><li>《Python机器学习实践：测试驱动的开发方法》（<em>Thoughtful Machine Learning with Python A Test Driven Approach</em>）</li><li>《Python机器学习经典实例》（<em>Python Machine Learning Cookbook</em>）</li><li>《TensorFlow：实战Google深度学习框架》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python参考书籍&quot;&gt;&lt;a href=&quot;#Python参考书籍&quot; class=&quot;headerlink&quot; title=&quot;Python参考书籍&quot;&gt;&lt;/a&gt;Python参考书籍&lt;/h2&gt;&lt;h3 id=&quot;入门读物&quot;&gt;&lt;a href=&quot;#入门读物&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E4%B9%8B%E7%A6%85%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BF%BB%E8%AF%91/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/Python%E4%B9%8B%E7%A6%85%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BF%BB%E8%AF%91/</id>
    <published>2021-10-17T13:24:56.812Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zen-of-Python（Python之禅）"><a href="#Zen-of-Python（Python之禅）" class="headerlink" title="Zen of Python（Python之禅）"></a>Zen of Python（Python之禅）</h2><p>Beautiful is better than ugly. （优美比丑陋好）<br>Explicit is better than implicit.（清晰比晦涩好）<br>Simple is better than complex.（简单比复杂好）<br>Complex is better than complicated.（复杂比错综复杂好）<br>Flat is better than nested.（扁平比嵌套好）<br>Sparse is better than dense.（稀疏比密集好）<br>Readability counts.（可读性很重要）<br>Special cases aren’t special enough to break the rules.（特殊情况也不应该违反这些规则）<br>Although practicality beats purity.（但现实往往并不那么完美）<br>Errors should never pass silently.（异常不应该被静默处理）<br>Unless explicitly silenced.（除非你希望如此）<br>In the face of ambiguity, refuse the temptation to guess.（遇到模棱两可的地方，不要胡乱猜测）<br>There should be one– and preferably only one –obvious way to do it.（肯定有一种通常也是唯一一种最佳的解决方案）<br>Although that way may not be obvious at first unless you’re Dutch.（虽然这种方案并不是显而易见的，因为你不是那个荷兰人^这里指的是Python之父Guido^）<br>Now is better than never.（现在开始做比不做好）<br>Although never is often better than *right* now.（不做比盲目去做好^极限编程中的YAGNI原则^）<br>If the implementation is hard to explain, it’s a bad idea.（如果一个实现方案难于理解，它就不是一个好的方案）<br>If the implementation is easy to explain, it may be a good idea.（如果一个实现方案易于理解，它很有可能是一个好的方案）<br>Namespaces are one honking great idea – let’s do more of those!（命名空间非常有用，我们应当多加利用）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Zen-of-Python（Python之禅）&quot;&gt;&lt;a href=&quot;#Zen-of-Python（Python之禅）&quot; class=&quot;headerlink&quot; title=&quot;Zen of Python（Python之禅）&quot;&gt;&lt;/a&gt;Zen of Python（Pyt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/PEP8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E7%95%AA%E5%A4%96%E7%AF%87/PEP8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</id>
    <published>2021-10-17T13:24:56.809Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PEP-8风格指南"><a href="#PEP-8风格指南" class="headerlink" title="PEP 8风格指南"></a>PEP 8风格指南</h2><p>PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的<a href="https://www.python.org/dev/peps/pep-0008/">PEP 8链接</a>中找到该文档，下面我们对该文档的关键部分做一个简单的总结。</p><h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><ol><li><u>使用空格来表示缩进而不要用制表符（Tab）。</u>这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。</li><li><u>和语法相关的每一层缩进都用4个空格来表示。</u></li><li><u>每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。</u></li><li><u>函数和类的定义，代码前后都要用两个空行进行分隔。</u></li><li><u>在同一个类中，各个方法之间应该用一个空行进行分隔。</u></li><li><u>二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。</u></li></ol><h3 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h3><p>PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。</p><ol><li><u>变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。</u></li><li><u>类中受保护的实例属性，应该以一个下划线开头。</u></li><li><u>类中私有的实例属性，应该以两个下划线开头。</u></li><li><u>类和异常的命名，应该每个单词首字母大写。</u></li><li><u>模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。</u></li><li><u>类的实例方法，应该把第一个参数命名为<code>self</code>以表示对象自身。</u></li><li><u>类的类方法，应该把第一个参数命名为<code>cls</code>以表示该类自身。</u></li></ol><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>在Python之禅（可以使用<code>import this</code>查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。</p><ol><li><u>采用内联形式的否定词，而不要把否定词放在整个表达式的前面。</u>例如<code>if a is not b</code>就比<code>if not a is b</code>更容易让人理解。</li><li>不要用检查长度的方式来判断字符串、列表等是否为<code>None</code>或者没有元素，应该用<code>if not x</code>这样的写法来检查它。</li><li><u>就算<code>if</code>分支、<code>for</code>循环、<code>except</code>异常捕获等中只有一行代码，也不要将代码和<code>if</code>、<code>for</code>、<code>except</code>等写在一起，分开写才会让代码更清晰。</u></li><li><u><code>import</code>语句总是放在文件开头的地方。</u></li><li><u>引入模块的时候，<code>from math import sqrt</code>比<code>import math</code>更好。</u></li><li><u>如果有多个<code>import</code>语句，应该将其分为三部分，从上到下分别是Python<strong>标准模块</strong>、<strong>第三方模块</strong>和<strong>自定义模块</strong>，每个部分内部应该按照模块名称的<strong>字母表顺序</strong>来排列。</u></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PEP-8风格指南&quot;&gt;&lt;a href=&quot;#PEP-8风格指南&quot; class=&quot;headerlink&quot; title=&quot;PEP 8风格指南&quot;&gt;&lt;/a&gt;PEP 8风格指南&lt;/h2&gt;&lt;p&gt;PEP是Python Enhancement Proposal的缩写，通常翻译为“P</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC06%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972-%E5%9C%A8%E6%B0%B4%E4%B8%80%E6%96%B9/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%20-%20%E5%9C%A8%E6%B0%B4%E4%B8%80%E6%96%B9/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC06%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972-%E5%9C%A8%E6%B0%B4%E4%B8%80%E6%96%B9/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%972%20-%20%E5%9C%A8%E6%B0%B4%E4%B8%80%E6%96%B9/</id>
    <published>2021-10-17T13:24:56.748Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法入门系列2-在水一方"><a href="#算法入门系列2-在水一方" class="headerlink" title="算法入门系列2 - 在水一方"></a>算法入门系列2 - 在水一方</h2><p>在第一次的公开课中，我们讲到了穷举法。穷举法也被称为暴力搜索法，今天我们要讲的回溯法就是暴力搜索法的一种。接下来我们讲到的很多算法跟“递归”这个概念有或多或少的关系，所以我们先说说“递归”。</p><h3 id="现实中的递归"><a href="#现实中的递归" class="headerlink" title="现实中的递归"></a>现实中的递归</h3><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……</p><p>野比大雄在房间里，用时光电视看着未来的情况。电视画面中，野比大雄在房间里，用时光电视看着未来的情况。电视画面中，野比大雄在房间里，用时光电视看着未来的情况……</p><p>阶乘的递归定义：$$0! = 1$$，$$n!=n*(n-1)!$$ ，使用被定义对象的自身来为其下定义称为递归定义。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94">德罗斯特效应</a>是递归的一种视觉形式。图中女性手持的物体中有一幅她本人手持同一物体的小图片，进而小图片中还有更小的一幅她手持同一物体的图片……</p><p><img src="./res/droste.png"></p><h3 id="递归的应用"><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h3><p>在程序中，一个函数如果直接或者间接的调用了自身，我们就称之为递归函数。</p><p>写递归函数有两个要点：</p><ol><li>收敛条件 - 什么时候结束递归。</li><li>递归公式 - 每一项与前一项（前<em>N</em>项）的关系。</li></ol><p>例子1：求阶乘。</p><pre><code class="Python">def fac(num):    if num == 0:        return 1    return num * fac(num - 1)</code></pre><p>Python对递归的深度加以了限制（默认1000层函数调用），如果想突破这个限制，可以使用下面的方法。</p><pre><code class="Python">import syssys.setrecursionlimit(10000)</code></pre><p>例子2：爬楼梯 - 楼梯有<em>n</em>个台阶，一步可以走1阶、2阶或3阶，走完<em>n</em>个台阶共有多少种不同的走法。</p><pre><code class="Python">def climb(num):    if num == 0:        return 1    elif num &lt; 0:        return 0    return climb(num - 1) + climb(num - 2) + climb(num - 3)</code></pre><p><strong>注意</strong>：上面的递归函数性能会非常的差，因为时间复杂度是几何级数级的。</p><p>优化后的代码。</p><pre><code class="Python">from functools import lru_cache@lru_cache()def climb(num):    if num == 0:        return 1    elif num &lt; 0:        return 0    return climb(num - 1) + climb(num - 2) + climb(num - 3)</code></pre><p>不使用的递归的代码。</p><pre><code class="Python">def climb(num):    a, b, c = 1, 2, 4    for _ in range(num - 1):        a, b, c = b, c, a + b + c    return a</code></pre><p><strong>重点</strong>：有更好的办法的时候，请不要考虑递归。</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p><strong>回溯法</strong>是<a href="https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E5%B0%8B%E6%B3%95">暴力搜索法</a>中的一种。对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。</p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><p>例子1：<strong>迷宫寻路</strong>。</p><p><img src="./res/maze.png"></p><pre><code class="Python">&quot;&quot;&quot;迷宫寻路&quot;&quot;&quot;import randomimport sysWALL = -1ROAD = 0ROWS = 10COLS = 10def find_way(maze, i=0, j=0, step=1):    &quot;&quot;&quot;走迷宫&quot;&quot;&quot;    if 0 &lt;= i &lt; ROWS and 0 &lt;= j &lt; COLS and maze[i][j] == 0:        maze[i][j] = step        if i == ROWS - 1 and j == COLS - 1:            print(&#39;=&#39; * 20)            display(maze)            sys.exit(0)        find_way(maze, i + 1, j, step + 1)        find_way(maze, i, j + 1, step + 1)        find_way(maze, i - 1, j, step + 1)        find_way(maze, i, j - 1, step + 1)        maze[i][j] = ROADdef reset(maze):    &quot;&quot;&quot;重置迷宫&quot;&quot;&quot;    for i in range(ROWS):        for j in range(COLS):            num = random.randint(1, 10)            maze[i][j] = WALL if num &gt; 7 else ROAD    maze[0][0] = maze[ROWS - 1][COLS - 1] = ROADdef display(maze):    &quot;&quot;&quot;显示迷宫&quot;&quot;&quot;    for row in maze:        for col in row:            if col == -1:                print(&#39;■&#39;, end=&#39; &#39;)            elif col == 0:                print(&#39;□&#39;, end=&#39; &#39;)            else:                print(f&#39;&#123;col&#125;&#39;.ljust(2), end=&#39;&#39;)        print()def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    maze = [[0] * COLS for _ in range(ROWS)]    reset(maze)    display(maze)    find_way(maze)    print(&#39;没有出路!!!&#39;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>说明：</strong>上面的代码用随机放置围墙的方式来生成迷宫，更好的生成迷宫的方式请参考<a href="https://indienova.com/indie-game-development/generate-tile-based-maze-with-backtracking/">《简单的使用回溯法生成 Tile Based 迷宫》</a>一文。</p><p>例子2：<strong>骑士巡逻</strong> - 国际象棋中的骑士（马），按照骑士的移动规则走遍整个棋盘的每一个方格，而且每个方格只能够经过一次。</p><p><img src="./res/knight_tour.gif"></p><pre><code class="Python">&quot;&quot;&quot;骑士巡逻&quot;&quot;&quot;import sysSIZE = 8def display(board):    &quot;&quot;&quot;显示棋盘&quot;&quot;&quot;    for row in board:        for col in row:            print(f&#39;&#123;col&#125;&#39;.rjust(2, &#39;0&#39;), end=&#39; &#39;)        print()def patrol(board, i=0, j=0, step=1):    &quot;&quot;&quot;巡逻&quot;&quot;&quot;    if 0 &lt;= i &lt; SIZE and 0 &lt;= j &lt; SIZE and board[i][j] == 0:        board[i][j] = step        if step == SIZE * SIZE:            display(board)            sys.exit(0)        patrol(board, i + 1, j + 2, step + 1)        patrol(board, i + 2, j + 1, step + 1)        patrol(board, i + 2, j - 1, step + 1)        patrol(board, i + 1, j - 2, step + 1)        patrol(board, i - 1, j - 2, step + 1)        patrol(board, i - 2, j - 1, step + 1)        patrol(board, i - 2, j + 1, step + 1)        patrol(board, i - 1, j + 2, step + 1)        board[i][j] = 0def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    board = [[0] * SIZE for _ in range(SIZE)]    patrol(board)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>例子3：<strong>八皇后</strong> - 如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。</p><p><img src="./res/eight_queen.png"></p><p><strong>说明</strong>：这个问题太经典了，网上有大把的答案，留给大家自己搞定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法入门系列2-在水一方&quot;&gt;&lt;a href=&quot;#算法入门系列2-在水一方&quot; class=&quot;headerlink&quot; title=&quot;算法入门系列2 - 在水一方&quot;&gt;&lt;/a&gt;算法入门系列2 - 在水一方&lt;/h2&gt;&lt;p&gt;在第一次的公开课中，我们讲到了穷举法。穷举法也被称为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC05%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971-%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971-%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC05%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971-%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%971-%E5%91%A8%E8%80%8C%E5%A4%8D%E5%A7%8B/</id>
    <published>2021-10-17T13:24:56.711Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法入门系列课程1-周而复始"><a href="#算法入门系列课程1-周而复始" class="headerlink" title="算法入门系列课程1 - 周而复始"></a>算法入门系列课程1 - 周而复始</h2><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><ol><li><p>什么是算法？</p><p>解决问题的正确方法和具体的实施步骤。</p><p>例子1：如何在两栋相距50m的大楼的两个房间牵一条线（两个房间都有窗）？</p><ul><li>养一只鸟（如鸽子），将线送过去</li><li>用很长的杆子将线递过去</li><li>用无人机（遥控飞行器）将线送过去</li></ul><p>如何评价这些方法的好坏？<strong>少花钱，不费事</strong>！</p><p>例子2：大教室里坐了几百名学生一起听课，如何快速的统计学生人数？</p><p>例子3：向列表容器中<strong>逆向</strong>插入100000个元素。</p><ul><li><p>方法1：</p><pre><code class="Python">nums = []for i in range(100000):    nums.append(i)nums.reverse()</code></pre></li><li><p>方法2：</p><pre><code class="Python">nums = []for i in range(100000):    nums.insert(0, i)</code></pre></li></ul><p>例子3：生成Fibonacci数列（前100个Fibonacci数）。</p><ul><li><p>方法1 - 递推：</p><pre><code class="Python">a, b = 0, 1for num in range(1, 101):    a, b = b, a + b    print(f&#39;&#123;num&#125;: &#123;a&#125;&#39;)</code></pre></li><li><p>方法2 - 递归：</p><pre><code class="Python">def fib(num):    if num in (1, 2):        return 1    return fib(num - 1) + fib(num - 2)for num in range(1, 101):    print(f&#39;&#123;num&#125;: &#123;fib(num)&#125;&#39;)</code></pre></li><li><p>方法3 - 改进的递归：</p><pre><code class="Python">def fib(num, temp=&#123;&#125;):    if num in (1, 2):        return 1    elif num not in temp:        temp[num] = fib(num - 1) + fib(num - 2)    return temp[num]</code></pre></li><li><p>方法4  - 改进的递归：</p><pre><code class="Python">from functools import lru_cache@lru_cache()def fib(num):    if num in (1, 2):        return 1    return fib(num - 1) + fib(num - 2)</code></pre></li></ul></li><li><p>如何评价算法的好坏？</p><p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">渐近时间复杂度</a>和渐近空间复杂度。</p></li><li><p>大<em><strong>O</strong></em>符号的意义？</p><p>表示一个函数相对于输入规模的增长速度，也可以称之为函数的数量级。</p><table><thead><tr><th>大<em>O</em>符号</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>$$O(c)$$</td><td>常量时间复杂度</td><td>布隆过滤器 / 哈希存储</td></tr><tr><td>$$O(log_2n)$$</td><td>对数时间复杂度</td><td>二分查找（折半查找）</td></tr><tr><td>$$O(n)$$</td><td>线性时间复杂度</td><td>顺序查找 / 桶排序</td></tr><tr><td>$$O(n*log_2n)$$</td><td>对数线性时间复杂度</td><td>高级排序算法（归并排序、快速排序）</td></tr><tr><td>$$O(n^2)$$</td><td>平方时间复杂度</td><td>简单排序算法（选择排序、插入排序、冒泡排序）</td></tr><tr><td>$$O(n^3)$$</td><td>立方时间复杂度</td><td>Floyd算法 / 矩阵乘法运算</td></tr><tr><td>$$O(2^n)$$</td><td>几何级数时间复杂度</td><td>汉诺塔</td></tr><tr><td>$$O(n!)$$</td><td>阶乘时间复杂度</td><td>旅行经销商问题</td></tr></tbody></table></li></ol><h3 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h3><p>在计算机科学中，<strong>穷举法</strong>或者<strong>暴力搜索法</strong>是一个非常非常直观的解决问题的方法，这种方法通过一项一项的列举解决方案所有可能的候选项以及检查每个候选项是否符合问题的描述，最终得到问题的解。</p><p>虽然暴力搜索很容易实现，并且如果解决方案存在它就一定能够找到，但是它的代价是和候选方案的数量成比例的，由于这一点，在很多实际问题中，消耗的代价会随着问题规模的增加而快速地增长。因此，当问题规模有限或当存在可用于将候选解决方案的集合减少到可管理大小时，就可以使用暴力搜索。另外，当实现方法的简单度比速度更重要的时候，也可以考虑使用这种方法。</p><h3 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h3><ol><li><p><strong>百钱百鸡</strong>问题：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100元买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p><pre><code class="Python">for x in range(21):    for y in range(34):        z = 100 - x - y        if z % 3 == 0 and 5 * x + 3 * y + z // 3 == 100:            print(x, y, z)</code></pre></li><li><p><strong>五人分鱼</strong>问题：ABCDE五人在某天夜里合伙捕鱼，最后疲惫不堪各自睡觉。第二天A第一个醒来，他将鱼分为5份，扔掉多余的1条，拿走了属于自己的一份；B第二个醒来，也将鱼分为5份，扔掉多余的1条，拿走属于自己的一份；然后C、D、E依次醒来，也按同样的方式分鱼，问他们至少捕了多少条鱼？</p><pre><code class="Python">fish = 6while True:    total = fish    enough = True    for _ in range(5):        if (total - 1) % 5 == 0:            total = (total - 1) // 5 * 4        else:            enough = False            break    if enough:        print(fish)        break    fish += 5</code></pre></li><li><p><strong>暴力破解口令</strong>：</p><pre><code class="Python">import reimport PyPDF2with open(&#39;Python_Tricks_encrypted.pdf&#39;, &#39;rb&#39;) as pdf_file_stream:    reader = PyPDF2.PdfFileReader(pdf_file_stream)    with open(&#39;dictionary.txt&#39;, &#39;r&#39;) as txt_file_stream:        file_iter = iter(lambda: txt_file_stream.readline(), &#39;&#39;)        for word in file_iter:            word = re.sub(r&#39;\s&#39;, &#39;&#39;, word)            if reader.decrypt(word):                print(word)                break</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法入门系列课程1-周而复始&quot;&gt;&lt;a href=&quot;#算法入门系列课程1-周而复始&quot; class=&quot;headerlink&quot; title=&quot;算法入门系列课程1 - 周而复始&quot;&gt;&lt;/a&gt;算法入门系列课程1 - 周而复始&lt;/h2&gt;&lt;h3 id=&quot;算法概述&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC04%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E5%A5%BD%E7%8E%A9%E7%9A%84Python/%E5%A5%BD%E7%8E%A9%E7%9A%84Python/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E7%AC%AC04%E6%AC%A1%E5%85%AC%E5%BC%80%E8%AF%BE-%E5%A5%BD%E7%8E%A9%E7%9A%84Python/%E5%A5%BD%E7%8E%A9%E7%9A%84Python/</id>
    <published>2021-10-17T13:24:56.670Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="好玩的Python"><a href="#好玩的Python" class="headerlink" title="好玩的Python"></a>好玩的Python</h2><p>因为下面的代码都非常简单，简单到直接使用Python的交互式环境就能完成。当然，官方Python自带的交互式环境比较难用，推荐大家使用ipython，可以使用下面的命令来安装ipython，安装成功后键入ipython命令就能进入交互式环境。</p><pre><code class="Shell">pip install ipython</code></pre><p>或</p><pre><code class="Shell">pip3 install ipython</code></pre><p>ipython最直观的优点：</p><ol><li>可以用?或者??来获取帮助。</li><li>可以用!调用系统命令。</li><li>可以使用Tab键自动补全。</li><li>可以使用魔法指令，如：%timeit。</li></ol><h3 id="没有工具用代码也能P图"><a href="#没有工具用代码也能P图" class="headerlink" title="没有工具用代码也能P图"></a>没有工具用代码也能P图</h3><ol><li><p>安装pillow三方库。</p><p>PIL（Python Imaging Library）是Python平台事实上的图像处理标准库了。PIL功能非常强大，而API却非常简单易用。但是PIL仅支持到Python 2.7，而且很多年都没有人维护了，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫<a href="https://github.com/python-pillow/Pillow">Pillow</a>，除了支持Python 3.x还加入了很多有用且有趣的新特性。</p><pre><code class="Shell">pip install pillow</code></pre><p>或</p><pre><code class="Shell">pip3 install pillow</code></pre></li><li><p>加载图片。</p><pre><code class="Python">from PIL import Imagechiling = Image.open(&#39;chiling.jpg&#39;)chiling.show()</code></pre></li><li><p>使用滤镜。</p><pre><code class="Shell">from PIL import ImageFilterchiling.filter(ImageFilter.EMBOSS).show()chiling.filter(ImageFilter.CONTOUR).show()</code></pre></li><li><p>图像剪裁和粘贴。</p><pre><code class="Python">rect = 220, 690, 265, 740 watch = chiling.crop(rect)watch.show()blured_watch = watch.filter(ImageFilter.GaussianBlur(4))chiling.paste(blured_watch, (220, 690))chiling.show()</code></pre></li><li><p>生成镜像。</p><pre><code class="Python">chiling2 = chiling.transpose(Image.FLIP_LEFT_RIGHT)chiling2.show()</code></pre></li><li><p>生成缩略图。</p><pre><code class="Python">width, height = chiling.sizewidth, height = int(width * 0.4), int(height * 0.4)chiling.thumbnail((width, height))</code></pre></li><li><p>合成图片。</p><pre><code class="Python">frame = Image.open(&#39;frame.jpg&#39;)frame.show()frame.paste(chiling, (210, 150))frame.paste(chiling2, (522, 150))frame.show()</code></pre></li></ol><p>上面的知识在<a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a>项目的<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/15.%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86.md">第15天</a>中也有对应的内容。</p><h3 id="向微信好友群发祝福视频"><a href="#向微信好友群发祝福视频" class="headerlink" title="向微信好友群发祝福视频"></a>向微信好友群发祝福视频</h3><ol><li><p>安装itchat三方库。</p><p><a href="https://itchat.readthedocs.io/zh/latest/">itchat</a>是一个开源的微信个人号接口，使用Python调用微信从未如此简单。</p><pre><code class="Shell">pip install itchat</code></pre><p>或</p><pre><code class="Shell">pip3 install itchat</code></pre></li><li><p>登录微信。</p><pre><code class="Python">import itchatitchat.auto_login()</code></pre><blockquote><p>说明：用自己的微信扫描屏幕上出现的二维码就完成了登录操作，登录之后才能获取自己的好友信息以及发送消息给自己的好友。</p></blockquote></li><li><p>查找自己的朋友。</p><pre><code class="Python">friends_list = itchat.get_friends(update=True)print(len(friends_list))luohao = friends_list[0]props = [&#39;NickName&#39;, &#39;Signature&#39;, &#39;Sex&#39;]for prop in props:    print(luohao[prop])</code></pre><blockquote><p>说明：friends_list相当于是一个列表，列表中的第一个元素是自己。</p></blockquote></li><li><p>随机选出5个朋友，获得他们的用户名、昵称、签名。</p><pre><code class="Python">lucky_friends = random.sample(friends_list[1:], 5) props = [&#39;NickName&#39;, &#39;Signature&#39;, &#39;City&#39;]for friend in lucky_friends:    for prop in props:        print(friend[prop] or &#39;没有此项信息&#39;)        print(&#39;-&#39; * 80)</code></pre></li><li><p>给朋友发送文字消息。</p><pre><code class="Python">itchat.send_msg(&#39;急需一个红包来拯救堕落的灵魂！！！&#39;, toUserName=&#39;@8e06606db03f0e28d0ff884083f727e6&#39;)</code></pre></li><li><p>群发视频给幸运的朋友们。</p><pre><code class="Python">lucky_friends = random.sample(friends_list[1:], 5) for friend in lucky_friends:    username = friend[&#39;UserName&#39;]    itchat.send_video(&#39;/Users/Hao/Desktop/my_test_video.mp4&#39;, toUserName=username)</code></pre></li></ol><p>利用itchat还能做很多事情，比如有好友给自己发了消息又撤回了，如果想查看这些被撤回的消息，itchat就可以做到（注册一个接收消息的钩子函数，请参考<a href="https://blog.csdn.net/enweitech/article/details/79585043">CSDN上的一篇文章</a>）；再比如，有时候我们想知道某个好友有没有把我们删除或者拉入黑名单，也可以利用itchat封装的群聊功能，非好友和黑名单用户不会被拉入群聊，通过创建群聊函数的返回值就可以判定你和指定的人之间的关系。</p><h3 id="不用客户端查看热点新闻"><a href="#不用客户端查看热点新闻" class="headerlink" title="不用客户端查看热点新闻"></a>不用客户端查看热点新闻</h3><ol><li><p>安装requests库。（点击常看<a href="https://2.python-requests.org/zh_CN/latest/">官方文档</a>）</p><p><img src="./res/requests.png"></p><pre><code class="Shell">pip install requests</code></pre><p>或</p><pre><code class="Shell">pip3 install requests</code></pre></li><li><p>爬取新闻数据或者通过API接口获取新闻数据。</p><pre><code class="Python">import requestsresp = requests.get(&#39;http://api.tianapi.com/allnews/?key=请使用自己申请的Key&amp;col=7&amp;num=50&#39;)</code></pre><blockquote><p>说明：上面使用了天行数据提供的数据接口，需要的话可以自行去<a href="https://www.tianapi.com/">天行数据</a>的网站注册开通，调用接口的时候要填写注册成功后系统分配给你的key。</p></blockquote></li><li><p>使用反序列化将JSON字符串解析为字典并获取新闻列表。</p><pre><code class="Python">import jsonnewslist = json.loads(resp.text)[&#39;newslist&#39;]</code></pre></li><li><p>对新闻列表进行循环遍历，找到感兴趣的新闻，例如：华为。</p><pre><code class="Python">for news in newslist:    title = news[&#39;title&#39;]    url = news[&#39;url&#39;]    if &#39;华为&#39; in title:        print(title)        print(url)</code></pre></li><li><p>调用短信网关发送短信到手机上，告知关注的新闻标题并给出链接。</p><pre><code class="Python">import repattern = re.compile(r&#39;https*:\/\/[^\/]*\/(?P&lt;url&gt;.*)&#39;) matcher = pattern.match(url)if matcher:    url = matcher.group(&#39;url&#39;)    resp = requests.post(        url=&#39;http://sms-api.luosimao.com/v1/send.json&#39;,        auth=(&#39;api&#39;, &#39;key-请使用你自己申请的Key&#39;),        data=&#123;            &#39;mobile&#39;: &#39;13548041193&#39;,            &#39;message&#39;: f&#39;发现一条您可能感兴趣的新闻 - &#123;title&#125;，详情点击https://news.china.com/&#123;url&#125; 查看。【Python小课】&#39;        &#125;,        timeout=10,        verify=False    )</code></pre><blockquote><p>说明：上面的代码使用了<a href="https://luosimao.com/">螺丝帽</a>提供的短信网关服务，利用短信网关发送短信是需要支付费用的，但是一般的平台都会提供若干条免费的测试短信。发送短信必须遵守平台的规则，违规的短信是无法发送的。上面发短信时使用的短信模板（“发现一条您可能感兴趣的新闻 - ###，详情点击<a href="https://news.china.com/###">https://news.china.com/###</a> 查看。”）和短信签名（“【Python小课】”）需要登录螺丝帽管理平台进行配置，如果不清楚如何配置，可以联系平台的客服人员进行咨询。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;好玩的Python&quot;&gt;&lt;a href=&quot;#好玩的Python&quot; class=&quot;headerlink&quot; title=&quot;好玩的Python&quot;&gt;&lt;/a&gt;好玩的Python&lt;/h2&gt;&lt;p&gt;因为下面的代码都非常简单，简单到直接使用Python的交互式环境就能完成。当然，官方</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E5%B9%B4%E8%96%AA50W+%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/%E5%B9%B4%E8%96%AA50W+%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%96%87%E6%A1%A3/%E5%B9%B4%E8%96%AA50W+%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/%E5%B9%B4%E8%96%AA50W+%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2021-10-17T13:24:56.356Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="年薪50W-的Python程序员如何写代码"><a href="#年薪50W-的Python程序员如何写代码" class="headerlink" title="年薪50W+的Python程序员如何写代码"></a>年薪50W+的Python程序员如何写代码</h2><h3 id="为什么要用Python写代码"><a href="#为什么要用Python写代码" class="headerlink" title="为什么要用Python写代码"></a>为什么要用Python写代码</h3><h4 id="没有对比就没有伤害"><a href="#没有对比就没有伤害" class="headerlink" title="没有对比就没有伤害"></a>没有对比就没有伤害</h4><blockquote><p><strong>很多互联网和移动互联网企业对开发效率的要求高于对执行效率的要求</strong>。</p></blockquote><h5 id="例子1：hello-world"><a href="#例子1：hello-world" class="headerlink" title="例子1：hello, world"></a>例子1：hello, world</h5><p>C的版本：</p><pre><code class="C">#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;hello, world\n&quot;);    return 0;&#125;</code></pre><p>Java的版本：</p><pre><code class="Java">class Example01 &#123;        public static void main(String[] args) &#123;        System.out.println(&quot;hello, world&quot;);    &#125;&#125;</code></pre><p>Python的版本：</p><pre><code class="Python">print(&#39;hello, world&#39;)</code></pre><h5 id="例子2：1-100求和"><a href="#例子2：1-100求和" class="headerlink" title="例子2：1-100求和"></a>例子2：1-100求和</h5><p>C的版本：</p><pre><code class="C">#include &lt;stdio.h&gt;int main() &#123;    int total = 0;    for (int i = 1; i &lt;= 100; ++i) &#123;        total += i;    &#125;    printf(&quot;%d\n&quot;, total);    return 0;&#125;</code></pre><p>Python的版本：</p><pre><code class="Java">print(sum(range(1, 101)))</code></pre><h5 id="例子3：创建和初始化数组（列表）"><a href="#例子3：创建和初始化数组（列表）" class="headerlink" title="例子3：创建和初始化数组（列表）"></a>例子3：创建和初始化数组（列表）</h5><p>Java的版本：</p><pre><code class="Java">import java.util.Arrays;public class Example03 &#123;    public static void main(String[] args) &#123;        boolean[] values = new boolean[10];        Arrays.fill(values, true);        System.out.println(Arrays.toString(values));        int[] numbers = new int[10];        for (int i = 0; i &lt; numbers.length; ++i) &#123;            numbers[i] = i + 1;        &#125;        System.out.println(Arrays.toString(numbers));    &#125;&#125;</code></pre><p>Python的版本：</p><pre><code class="Python">values = [True] * 10print(values)numbers = [x for x in range(1, 11)]print(numbers)</code></pre><h5 id="例子4：双色球随机选号"><a href="#例子4：双色球随机选号" class="headerlink" title="例子4：双色球随机选号"></a>例子4：双色球随机选号</h5><p>Java的版本：</p><pre><code class="Java">import java.util.List;import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;class Example03 &#123;    /**     * 产生[min, max)范围的随机整数     */    public static int randomInt(int min, int max) &#123;        return (int) (Math.random() * (max - min) + min);    &#125;        /**     * 输出一组双色球号码     */    public static void display(List&lt;Integer&gt; balls) &#123;        for (int i = 0; i &lt; balls.size(); ++i) &#123;            System.out.printf(&quot;%02d &quot;, balls.get(i));            if (i == balls.size() - 2) &#123;                System.out.print(&quot;| &quot;);            &#125;        &#125;        System.out.println();    &#125;    /**     * 生成一组随机号码     */    public static List&lt;Integer&gt; generate() &#123;        List&lt;Integer&gt; redBalls = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= 33; ++i) &#123;            redBalls.add(i);        &#125;        List&lt;Integer&gt; selectedBalls = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 6; ++i) &#123;            selectedBalls.add(redBalls.remove(randomInt(0, redBalls.size())));        &#125;        Collections.sort(selectedBalls);        selectedBalls.add(randomInt(1, 17));        return selectedBalls;    &#125;        public static void main(String[] args) &#123;        try (Scanner sc = new Scanner(System.in)) &#123;            System.out.print(&quot;机选几注: &quot;);            int num = sc.nextInt();            for (int i = 0; i &lt; num; ++i) &#123;                display(generate());            &#125;        &#125;    &#125;&#125;</code></pre><p>Python的版本：</p><pre><code class="Python">from random import randint, sampledef generate():    &quot;&quot;&quot;生成一组随机号码&quot;&quot;&quot;    red_balls = [x for x in range(1, 34)]    selected_balls = sample(red_balls, 6)    selected_balls.sort()    selected_balls.append(randint(1, 16))    return selected_ballsdef display(balls):    &quot;&quot;&quot;输出一组双色球号码&quot;&quot;&quot;    for index, ball in enumerate(balls):        print(f&#39;&#123;ball:0&gt;2d&#125;&#39;, end=&#39; &#39;)        if index == len(balls) - 2:            print(&#39;|&#39;, end=&#39; &#39;)    print()num = int(input(&#39;机选几注: &#39;))for _ in range(num):    display(generate())</code></pre><blockquote><p><strong>温馨提示</strong>：珍爱生命，远离任何形式的赌博。</p></blockquote><h5 id="例子5：实现一个简单的HTTP服务器。"><a href="#例子5：实现一个简单的HTTP服务器。" class="headerlink" title="例子5：实现一个简单的HTTP服务器。"></a>例子5：实现一个简单的HTTP服务器。</h5><p>Java的版本：</p><blockquote><p><strong>说明</strong>：JDK 1.6以前，需要通过套接字编程来实现，具体又可以分为多线程和NIO两种做法。JDK 1.6以后，可以使用<code>com.sun.net.httpserver</code>包提供的<code>HttpServer</code>类来实现。</p></blockquote><pre><code class="Java">import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.OutputStream;import java.net.InetSocketAddress;class Example05 &#123;    public static void main(String[] arg) throws Exception &#123;        HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);        server.createContext(&quot;/&quot;, new RequestHandler());        server.start();    &#125;    static class RequestHandler implements HttpHandler &#123;                @Override        public void handle(HttpExchange exchange) throws IOException &#123;            String response = &quot;&lt;h1&gt;hello, world&lt;/h1&gt;&quot;;            exchange.sendResponseHeaders(200, 0);            try (OutputStream os = exchange.getResponseBody()) &#123;                os.write(response.getBytes());            &#125;        &#125;    &#125;&#125;</code></pre><p>Python的版本：</p><pre><code class="Python">from http.server import HTTPServer, SimpleHTTPRequestHandlerclass RequestHandler(SimpleHTTPRequestHandler):    def do_GET(self):        self.send_response(200)        self.end_headers()        self.wfile.write(&#39;&lt;h1&gt;hello, world&lt;/h1&gt;&#39;.encode())server = HTTPServer((&#39;&#39;, 8000), RequestHandler)server.serve_forever()</code></pre><p>或</p><pre><code class="Python">python3 -m http.server 8000</code></pre><h4 id="一行Python代码可以做什么"><a href="#一行Python代码可以做什么" class="headerlink" title="一行Python代码可以做什么"></a>一行Python代码可以做什么</h4><blockquote><p><strong>很多时候，你的问题只需一行Python代码就能解决</strong>。</p></blockquote><pre><code class="Python"># 一行代码实现求阶乘函数fac = lambda x: __import__(&#39;functools&#39;).reduce(int.__mul__, range(1, x + 1), 1)# 一行代码实现求最大公约数函数gcd = lambda x, y: y % x and gcd(y % x, x) or x# 一行代码实现判断素数的函数is_prime = lambda x: x &gt; 1 and not [f for f in range(2, int(x ** 0.5) + 1) if x % f == 0]# 一行代码实现快速排序quick_sort = lambda items: len(items) and quick_sort([x for x in items[1:] if x &lt; items[0]]) + [items[0]] + quick_sort([x for x in items[1:] if x &gt; items[0]]) or items# 生成FizzBuzz列表[&#39;Fizz&#39;[x % 3 * 4:] + &#39;Buzz&#39;[x % 5 * 4:] or x for x in range(1, 101)]</code></pre><h4 id="设计模式从未如此简单"><a href="#设计模式从未如此简单" class="headerlink" title="设计模式从未如此简单"></a>设计模式从未如此简单</h4><blockquote><p><strong>Python是动态类型语言，大量的设计模式在Python中被简化或弱化</strong>。</p></blockquote><p>思考：如何优化下面的代码。</p><pre><code class="Python">def fib(num):    if num in (1, 2):        return 1    return fib(num - 1) + fib(num - 2)</code></pre><p>代理模式在Python中可以通过内置的或自定义的装饰器来实现。</p><pre><code class="Python">from functools import lru_cache@lru_cache()def fib(num):    if num in (1, 2):        return 1    return fib(num - 1) + fib(num - 2)for n in range(1, 121):    print(f&#39;&#123;n&#125;: &#123;fib(n)&#125;&#39;)</code></pre><blockquote><p><strong>说明</strong>：通过Python标准库<code>functools</code>模块的<code>lru_cache</code>装饰器为<code>fib</code>函数加上缓存代理，缓存函数执行的中间结果，优化代码的性能。</p></blockquote><p>单例模式在Python中可以通过自定义的装饰器或元类来实现。</p><pre><code class="Python">from functools import wrapsfrom threading import RLockdef singleton(cls):    instances = &#123;&#125;    lock = RLock()    @wraps(cls)    def wrapper(*args, **kwargs):        if cls not in instances:            with lock:                if cls not in instances:                    instances[cls] = cls(*args, **kwargs)        return instances[cls]</code></pre><blockquote><p><strong>说明</strong>：需要实现单例模式的类只需要添加上面的装饰器即可。</p></blockquote><p>原型模式在Python中可以通过元类来实现。</p><pre><code class="Python">import copyclass PrototypeMeta(type):    def __init__(cls, *args, **kwargs):        super().__init__(*args, **kwargs)        cls.clone = lambda self, is_deep=True: \            copy.deepcopy(self) if is_deep else copy.copy(self)</code></pre><blockquote><p><strong>说明</strong>：通过元类给指定了<code>metaclass=PrototypeMeta</code>的类添加一个<code>clone</code>方法实现对象克隆，利用Python标准库<code>copy</code>模块的<code>copy</code>和<code>deepcopy</code>分别实现浅拷贝和深拷贝。</p></blockquote><h4 id="数据采集和数据分析从未如此简单"><a href="#数据采集和数据分析从未如此简单" class="headerlink" title="数据采集和数据分析从未如此简单"></a>数据采集和数据分析从未如此简单</h4><blockquote><p><strong>网络数据采集是Python最擅长的领域之一。</strong></p></blockquote><p>例子：获取豆瓣电影“Top250”。</p><pre><code class="Python">import randomimport timeimport requestsfrom bs4 import BeautifulSoupfor page in range(10):    resp = requests.get(        url=f&#39;https://movie.douban.com/top250?start=&#123;25 * page&#125;&#39;,        headers=&#123;&#39;User-Agent&#39;: &#39;BaiduSpider&#39;&#125;    )    soup = BeautifulSoup(resp.text, &quot;lxml&quot;)    for elem in soup.select(&#39;a &gt; span.title:nth-child(1)&#39;):        print(elem.text)    time.sleep(random.random() * 5)</code></pre><blockquote><p><strong>利用NumPy、Pandas、Matplotlib可以轻松实现数据分析和可视化</strong>。</p></blockquote><p><img src="res/use-pandas-in-jupyter-notebook.png"></p><h3 id="写出Python代码的正确姿势"><a href="#写出Python代码的正确姿势" class="headerlink" title="写出Python代码的正确姿势"></a>写出Python代码的正确姿势</h3><blockquote><p><strong>用Python写代码就要写出Pythonic的代码</strong>。</p></blockquote><h4 id="姿势1：选择结构的正确姿势"><a href="#姿势1：选择结构的正确姿势" class="headerlink" title="姿势1：选择结构的正确姿势"></a>姿势1：选择结构的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">name = &#39;jackfrued&#39;fruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]owners = &#123;&#39;name&#39;: &#39;骆昊&#39;, &#39;age&#39;: 40, &#39;gender&#39;: True&#125;if name != &#39;&#39; and len(fruits) &gt; 0 and len(owners.keys()) &gt; 0:    print(&#39;Jackfrued love fruits.&#39;)</code></pre><p>Pythonic的代码：</p><pre><code class="Python">name = &#39;jackfrued&#39;fruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]owners = &#123;&#39;name&#39;: &#39;骆昊&#39;, &#39;age&#39;: 40, &#39;gender&#39;: True&#125;if name and fruits and owners:    print(&#39;Jackfrued love fruits.&#39;)</code></pre><h4 id="姿势2：交换两个变量的正确姿势"><a href="#姿势2：交换两个变量的正确姿势" class="headerlink" title="姿势2：交换两个变量的正确姿势"></a>姿势2：交换两个变量的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">temp = aa = bb = temp</code></pre><p>或</p><pre><code class="Python">a = a ^ bb = a ^ ba = a ^ b</code></pre><p>Pythonic的代码：</p><pre><code class="Python">a, b = b, a</code></pre><h4 id="姿势3：用序列组装字符串的正确姿势"><a href="#姿势3：用序列组装字符串的正确姿势" class="headerlink" title="姿势3：用序列组装字符串的正确姿势"></a>姿势3：用序列组装字符串的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">chars = [&#39;j&#39;, &#39;a&#39;, &#39;c&#39;, &#39;k&#39;, &#39;f&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;, &#39;d&#39;]name = &#39;&#39;for char in chars:    name += char</code></pre><p>Pythonic的代码：</p><pre><code class="Python">chars = [&#39;j&#39;, &#39;a&#39;, &#39;c&#39;, &#39;k&#39;, &#39;f&#39;, &#39;r&#39;, &#39;u&#39;, &#39;e&#39;, &#39;d&#39;]name = &#39;&#39;.join(chars)</code></pre><h4 id="姿势4：遍历列表的正确姿势"><a href="#姿势4：遍历列表的正确姿势" class="headerlink" title="姿势4：遍历列表的正确姿势"></a>姿势4：遍历列表的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">fruits = [&#39;orange&#39;, &#39;grape&#39;, &#39;pitaya&#39;, &#39;blueberry&#39;]index = 0for fruit in fruits:    print(index, &#39;:&#39;, fruit)    index += 1</code></pre><p>Pythonic的代码：</p><pre><code class="Python">fruits = [&#39;orange&#39;, &#39;grape&#39;, &#39;pitaya&#39;, &#39;blueberry&#39;]for index, fruit in enumerate(fruits):    print(index, &#39;:&#39;, fruit)</code></pre><h4 id="姿势5：创建列表的正确姿势"><a href="#姿势5：创建列表的正确姿势" class="headerlink" title="姿势5：创建列表的正确姿势"></a>姿势5：创建列表的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">data = [7, 20, 3, 15, 11]result = []for i in data:    if i &gt; 10:        result.append(i * 3)</code></pre><p>Pythonic的代码：</p><pre><code class="Python">data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10]</code></pre><h4 id="姿势6：确保代码健壮性的正确姿势"><a href="#姿势6：确保代码健壮性的正确姿势" class="headerlink" title="姿势6：确保代码健壮性的正确姿势"></a>姿势6：确保代码健壮性的正确姿势</h4><p>跨界开发者的代码：</p><pre><code class="Python">data = &#123;&#39;x&#39;: &#39;5&#39;&#125;if &#39;x&#39; in data and isinstance(data[&#39;x&#39;], (str, int, float)) \        and data[&#39;x&#39;].isdigit():    value = int(data[&#39;x&#39;])    print(value)else:    value = None</code></pre><p>Pythonic的代码：</p><pre><code class="Python">data = &#123;&#39;x&#39;: &#39;5&#39;&#125;try:    value = int(data[&#39;x&#39;])    print(value)except (KeyError, TypeError, ValueError):    value = None</code></pre><h3 id="使用Lint工具检查你的代码规范"><a href="#使用Lint工具检查你的代码规范" class="headerlink" title="使用Lint工具检查你的代码规范"></a>使用Lint工具检查你的代码规范</h3><p>阅读下面的代码，看看你能看出哪些地方是有毛病的或者说不符合Python的编程规范的。</p><pre><code class="Python">from enum import *@uniqueclass Suite (Enum):    SPADE, HEART, CLUB, DIAMOND = range(4)class Card(object):    def __init__(self,suite,face ):        self.suite = suite        self.face = face    def __repr__(self):        suites=&#39;♠♥♣♦&#39;        faces=[&#39;&#39;,&#39;A&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;10&#39;,&#39;J&#39;,&#39;Q&#39;,&#39;K&#39;]        return f&#39;&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;&#39;import randomclass Poker(object):    def __init__(self):        self.cards =[Card(suite, face) for suite in Suite            for face in range(1, 14)]        self.current=0    def shuffle (self):        self.current=0        random.shuffle(self.cards)    def deal (self):        card = self.cards[self.current]        self.current+=1        return card    def has_next (self):        if self.current&lt;len(self.cards): return True        return Falsep = Poker()p.shuffle()print(p.cards)</code></pre><h4 id="PyLint的安装和使用"><a href="#PyLint的安装和使用" class="headerlink" title="PyLint的安装和使用"></a>PyLint的安装和使用</h4><p>Pylint是Python代码分析工具，它分析Python代码中的错误，查找不符合代码风格标准（默认使用的代码风格是 PEP 8）和有潜在问题的代码。</p><pre><code class="Bash">pip install pylintpylint [options] module_or_package</code></pre><p>Pylint输出格式如下所示。</p><blockquote><p>模块名:行号:列号:    消息类型    消息</p></blockquote><p>消息类型有以下几种：</p><ol><li>C - 惯例：违反了Python编程惯例（PEP 8）的代码。</li><li>R - 重构：写得比较糟糕需要重构的代码。</li><li>W - 警告：代码中存在的不影响代码运行的问题。</li><li>E - 错误：代码中存在的影响代码运行的错误。</li><li>F - 致命错误：导致Pylint无法继续运行的错误。</li></ol><p>Pylint命令的常用参数：</p><ol><li><code>--disable=&lt;msg ids&gt;</code>或<code>-d &lt;msg ids&gt;</code>：禁用指定类型的消息。</li><li><code>--errors-only</code>或<code>-E</code>：只显示错误。</li><li><code>--rcfile=&lt;file&gt;</code>：指定配置文件。</li><li><code>--list-msgs</code>：列出Pylint的消息清单。</li><li><code>--generate-rcfile</code>：生成配置文件的样例。</li><li><code>--reports=&lt;y_or_n&gt;</code>或<code>-r &lt;y_or_n&gt;</code>：是否生成检查报告。</li></ol><h3 id="使用Profile工具剖析你的代码性能"><a href="#使用Profile工具剖析你的代码性能" class="headerlink" title="使用Profile工具剖析你的代码性能"></a>使用Profile工具剖析你的代码性能</h3><h4 id="cProfile模块"><a href="#cProfile模块" class="headerlink" title="cProfile模块"></a>cProfile模块</h4><p><code>example01.py</code></p><pre><code class="Python">import cProfiledef is_prime(num):    for factor in range(2, int(num ** 0.5) + 1):        if num % factor == 0:            return False    return Trueclass PrimeIter:    def __init__(self, total):        self.counter = 0        self.current = 1        self.total = total    def __iter__(self):        return self    def __next__(self):        if self.counter &lt; self.total:            self.current += 1            while not is_prime(self.current):                self.current += 1            self.counter += 1            return self.current        raise StopIteration()        cProfile.run(&#39;list(PrimeIter(10000))&#39;)</code></pre><p>执行结果：</p><pre><code>   114734 function calls in 0.573 seconds   Ordered by: standard name   ncalls  tottime  percall  cumtime  percall filename:lineno(function)        1    0.006    0.006    0.573    0.573 &lt;string&gt;:1(&lt;module&gt;)        1    0.000    0.000    0.000    0.000 example.py:14(__init__)        1    0.000    0.000    0.000    0.000 example.py:19(__iter__)    10001    0.086    0.000    0.567    0.000 example.py:22(__next__)   104728    0.481    0.000    0.481    0.000 example.py:5(is_prime)        1    0.000    0.000    0.573    0.573 &#123;built-in method builtins.exec&#125;        1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;</code></pre><p>####line_profiler</p><p>给需要剖析时间性能的函数加上一个<code>profile</code>装饰器，这个函数每行代码的执行次数和时间都会被剖析。</p><p><code>example02.py</code></p><pre><code class="Python">@profiledef is_prime(num):    for factor in range(2, int(num ** 0.5) + 1):        if num % factor == 0:            return False    return Trueclass PrimeIter:    def __init__(self, total):        self.counter = 0        self.current = 1        self.total = total    def __iter__(self):        return self    def __next__(self):        if self.counter &lt; self.total:            self.current += 1            while not is_prime(self.current):                self.current += 1            self.counter += 1            return self.current        raise StopIteration()list(PrimeIter(1000))</code></pre><p>安装和使用<code>line_profiler</code>三方库。</p><pre><code class="Bash">pip install line_profilerkernprof -lv example.pyWrote profile results to example02.py.lprofTimer unit: 1e-06 sTotal time: 0.089513 sFile: example02.pyFunction: is_prime at line 1 #      Hits         Time  Per Hit   % Time  Line Contents============================================================== 1                                           @profile 2                                           def is_prime(num): 3     86624      43305.0      0.5     48.4      for factor in range(2, int(num ** 0.5) + 1): 4     85624      42814.0      0.5     47.8          if num % factor == 0: 5      6918       3008.0      0.4      3.4              return False 6      1000        386.0      0.4      0.4      return True</code></pre><p>####memory_profiler </p><p>给需要剖析内存性能的函数加上一个<code>profile</code>装饰器，这个函数每行代码的内存使用情况都会被剖析。</p><p><code>example03.py</code></p><pre><code class="Python">@profiledef eat_memory():    items = []    for _ in range(1000000):        items.append(object())    return itemseat_memory()</code></pre><p>安装和使用<code>memory_profiler</code>三方库。</p><pre><code class="Python">pip install memory_profilerpython3 -m memory_profiler example.pyFilename: example03.pyLine #    Mem usage    Increment   Line Contents================================================     1   38.672 MiB   38.672 MiB   @profile     2                             def eat_memory():     3   38.672 MiB    0.000 MiB       items = []     4   68.727 MiB    0.000 MiB       for _ in range(1000000):     5   68.727 MiB    1.797 MiB           items.append(object())     6   68.727 MiB    0.000 MiB       return items</code></pre><h3 id="如何构建综合职业素养"><a href="#如何构建综合职业素养" class="headerlink" title="如何构建综合职业素养"></a>如何构建综合职业素养</h3><h4 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h4><ol><li>了解全局</li><li>确定范围</li><li>定义目标</li><li>寻找资源</li><li>创建学习计划</li><li>筛选资源</li><li>开始学习，浅尝辄止（YAGNI）</li><li>动手操作，边学边玩</li><li>全面掌握，学以致用</li><li>乐为人师，融会贯通</li></ol><h4 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h4><ol><li><p>提升专注力</p></li><li><p>充分利用碎片时间</p></li><li><p>使用番茄工作法</p></li><li><p>时间是怎么浪费掉的</p></li><li><p>任何行动都比不采取行动好</p><p><img src="res/action.png"></p></li></ol><h4 id="好书推荐"><a href="#好书推荐" class="headerlink" title="好书推荐"></a>好书推荐</h4><ol><li>职业规划：《软技能 - 代码之外的生存指南》</li><li>吴军系列：《浪潮之巅》、《硅谷之谜》、《数学之美》、……</li><li>时间管理：《成为一个更高效的人》、《番茄工作法图解》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;年薪50W-的Python程序员如何写代码&quot;&gt;&lt;a href=&quot;#年薪50W-的Python程序员如何写代码&quot; class=&quot;headerlink&quot; title=&quot;年薪50W+的Python程序员如何写代码&quot;&gt;&lt;/a&gt;年薪50W+的Python程序员如何写代码&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/Day91-100/99.%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/Day91-100/99.%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-17T13:24:56.054Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试中的公共问题"><a href="#面试中的公共问题" class="headerlink" title="面试中的公共问题"></a>面试中的公共问题</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ol><li><p>TCP/IP模型相关问题。</p><blockquote><p>建议阅读阮一峰的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门（一）》</a>和<a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">《互联网协议入门（二）》</a>。</p></blockquote></li><li><p>HTTP和HTTPS相关问题。</p><blockquote><p>建议阅读阮一峰的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a>和<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS协议运行机制的概述》</a>。</p></blockquote></li><li><p>Linux常用命令和服务。</p></li><li><p>进程和线程之间的关系。什么时候用多线程？什么时候用多进程？。</p></li><li><p>关系型数据库相关问题（ACID、事务隔离级别、锁、SQL优化）。</p></li><li><p>非关系型数据库相关问题（CAP/BASE、应用场景）。</p></li></ol><h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><ol><li><p>开发中用过哪些标准库和三方库。</p><blockquote><p>标准库：sys / os / re / math / random / logging / json / pickle / shelve / socket / datetime / hashlib / configparser / urllib / itertools / collections / functools / threading / multiprocess / timeit / atexit / abc / asyncio / base64 / concurrent.futures / copy / csv / operator / enum / heapq / http / profile / pstats / ssl / unittest / uuid</p><p>三方库：openpyxl / xlrd / xlwt / PyPDF2 / ReportLab / PyYAML / jieba / pillow / requests / urllib3 / responses / aiohttp / BeautifulSoup4 / lxml / pyquery / PyMySQL / psycopg2 / redis / PyMongo / Peewee / SQLAlchemy / alipay / PyJWT / itsdangerous / celery / flower / elasticsearch-dsl-py / PyCrypto / Paramiko / logbook / nose / pytest / coverage / Selenium / lineprofiler / memoryprofiler / matplotlib / pygal / OpenCV</p></blockquote></li><li><p>装饰器的作用、原理和实现。</p></li><li><p>使用过哪些魔法方法。</p><blockquote><p>建议阅读<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html">《Python魔术方法指南》</a>。</p></blockquote></li><li><p>生成式、生成器、迭代器的编写。</p></li><li><p>列表、集合、字典的底层实现。</p></li><li><p>垃圾回收相关问题。</p></li><li><p>并发编程的相关问题。</p></li><li><p>协程和异步I/O相关知识。</p></li></ol><h3 id="Django和Flask"><a href="#Django和Flask" class="headerlink" title="Django和Flask"></a>Django和Flask</h3><ol><li><p>MVC架构（MTV）解决了什么问题。</p></li><li><p>中间件的执行流程以及如何自定义中间件。</p></li><li><p>REST数据接口如何设计（URL、域名、版本、过滤、状态码、安全性）。</p><blockquote><p>建议阅读阮一峰的<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">《RESTful API设计指南》</a>。</p></blockquote></li><li><p>使用ORM框架实现CRUD操作的相关问题。</p><ul><li>如何实现多条件组合查询 / 如何执行原生的SQL / 如何避免N+1查询问题</li></ul></li><li><p>如何执行异步任务和定时任务。</p></li><li><p>如何实现页面缓存和查询缓存？缓存如何预热？</p></li></ol><h3 id="爬虫相关"><a href="#爬虫相关" class="headerlink" title="爬虫相关"></a>爬虫相关</h3><ol><li>Scrapy框架的组件和数据处理流程。</li><li>爬取的目的（项目中哪些地方需要用到爬虫的数据）。</li><li>使用的工具（抓包、下载、清理、存储、分析、可视化）。</li><li>数据的来源（能够轻松的列举出10个网站）。</li><li>数据的构成（抓取的某个字段在项目中有什么用）。</li><li>反反爬措施（限速、请求头、Cookie池、代理池、Selenium WebDriver、RoboBrowser、TOR、OCR）。</li><li>数据的体量（最后抓取了多少数据，多少W条数据或多少个G的数据）。</li><li>后期数据处理（持久化、数据补全、归一化、格式化、转存、分类）。</li></ol><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ol><li>科学运算函数库（SciPy和NumPy常用运算）。</li><li>数据分析库（Pandas中封装的常用算法）。</li><li>常用的模型及对应的场景（分类、回归、聚类）。</li><li>提取了哪些具体的指标。</li><li>如何评价模型的优劣。</li><li>每种模型实际操作的步骤，对结果如何评价。</li></ol><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ol><li>项目团队构成以及自己在团队中扮演的角色（在项目中的职责）。</li><li>项目的业务架构（哪些模块及子模块）和技术架构（移动端、PC端、后端技术栈）。</li><li>软件控制管理相关工具（版本控制、问题管理、持续集成）。</li><li>核心业务实体及其属性，实体与实体之间的关系。</li><li>用到哪些依赖库，依赖库主要解决哪方面的问题。</li><li>项目如何部署上线以及项目的物理架构（Nginx、Gunicorn/uWSGI、Redis、MongoDB、MySQL、Supervisor等）。</li><li>如何对项目进行测试，有没有做过性能调优。</li><li>项目中遇到的困难有哪些，如何解决的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试中的公共问题&quot;&gt;&lt;a href=&quot;#面试中的公共问题&quot; class=&quot;headerlink&quot; title=&quot;面试中的公共问题&quot;&gt;&lt;/a&gt;面试中的公共问题&lt;/h2&gt;&lt;h3 id=&quot;计算机基础&quot;&gt;&lt;a href=&quot;#计算机基础&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/17/Python-100-Days-master/Day91-100/98.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://example.com/2021/10/17/Python-100-Days-master/Day91-100/98.%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2021-10-17T13:24:56.050Z</published>
    <updated>2021-04-05T16:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目部署上线指南"><a href="#项目部署上线指南" class="headerlink" title="项目部署上线指南"></a>项目部署上线指南</h2><h3 id="准备上线"><a href="#准备上线" class="headerlink" title="准备上线"></a>准备上线</h3><ol><li><p>上线前的检查工作。</p><pre><code class="Shell">python manage.py check --deploy</code></pre></li><li><p>将DEBUG设置为False并配置ALLOWED_HOSTS。</p><pre><code class="Python">DEBUG = FalseALLOWED_HOSTS = [&#39;*&#39;]</code></pre></li><li><p>安全相关的配置。</p><pre><code class="Python"># 保持HTTPS连接的时间SECURE_HSTS_SECONDS = 3600SECURE_HSTS_INCLUDE_SUBDOMAINS = TrueSECURE_HSTS_PRELOAD = True# 自动重定向到安全连接SECURE_SSL_REDIRECT = True# 避免浏览器自作聪明推断内容类型SECURE_CONTENT_TYPE_NOSNIFF = True# 避免跨站脚本攻击SECURE_BROWSER_XSS_FILTER = True# COOKIE只能通过HTTPS进行传输SESSION_COOKIE_SECURE = TrueCSRF_COOKIE_SECURE = True# 防止点击劫持攻击手段 - 修改HTTP协议响应头# 当前网站是不允许使用&lt;iframe&gt;标签进行加载的X_FRAME_OPTIONS = &#39;DENY&#39;</code></pre></li><li><p>敏感信息放到环境变量或文件中。</p><pre><code class="Python">SECRET_KEY = os.environ[&#39;SECRET_KEY&#39;]DB_USER = os.environ[&#39;DB_USER&#39;]DB_PASS = os.environ[&#39;DB_PASS&#39;]REDIS_AUTH = os.environ[&#39;REDIS_AUTH&#39;]</code></pre></li></ol><h3 id="更新服务器Python环境到3-x"><a href="#更新服务器Python环境到3-x" class="headerlink" title="更新服务器Python环境到3.x"></a>更新服务器Python环境到3.x</h3><blockquote><p>说明：如果需要清除之前的安装，就删除对应的文件和文件夹即可</p></blockquote><ol><li><p>安装底层依赖库。</p><pre><code class="Shell">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel libdb4-devel libpcap-devel xz-devel libffi-devel</code></pre></li><li><p>下载Python源代码。</p><pre><code class="Shell">wget https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tar.xz</code></pre></li><li><p>验证下载文件。</p><pre><code class="Bash">md5sum Python-3.7.6.tar.xz</code></pre></li><li><p>解压缩和解归档。</p><pre><code class="Shell">xz -d Python-3.7.6.tar.xztar -xvf Python-3.7.6.tar</code></pre></li><li><p>执行安装前的配置（生成Makefile文件）。</p><pre><code class="Shell">cd Python-3.7.6./configure --prefix=/usr/local/python37 --enable-optimizations</code></pre></li><li><p>构建和安装。</p><pre><code class="Shell">make &amp;&amp; make install</code></pre></li><li><p>配置PATH环境变量（用户或系统环境变量）并激活。</p><pre><code class="Shell">vim ~/.bash_profilevim /etc/profile</code></pre><pre><code class="INI">... 此处省略上面的代码...export PATH=$PATH:/usr/local/python37/bin... 此处省略下面的代码...</code></pre><pre><code class="Shell">source ~/.bash_profilesource /etc/profile</code></pre></li><li><p>注册软链接（符号链接）- 这一步不是必须的，但通常会比较有用。</p><pre><code class="Shell">ln -s /usr/local/python37/bin/python3 /usr/bin/python3</code></pre></li><li><p>测试Python环境是否更新成功（安装Python 3一定不能破坏原来的Python 2）。</p><pre><code class="Shell">python3 --versionpython --version</code></pre></li></ol><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><p>假设项目文件夹为<code>project</code>，下面的五个子目录分别是：<code>code</code>、<code>conf</code>、<code>logs</code>、<code>stat</code>和<code>venv</code>分别用来保存项目的代码、配置文件、日志文件、静态资源和虚拟环境。其中，<code>conf</code>目录下的子目录<code>cert</code>中保存了配置HTTPS需要使用的证书和密钥；<code>code</code>目录下的项目代码可以通过版本控制工具从代码仓库中检出；虚拟环境可以通过工具（如：venv、virtualenv、pyenv等）进行创建。</p><pre><code>project├── code│   └── fangtx│       ├── api│       ├── common│       ├── fangtx│       ├── forum│       ├── rent│       ├── user│       ├── manage.py│       ├── README.md│       ├── static│       └── templates├── conf│   ├── cert│   │   ├── 214915882850706.key│   │   └── 214915882850706.pem│   ├── nginx.conf│   └── uwsgi.ini├── logs│   ├── access.log│   ├── error.log│   └── uwsgi.log├── stat│   └── css│   └── images│   └── js└── venv    ├── bin    │   ├── activate    │   ├── activate.csh    │   ├── activate.fish    │   ├── celery    │   ├── celerybeat    │   ├── celeryd    │   ├── celeryd-multi    │   ├── coverage    │   ├── coverage3    │   ├── coverage-3.7    │   ├── django-admin    │   ├── django-admin.py    │   ├── easy_install    │   ├── easy_install-3.7    │   ├── pip    │   ├── pip3    │   ├── pip3.7    │   ├── __pycache__    │   ├── pyrsa-decrypt    │   ├── pyrsa-decrypt-bigfile    │   ├── pyrsa-encrypt    │   ├── pyrsa-encrypt-bigfile    │   ├── pyrsa-keygen    │   ├── pyrsa-priv2pub    │   ├── pyrsa-sign    │   ├── pyrsa-verify    │   ├── python -&gt; python3    │   ├── python3 -&gt; /usr/bin/python3    │   └── uwsgi    ├── include    ├── lib    │   └── python3.7    ├── lib64 -&gt; lib    ├── pip-selfcheck.json    └── pyvenv.cfg</code></pre><p>下面以阿里云为例，简单说明如何为项目注册域名、解析域名以及购买权威机构颁发的证书。</p><ol><li><p><a href="https://wanwang.aliyun.com/domain/">注册域名</a>。</p><p><img src="./res/aliyun-domain.png"></p></li><li><p><a href="https://beian.aliyun.com/">域名备案</a>。</p><p><img src="./res/aliyun-keeprecord.png"></p></li><li><p><a href="https://dns.console.aliyun.com/#/dns/domainList">域名解析</a>。</p><p><img src="./res/aliyun-dnslist.png"></p><p><img src="./res/aliyun-resolve-settings.png"></p></li><li><p><a href="https://www.aliyun.com/product/cas">购买证书</a>。</p><p><img src="./res/aliyun-certificate.png"></p></li></ol><p>可以使用类似于sftp的工具将证书上传到<code>conf/cert</code>目录，然后使用git克隆项目代码到<code>code</code>目录。</p><pre><code class="Shell">cd codegit clone &lt;url&gt;</code></pre><p>回到项目目录，创建并激活虚拟环境。</p><pre><code class="Shell">python3 -m venv venvsource venv/bin/activate</code></pre><p>重建项目依赖项。</p><pre><code class="Shell">pip install -r code/teamproject/requirements.txt</code></pre><h3 id="uWSGI的配置"><a href="#uWSGI的配置" class="headerlink" title="uWSGI的配置"></a>uWSGI的配置</h3><ol><li><p>安装uWSGI。</p><pre><code class="Shell">pip install uwsgi</code></pre></li><li><p>修改uWSGI的配置文件（<code>/root/project/conf/uwsgi.ini</code>）。</p><pre><code class="INI">[uwsgi]# 配置前导路径base=/root/project# 配置项目名称name=teamproject# 守护进程master=true# 进程个数processes=4# 虚拟环境pythonhome=%(base)/venv# 项目地址chdir=%(base)/code/%(name)# 指定python解释器pythonpath=%(pythonhome)/bin/python# 指定uwsgi文件module=%(name).wsgi# 通信的地址和端口(自己服务器的IP地址和端口)socket=172.18.61.250:8000# 日志文件地址logto=%(base)/logs/uwsgi.log</code></pre><blockquote><p>说明：可以先将“通信的地址和端口”项等号前面改为http来进行测试，如果没有问题再改回    成socket，然后通过Nginx来实现项目的“动静分离”（静态资源交给Nginx处理，动态内容交给    uWSGI处理）。按照下面的方式可以启动uWSGI服务器。</p></blockquote></li><li><p>启动服务器。</p><pre><code class="Shell">nohup uwsgi --ini conf/uwsgi.ini &amp;</code></pre></li></ol><h3 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h3><ol><li><p>安装Nginx。</p><pre><code class="Shell">yum -y install nginx</code></pre></li><li><p>修改全局配置文件（<code>/etc/nginx/nginx.conf</code>）。</p><pre><code class="Nginx"># 配置用户user nginx;# 工作进程数(建议跟CPU的核数量一致)worker_processes auto;# 错误日志error_log /var/log/nginx/error.log;# 进程文件pid /run/nginx.pid;# 包含其他的配置include /usr/share/nginx/modules/*.conf;# 工作模式(多路IO复用方式)和连接上限events &#123;    use epoll;    worker_connections 1024;&#125;# HTTP服务器相关配置http &#123;    # 日志格式    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    # 访问日志    access_log  /var/log/nginx/access.log  main;    # 开启高效文件传输模式    sendfile            on;    # 用sendfile传输文件时有利于改善性能    tcp_nopush          on;    # 禁用Nagle来解决交互性问题    tcp_nodelay         on;    # 客户端保持连接时间    keepalive_timeout   30;    types_hash_max_size 2048;    # 包含MIME类型的配置    include             /etc/nginx/mime.types;    # 默认使用二进制流格式    default_type        application/octet-stream;    # 包含其他配置文件    include /etc/nginx/conf.d/*.conf;    # 包含项目的Nginx配置文件    include /root/project/conf/*.conf;&#125;</code></pre></li><li><p>编辑局部配置文件（<code>/root/project/conf/nginx.conf</code>）。</p><pre><code class="Nginx">server &#123;    listen      80;    server_name _;    access_log /root/project/logs/access.log;    error_log /root/project/logs/error.log;    location / &#123;        include uwsgi_params;        uwsgi_pass 172.18.61.250:8000;    &#125;    location /static/ &#123;        alias /root/project/stat/;        expires 30d;    &#125;&#125;server &#123;    listen      443;    server_name _;    ssl         on;    access_log /root/project/logs/access.log;    error_log /root/project/logs/error.log;    ssl_certificate     /root/project/conf/cert/214915882850706.pem;    ssl_certificate_key /root/project/conf/cert/214915882850706.key;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;    location / &#123;        include uwsgi_params;        uwsgi_pass 172.18.61.250:8000;    &#125;    location /static/ &#123;        alias /root/project/static/;        expires 30d;    &#125;&#125;</code></pre><p> 到此为止，我们可以启动Nginx来访问我们的应用程序，HTTP和HTTPS都是没有问题的，如果Nginx已经运行，在修改配置文件后，我们可以用下面的命令重新启动Nginx。</p></li><li><p>重启Nginx服务器。</p><pre><code class="Shell">nginx -s reload</code></pre><p> 或</p><pre><code class="Shell">systemctl restart nginx</code></pre></li></ol><blockquote><p>说明：可以对Django项目使用<code>python manage.py collectstatic</code>命令将静态资源收集到指定目录下，要做到这点只需要在项目的配置文件<code>settings.py</code>中添加<code>STATIC_ROOT</code>配置即可。</p></blockquote><h4 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h4><p>下面的配置中我们使用Nginx实现负载均衡，为另外的三个Nginx服务器（通过Docker创建）提供反向代理服务。</p><pre><code class="Shell">docker run -d -p 801:80 --name nginx1 nginx:latestdocker run -d -p 802:80 --name nginx2 nginx:latestdocker run -d -p 803:80 --name nginx3 nginx:latest</code></pre><pre><code class="Nginx">user root;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123;    worker_connections 1024;&#125;# 为HTTP服务配置负载均衡http &#123;    upstream xx &#123;        server 192.168.1.100 weight=2;        server 192.168.1.101 weight=1;        server 192.168.1.102 weight=1;    &#125;    server &#123;        listen       80 default_server;        listen       [::]:80 default_server;        listen       443 ssl;        listen       [::]:443 ssl;        ssl on;        access_log /root/project/logs/access.log;        error_log /root/project/logs/error.log;        ssl_certificate /root/project/conf/cert/214915882850706.pem;        ssl_certificate_key /root/project/conf/cert/214915882850706.key;        ssl_session_timeout 5m;        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        location / &#123;            proxy_set_header Host $host;            proxy_set_header X-Forwarded-For $remote_addr;            # proxy_set_header X-Real-IP $remote_addr;            # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_buffering off;            proxy_pass http://fangtx;        &#125;    &#125;&#125;</code></pre><blockquote><p>说明：Nginx在配置负载均衡时，默认使用WRR（加权轮询算法），除此之外还支持ip_hash、fair（需要安装upstream_fair模块）和url_hash算法。此外，在配置upstream模块时可以指定服务器的状态值，包括：backup（备份机器，其他服务器不可用时才将请求分配到该机器）、down、fail_timeout（请求失败达到max_fails后的暂停服务时间）、max_fails（允许请求失败的次数）和weight（轮询的权重）。</p></blockquote><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>当使用Nginx进行负载均衡配置时，要考虑负载均衡服务器宕机的情况。为此可以使用Keepalived来实现负载均衡主机和备机的热切换，从而保证系统的高可用性。Keepalived的配置还是比较复杂，通常由专门做运维的人进行配置，一个基本的配置可以参照<a href="https://www.jianshu.com/p/dd93bc6d45f5">《Keepalived的配置和使用》</a>。</p><h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><p>下面还是基于Docker来演示如何配置MySQL主从复制。我们事先准备好MySQL的配置文件以及保存MySQL数据和运行日志的目录，然后通过Docker的数据卷映射来指定容器的配置、数据和日志文件的位置。</p><pre><code class="Shell">root└── mysql    ├── master    │   ├── conf    |    └── data    └── slave-1    |    ├── conf    |    └── data    └── slave-2    |    ├── conf    |    └── data    └── slave-3        ├── conf        └── data</code></pre><ol><li><p>MySQL的配置文件（master和slave的配置文件需要不同的server-id）。</p><pre><code>[mysqld]pid-file=/var/run/mysqld/mysqld.pidsocket=/var/run/mysqld/mysqld.sockdatadir=/var/lib/mysqllog-error=/var/log/mysql/error.logserver-id=1log-bin=/var/log/mysql/mysql-bin.logexpire_logs_days=30max_binlog_size=256Msymbolic-links=0# slow_query_log=ON# slow_query_log_file=/var/log/mysql/slow.log# long_query_time=1</code></pre></li><li><p>创建和配置master。</p><pre><code class="Shell">docker run -d -p 3306:3306 --name mysql-master \-v /root/mysql/master/conf:/etc/mysql/mysql.conf.d \-v /root/mysql/master/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 mysql:5.7docker exec -it mysql-master /bin/bash</code></pre><pre><code class="Shell">mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.7.23-log MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; grant replication slave on *.* to &#39;slave&#39;@&#39;%&#39; identified by &#39;iamslave&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000003 |      590 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)mysql&gt; quitByeexit</code></pre><p>上面创建Docker容器时使用的<code>-v</code>参数（<code>--volume</code>）表示映射数据卷，冒号前是宿主机的目录，冒号后是容器中的目录，这样相当于将宿主机中的目录挂载到了容器中。</p></li><li><p>备份主表中的数据（如果需要的话）。</p><pre><code class="SQL">mysql&gt; flush table with read lock;</code></pre><pre><code class="Bash">mysqldump -u root -p 123456 -A -B &gt; /root/backup/mysql/mybak$(date +&quot;%Y%m%d%H%M%S&quot;).sql</code></pre><pre><code class="SQL">mysql&gt; unlock table;</code></pre></li><li><p>创建和配置slave。</p><pre><code class="Shell">docker run -d -p 3308:3306 --name mysql-slave-1 \-v /root/mysql/slave-1/conf:/etc/mysql/mysql.conf.d \-v /root/mysql/slave-1/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \--link mysql-master:mysql-master mysql:5.7docker run -d -p 3309:3306 --name mysql-slave-2 \-v /root/mysql/slave-2/conf:/etc/mysql/mysql.conf.d \-v /root/mysql/slave-2/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \--link mysql-master:mysql-master mysql:5.7docker run -d -p 3310:3306 --name mysql-slave-3 \-v /root/mysql/slave-3/conf:/etc/mysql/mysql.conf.d \-v /root/mysql/slave-3/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \--link mysql-master:mysql-master mysql:5.7docker exec -it mysql-slave-1 /bin/bash</code></pre><pre><code class="Shell">mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.23-log MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; reset slave;Query OK, 0 rows affected (0.02 sec)mysql&gt; change master to master_host=&#39;mysql-master&#39;, master_user=&#39;slave&#39;, master_password=&#39;iamslave&#39;, master_log_file=&#39;mysql-bin.000003&#39;, master_log_pos=590;Query OK, 0 rows affected, 2 warnings (0.03 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)mysql&gt; show slave status\G*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: mysql57                  Master_User: slave                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000001          Read_Master_Log_Pos: 590               Relay_Log_File: f352f05eb9d0-relay-bin.000002                Relay_Log_Pos: 320        Relay_Master_Log_File: mysql-bin.000001             Slave_IO_Running: Yes            Slave_SQL_Running: Yes             Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: 0                   Last_Error:                 Skip_Counter: 0          Exec_Master_Log_Pos: 590              Relay_Log_Space: 534              Until_Condition: None               Until_Log_File:                Until_Log_Pos: 0           Master_SSL_Allowed: No           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No                Last_IO_Errno: 0                Last_IO_Error:               Last_SQL_Errno: 0               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: 1                  Master_UUID: 30c38043-ada1-11e8-8fa1-0242ac110002             Master_Info_File: /var/lib/mysql/master.info                    SQL_Delay: 0          SQL_Remaining_Delay: NULL      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates           Master_Retry_Count: 86400                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: 0         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:1 row in set (0.00 sec)mysql&gt; quitByeexit</code></pre><p>接下来可以如法炮制配置出slave2和slave3，这样就可以搭建起一个“一主带三从”的主从复制环境。上面创建创建容器时使用的<code>--link</code>参数用来配置容器在网络上的主机名（网络地址别名）。</p></li></ol><p>配置好主从复制后，写数据的操作应该master上执行，而读数据的操作应该在slave上完成。为此，在Django项目中需要配置DATABASE_ROUTERS并通过自定义的主从复制路由类来实现读写分离操作，如下所示：</p><pre><code class="Python">DATABASE_ROUTERS = [    # 此处省略其他配置    &#39;common.routers.MasterSlaveRouter&#39;,]</code></pre><pre><code class="Python">class MasterSlaveRouter(object):    &quot;&quot;&quot;主从复制路由&quot;&quot;&quot;    @staticmethod    def db_for_read(model, **hints):        &quot;&quot;&quot;        Attempts to read auth models go to auth_db.        &quot;&quot;&quot;        return random.choice((&#39;slave1&#39;, &#39;slave2&#39;, &#39;slave3&#39;))    @staticmethod    def db_for_write(model, **hints):        &quot;&quot;&quot;        Attempts to write auth models go to auth_db.        &quot;&quot;&quot;        return &#39;default&#39;    @staticmethod    def allow_relation(obj1, obj2, **hints):        &quot;&quot;&quot;        Allow relations if a model in the auth app is involved.        &quot;&quot;&quot;        return None    @staticmethod    def allow_migrate(db, app_label, model_name=None, **hints):        &quot;&quot;&quot;        Make sure the auth app only appears in the &#39;auth_db&#39;        database.        &quot;&quot;&quot;        return True</code></pre><p>上面的内容参考了Django官方文档的<a href="https://docs.djangoproject.com/en/2.1/topics/db/multi-db/#topics-db-multi-db-routing">DATABASE_ROUTERS配置</a>，对代码进行了适当的调整。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>事实上，项目上线中最为麻烦的事情就是配置软件运行环境，环境的差异会给软件的安装和部署带来诸多的麻烦，而Docker正好可以解决这个问题。关于Docker在之前的文档中我们已经介绍过了，接下来我们对Docker的知识做一些必要的补充。</p><ol><li><p>创建镜像文件。</p><p>将容器保存成镜像：</p><pre><code class="Shell">docker commit -m &quot;...&quot; -a &quot;jackfrued&quot; &lt;container-name&gt; jackfrued/&lt;image-name&gt;</code></pre><p>使用Dockerfile构建镜像：</p><pre><code class="Dockerfile"># 指定基础镜像文件FROM centos:latest# 指定维护者信息MAINTAINER jackfrued# 执行命令RUN yum -y install gccRUN cd ~RUN mkdir -p project/codeRUN mkdir -p project/logs# 拷贝文件COPY ...# 暴露端口EXPOSE ...# 在容器启动时执行命令CMD ~/init.sh</code></pre><pre><code class="Shell">docker build -t jackfrued/&lt;image-name&gt; .</code></pre></li><li><p>镜像的导入和导出。</p><pre><code class="Shell">docker save -o &lt;file-name&gt;.tar &lt;image-name&gt;:&lt;version&gt;docker load -i &lt;file-name&gt;.tar</code></pre></li><li><p>推送到DockerHub服务器。</p><pre><code class="Shell">docker tag &lt;image-name&gt;:&lt;version&gt; jackfrued/&lt;name&gt;docker logindocker push jackfrued/&lt;name&gt;</code></pre></li><li><p>容器之间的通信。</p><pre><code class="Shell">docker run --link &lt;container-name&gt;:&lt;alias-name&gt;</code></pre></li></ol><p>如果我们能够在Docker中完成项目的部署，并且将整个部署好的容器打包成镜像文件进行分发和安装，这样就可以解决项目在多个节点上进行部署时可能遇到的麻烦，而且整个部署可以在很短的时间内完成。</p><h3 id="Supervisor"><a href="#Supervisor" class="headerlink" title="Supervisor"></a>Supervisor</h3><p><a href="https://github.com/Supervisor/supervisor">Supervisor</a>是一个用Python写的进程管理工具，可以很方便的用来在类Unix系统下启动、重启（自动重启程序）和关闭进程，目前Supervisor暂时还没有提供对Python 3的支持，可以通过Python 2来安装和运行Supervisor，再通过Supervisor来管理Python 3的程序。</p><blockquote><p><strong>提示</strong>：还有一个和Supervisor功能类似的工具名为Circus，支持Python 3。</p></blockquote><ol><li><p>安装Supervisor。</p><pre><code class="Shell">virtualenv -p /usr/bin/python venvsource venv/bin/activatepip install supervisor</code></pre></li><li><p>查看Supervisor的配置文件。</p><pre><code class="Shell">vim /etc/supervisord.conf</code></pre><pre><code class="INI">; 此处省略上面的代码; The [include] section can just contain the &quot;files&quot; setting.  This; setting can list multiple files (separated by whitespace or; newlines).  It can also contain wildcards.  The filenames are; interpreted as relative to this file.  Included files *cannot*; include files themselves.[include]files = supervisord.d/*.ini</code></pre><p> 可以看出自定义的管理配置代码可以放在<code>/etc/supervisord.d</code>目录中，并且文件名以<code>ini</code>作为后缀即可。</p></li><li><p>编写自己的配置文件<code>fangtx.ini</code>并放在<code>/etc/supervisord.d</code>目录中。</p><pre><code class="INI">[program:project]command=uwsgi --ini /root/project/conf/uwsgi.inistopsignal=QUITautostart=trueautorestart=trueredirect_stderr=true[program:celery]; Set full path to celery program if using virtualenvcommand=/root/project/venv/bin/celery -A fangtx workeruser=rootnumprocs=1stdout_logfile=/var/log/supervisor/celery.logstderr_logfile=/var/log/supervisor/celery_error.logautostart=trueautorestart=truestartsecs=10; Need to wait for currently executing tasks to finish at shutdown.; Increase this if you have very long running tasks.;stopwaitsecs = 600; When resorting to send SIGKILL to the program to terminate it; send SIGKILL to its whole process group instead,; taking care of its children as well.killasgroup=true; Set Celery priority higher than default (999); so, if rabbitmq is supervised, it will start first.priority=1000</code></pre></li><li><p>启动Supervisor。</p><pre><code class="Shell">supervisorctl -c /etc/supervisord.conf</code></pre></li></ol><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><ol><li><p>常用开源软件。</p><table><thead><tr><th>功能</th><th>开源方案</th></tr></thead><tbody><tr><td>版本控制工具</td><td>Git、Mercurial、SVN</td></tr><tr><td>缺陷管理</td><td>Redmine、Mantis</td></tr><tr><td>负载均衡</td><td>Nginx、LVS、HAProxy</td></tr><tr><td>邮件服务</td><td>Postfix、Sendmail</td></tr><tr><td>HTTP服务</td><td>Nginx、Apache</td></tr><tr><td>消息队列</td><td>RabbitMQ、ZeroMQ、Redis、Kafka</td></tr><tr><td>文件系统</td><td>FastDFS</td></tr><tr><td>基于位置服务（LBS）</td><td>MongoDB、Redis</td></tr><tr><td>监控服务</td><td>Nagios、Zabbix</td></tr><tr><td>关系型数据库</td><td>MySQL、PostgreSQL</td></tr><tr><td>非关系型数据库</td><td>MongoDB、Redis、Cassandra、TiDB</td></tr><tr><td>搜索引擎</td><td>ElasticSearch、Solr</td></tr><tr><td>缓存服务</td><td>Mamcached、Redis</td></tr></tbody></table></li><li><p>常用云服务。</p><table><thead><tr><th>功能</th><th>可用的云服务</th></tr></thead><tbody><tr><td>团队协作工具</td><td>Teambition、钉钉</td></tr><tr><td>代码托管平台</td><td>Github、Gitee、CODING</td></tr><tr><td>邮件服务</td><td>SendCloud</td></tr><tr><td>云存储（CDN）</td><td>七牛、OSS、LeanCloud、Bmob、又拍云、S3</td></tr><tr><td>移动端推送</td><td>极光、友盟、百度</td></tr><tr><td>即时通信</td><td>环信、融云</td></tr><tr><td>短信服务</td><td>云片、极光、Luosimao、又拍云</td></tr><tr><td>第三方登录</td><td>友盟、ShareSDK</td></tr><tr><td>网站监控和统计</td><td>阿里云监控、监控宝、百度云观测、小鸟云</td></tr></tbody></table></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目部署上线指南&quot;&gt;&lt;a href=&quot;#项目部署上线指南&quot; class=&quot;headerlink&quot; title=&quot;项目部署上线指南&quot;&gt;&lt;/a&gt;项目部署上线指南&lt;/h2&gt;&lt;h3 id=&quot;准备上线&quot;&gt;&lt;a href=&quot;#准备上线&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
</feed>
